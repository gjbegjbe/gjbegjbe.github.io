<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gjbegjbe.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言每个tab页面都有自己的渲染进程，而每个渲染进程又由多个线程组成，每个渲染进程都有一个主线程，主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要⼀个系统来统筹调度这些任务。这个系统就是今天的主角 – 消息队列和事件循环系统。 JS为什么是单线程的？为什么需要异步？既">
<meta property="og:type" content="article">
<meta property="og:title" content="任务队列与事件循环">
<meta property="og:url" content="https://gjbegjbe.github.io/2022/08/22/%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/index.html">
<meta property="og:site_name" content="gjbe">
<meta property="og:description" content="前言每个tab页面都有自己的渲染进程，而每个渲染进程又由多个线程组成，每个渲染进程都有一个主线程，主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要⼀个系统来统筹调度这些任务。这个系统就是今天的主角 – 消息队列和事件循环系统。 JS为什么是单线程的？为什么需要异步？既">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231638678.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231742076.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208230953801.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231715951.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231021363.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231721785.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231723029.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231426418.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231656730.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231658682.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231700021.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231701462.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231706622.png">
<meta property="article:published_time" content="2022-08-22T07:48:40.000Z">
<meta property="article:modified_time" content="2022-08-23T12:02:56.072Z">
<meta property="article:author" content="gjbe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231638678.png">

<link rel="canonical" href="https://gjbegjbe.github.io/2022/08/22/%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>任务队列与事件循环 | gjbe</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-MXN04CBZXN"></script>
    <script data-pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-MXN04CBZXN');
      }
    </script>


  <script data-pjax>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?49e659bd9c945277731a2e39ec566e9d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="gjbe" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">gjbe</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/gjbegjbe" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gjbegjbe.github.io/2022/08/22/%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gjbe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gjbe">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          任务队列与事件循环
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-22 15:48:40" itemprop="dateCreated datePublished" datetime="2022-08-22T15:48:40+08:00">2022-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-23 20:02:56" itemprop="dateModified" datetime="2022-08-23T20:02:56+08:00">2022-08-23</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每个tab页面都有自己的渲染进程，而每个渲染进程又由多个线程组成，每个渲染进程都有一个主线程，主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要⼀个系统来统筹调度这些任务。这个系统就是今天的主角 – 消息队列和事件循环系统。</p>
<p>JS为什么是单线程的？为什么需要异步？既然 JS 是单线程的，只能在⼀条线程上执⾏，⼜是如何实现的异步呢？</p>
<p>本文Event Loop 只针对浏览器，暂不为 node 展开讨论。</p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>JS是单线程执行的，指的是一个进程里有且只有一个主线程负责执行js代码。</p>
<p>进程是CPU资源分配的最小单位。线程是CPU调度的最小单位。</p>
<h3 id="多线程与多进程"><a href="#多线程与多进程" class="headerlink" title="多线程与多进程"></a>多线程与多进程</h3><p>多进程是指同一个时间里，同一个计算机系统允许两个或者两个以上的进程处于运行状态。比如可以在听歌的同时写代码。</p>
<p>多线程是指程序中包含多个执行流，一个程序中可以同时运行多个不同的线程来执行不同的任务，允许单个程序创建多个并行执行的线程来完成各自的任务。⽐如打开 QQ 的这个进程，可能同时有接收消息线程、传输⽂件线程、检测安全线程…… 所以⼀个⽹⻚能够正常的运⾏并和⽤户交互，也需要很多个进程之间相互配合。</p>
<p>浏览器打开一个Tab页就是创建了一个进程，一个进程可以有多个线程，JS 引擎线程、HTTP 请求线程、事件触发线程、GUI 渲染线程等等。发起请求是就创建了一个线程，请求结束后线程可能被销毁。</p>
<p>由于单线程原因，主线程一次只能执行一个任务，每次任务执行完成会去消息队列取新的任务执行。</p>
<ol>
<li>一个任务执行时间过长，导致主线程长期被霸占，如何优化？&#x3D;&#x3D;&gt; 引入异步编程，实现<br>非阻塞调用</li>
<li>如何处理任务优先级？ &#x3D;&#x3D;&#x3D;》引⼊任务队列，先进先出来管理任务执行顺序</li>
<li>紧急任务无法插队？&#x3D;&#x3D;&#x3D;》引入宏任务、微任务处理不同任务队列的优先级</li>
</ol>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>既然 JS 是单线程的，那么诸如 onclick 回调，setTimeout，Ajax 这些都是怎么实现的呢？是因为浏览器或 node（宿主环境）是多线程的，即浏览器搞了⼏个其他线程去辅助 JS 线程的运⾏。</p>
<p>浏览器有很多线程，例如：</p>
<ol>
<li>GUI 渲染线程</li>
<li>JS 引擎线程</li>
<li>定时器触发线程 (setTimeout)</li>
<li>浏览器事件线程 (onclick)</li>
<li>http 异步线程</li>
<li>EventLoop 轮询处理线程</li>
</ol>
<p>其中，1、2、4 为常驻线程。</p>
<p>分类：<br>类别 A：GUI 渲染线程<br>类别 B：JS 引擎线程<br>类别 C：EventLoop 轮询处理线程<br>类别 D：其他线程，有 定时器触发线程 (setTimeout)、http 异步线程、浏览器事件线程 (onclick)等等。</p>
<h3 id="JS-引擎线程"><a href="#JS-引擎线程" class="headerlink" title="JS 引擎线程"></a>JS 引擎线程</h3><p>JS 引擎线程，我们把它称为主线程，即运⾏ JS 代码的那个线程（不包括异步的那些代码）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>()</span><br><span class="line"><span class="title function_">ajax</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>()</span><br></pre></td></tr></table></figure>

<p>第 1、4 ⾏代码是同步代码，直接在主线程中运⾏；第 2、3 ⾏代码交给其他线程运⾏。<br>主线程运⾏ JS 代码时，会⽣成个执⾏栈，可以处理函数的嵌套。</p>
<h4 id="消息队列（任务队列）"><a href="#消息队列（任务队列）" class="headerlink" title="消息队列（任务队列）"></a>消息队列（任务队列）</h4><p>可以理解为⼀个静态的队列存储结构，⾮线程，只做存储，⾥⾯存的是⼀堆异步成功后的回调函数字符串，肯定是先成功的异步的回调函数在队列的前⾯，后成功的在后⾯。<br>注意：是<strong>异步成功后</strong>，才把其回调函数扔进队列中，⽽不是⼀开始就把所有异步的回调函数扔进队列。<strong>⽐如 setTimeout 3 秒后执⾏⼀个函数，那么这个函数是在 3 秒后才进队列的。</strong></p>
<h3 id="其他线程"><a href="#其他线程" class="headerlink" title="其他线程"></a>其他线程</h3><p>定时器触发线程 (setTimeout)、http 异步线程、浏览器事件线程 (onclick)<br>主线程执⾏ JS 代码时，碰到异步代码，就把它丢给各⾃相对应的线程去执⾏，⽐如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(fun A)</span><br><span class="line"><span class="title function_">ajax</span>(fun B)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>()</span><br><span class="line">dom.<span class="title function_">onclick</span>(func C)</span><br></pre></td></tr></table></figure>

<p>主线程在运⾏这段代码时，碰到 2 setTimeout (fun A)，把这⾏代码交给定时器触发线程去执⾏；碰到 3 ajax (fun B)，把这⾏代码交给 http 异步线程去执⾏；碰到 5 dom.onclick (func C) ，把这⾏代码交给浏览器事件线程去执⾏。<br>注意： 这⼏个异步代码的回调函数 fun A，fun B，fun C，各⾃的线程都会保存着的，因为需要在未来的某个时候，将回调函数交给主线程去执⾏。</p>
<p>作用：</p>
<ol>
<li>执⾏主线程扔过来的异步代码，并执⾏代码</li>
<li>保存回调函数，在未来的某个时刻，通知 EventLoop 轮询处理线程过来取相应的回调函数然后执⾏（下⾯会讲）</li>
</ol>
<p>区别：</p>
<ul>
<li><p>对于 setTimeout 代码，定时器触发线程在接收到代码时就开始计时，时间到了将回调函数扔进队列。</p>
</li>
<li><p>对于 ajax 代码，http 异步线程⽴即发起 http 请求，请求成功后将回调函数扔进队列。</p>
</li>
<li><p>对于 dom.onclick，浏览器事件线程会先监听 dom，直到 dom 被点击了，才将回调函数扔进队列。</p>
</li>
</ul>
<h3 id="EventLoop-轮询处理线程"><a href="#EventLoop-轮询处理线程" class="headerlink" title="EventLoop 轮询处理线程"></a>EventLoop 轮询处理线程</h3><ol>
<li>主线程，处理同步代码</li>
<li>类别 D 的⼏个异步线程，处理异步代码</li>
<li>消息队列，存储着异步成功后的回调函数，⼀个静态存储结构</li>
</ol>
<p>消息队列作⽤就是存放着未来要执⾏的回调函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<p>在⼀开始，消息队列是空的，在 2 秒后，⼀个 () &#x3D;&gt; { console.log (1) } 的函数进⼊队列，在 3 秒后，⼀个 () &#x3D;&gt; { console.log (2) } 的函数进⼊队列，此时队列⾥有两个元素，主线程从队列头中挨个取出并执⾏。</p>
<p>这需要⼀个中介去专⻔去沟通它们 3 个，⽽这个中介，就是 EventLoop 轮询处理线程</p>
<h2 id="Event-Loop（事件循环）"><a href="#Event-Loop（事件循环）" class="headerlink" title="Event Loop（事件循环）"></a>Event Loop（事件循环）</h2><p>JS是一种单线程语言，一次只能完成一个任务。如果有多个任务，就必须排队，前面一个任务完成再完成下面的任务。如果前面的任务过长，后面的就会一直等待，拖延整个程序。为了解决这个问题，引入Event Loop，将任务分为同步任务和异步任务，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会交给相应的WebAPIs 线程处理，在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231638678.png"></p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231742076.png"></p>
<p>事件循环可以理解为由三部分组成：</p>
<ol>
<li>主线程执行栈</li>
<li>异步任务等待触发：浏览器为异步任务单独开辟的几个辅佐线程 (事件触发线程、Http异步请求线程、GUI 渲染线程) 可以统⼀理解为 WebAPIs</li>
<li>异步任务队列：以队列的数据结构对事件任务进行管理，特点是先进先出，后进后出。</li>
</ol>
<p>模型特点：</p>
<ol>
<li>所有同步任务都会在主线程上执行，同时会形成一个执行栈（execution context<br>stack），直至栈空，即任务结束。</li>
<li>主线程之外，还存在一个任务队列（task queue）。只要异步任务有了运行结果，就在<br>任务队列之中放置⼀个事件。</li>
<li>一旦执行栈上的任务执行完毕，系统就会从任务队列读取新的任务，结束等待状态，进入执行栈，开始执行，循环往复。</li>
</ol>
<p>从C语言角度理解：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TaskQueue task_queue；</span><br><span class="line"><span class="type">void</span> <span class="title function_">ProcessTask</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ProcessDelayTask</span><span class="params">()</span>;</span><br><span class="line"><span class="type">bool</span> keep_running = <span class="literal">true</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MainThread</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (task_queue.waitForTask()) &#123;</span><br><span class="line">    Task task = task_queue.takeTask();<span class="comment">// 取出消息队列中任务</span></span><br><span class="line">    ProcessTask(task);<span class="comment">// 执⾏任务</span></span><br><span class="line">    ProcessDelayTask()<span class="comment">// 执⾏延迟队列中的任务</span></span><br><span class="line">    <span class="keyword">if</span>(!keep_running) <span class="comment">//如果设置了退出标志，那么直接退出线程循环</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h3><p>A callback is a function that is passed as an argument to another function and is executed after its parent function has completed.<br>回调是作为参数传递给另一个函数并在其父函数完成后执行的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步请求的回调函数</span></span><br><span class="line">$.<span class="title function_">get</span>(<span class="string">&#x27;api/find&#x27;</span>,<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 点击事件的回调函数</span></span><br><span class="line">$(<span class="string">&#x27;.btn&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;this is a callback of click event&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 数组中遍历每⼀项调⽤的回调函数</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 同步回调</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getNodes</span>(<span class="params">params,callback</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> list = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(params)</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line"><span class="title function_">callback</span>(list)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getNodes</span>(<span class="string">&#x27;[1,2,3]&#x27;</span>,<span class="keyword">function</span>(<span class="params">list</span>)&#123;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>既可以有同步回调，也可以有异步回调，还可以有事件处理回调和延迟函数回调。</p>
<h3 id="同步vs异步"><a href="#同步vs异步" class="headerlink" title="同步vs异步"></a>同步vs异步</h3><p>同步就是后⼀个任务等待前⼀个任务结束，然后再执⾏，程序的执⾏顺序与任务的排列顺序是⼀致的、同步的。</p>
<p>异步则完全不同，从程序⻆度来理解就是改变程序正常执⾏顺序的操作，每⼀个任务有⼀个或多个回调函数（callback），前⼀个任务结束后，不是执⾏后⼀个任务，⽽是执⾏回调函数，后⼀个任务则是不等前⼀个任务结束就执⾏，所以程序的执⾏顺序与任务的排列顺序是不⼀致的、异步的。</p>
<p>JS作为一种单线程的语言如何实现异步的？</p>
<p>JS 异步的实现靠的就是浏览器的多线程，当他遇到异步 API 时，就将这个任务交给对应的线程，当这个异步 API 满⾜回调条件时，对应的线程⼜通过事件触发线程将这个事件放⼊任务队列，然后主线程执⾏完主线任务后从任务队列取出任务事件继续执⾏。</p>
<p><strong>总结：</strong></p>
<p>同步 &#x2F; 异步指的是各个任务之间执⾏顺序的确定性。同时， 任务≠回调函数 , 不管是同步任务，异步任务都可以通过回调函数去实现。</p>
<h4 id="从同步异步角度理解JS的执行机制"><a href="#从同步异步角度理解JS的执行机制" class="headerlink" title="从同步异步角度理解JS的执行机制"></a>从同步异步角度理解JS的执行机制</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="comment">// 200ms后，新任务task_1进⼊ 任务队列</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;,<span class="number">200</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果是132，思路（暂不考虑宏任务微任务）：</p>
<ol>
<li>整体 script 作为第⼀个任务进⼊主线程，console 输出 1;</li>
<li>遇到异步 API setTimeout ，将异步回调函数交给 Web API 处理 (此处为定时器触发线程，200ms 之后，即满⾜触发条件后，将 task_1 推⼊任务队列 task queue )。</li>
<li>主线程继续往下执⾏，console 输出3，任务执⾏结束，调⽤栈为空</li>
<li>进⼊下⼀个循环，取出任务队列中的下个任务，此时任务队列为空，主线程进⼊等待状态。</li>
<li>直到 200ms 之后，发现新推⼊任务队列的 task_1 , 开始执⾏，console 输出 2</li>
</ol>
<h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><p>javascript 是⼀⻔单线程的脚本语⾔，也就意味着同⼀个时间只能做⼀件事，但是单线程有⼀个问题：⼀旦这个线程被阻塞就⽆法继续⼯作了，这肯定是不⾏的。上⾯谈的EventLoop 模型通过异步编程实现⾮阻塞的调⽤效果⽅式解决了⼀个任务⻓时间霸占线程问题，但由于队列是⼀种数据结构，可以存放要执⾏的任务。它符合队列先进先出的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取，但这不能解决任务优先级问题 (紧急任务插队的需求)。为解决这个问题引⼊宏任务，微任务概念。</p>
<h4 id="宏任务VS微任务"><a href="#宏任务VS微任务" class="headerlink" title="宏任务VS微任务"></a>宏任务VS微任务</h4><p>ES6 规范中，Microtask 称为 jobs，Macrotask 称为 task。即微任务是 ES 对异步的定义；⽽宏任务是浏览器对异步的定义。</p>
<p>宏任务与微任务都是独⽴于主执⾏栈之外的另外两个队列。<br>为了处理任务的优先级，权衡效率和实时性。浏览器端事件循环中的异步队列有两种：Macrotask（宏任务）队列和 Microtask（微任务）队列.</p>
<table>
<thead>
<tr>
<th></th>
<th>宏任务 (Macrotask)</th>
<th>微任务 (Microtask)</th>
</tr>
</thead>
<tbody><tr>
<td>谁发起</td>
<td>浏览器、Node</td>
<td>Javascript</td>
</tr>
<tr>
<td>具体事件</td>
<td>script（全局任务）, setTimeout, setInterval, setImmediate, I&#x2F;O, UI rendering</td>
<td>process.nextTick, Promise 的 then 或 catch, Object.observer, MutationObserver</td>
</tr>
</tbody></table>
<p>在事件循环这个机制当中，我们将进⾏⼀次循环操作称为 tick ，每⼀次 tick 的任务处理模型是⽐较复杂的，但关键步骤如下：</p>
<ol>
<li>进⼊循环，⾸先选择最先进⼊宏任务队列的任务 (oldest task)，如果有则执⾏ (⼀次)</li>
<li>检查是否存在 Microtasks，如果存在则不停地执⾏，直⾄清空微任务 (Microtasks Queue)，此时执⾏栈也为清空了。</li>
<li>GUI 线程更新 (render) 界⾯（与主线程互斥）</li>
<li>进⼊下⼀个 Tick 主线程重复执⾏上述步骤</li>
</ol>
<p>注意：new Promise 执⾏本身时是属于同步代码，只有.then 才是微任务</p>
<h3 id="Event-Loop-的模型-Macrotask-Microtask"><a href="#Event-Loop-的模型-Macrotask-Microtask" class="headerlink" title="Event Loop 的模型 (Macrotask + Microtask)"></a>Event Loop 的模型 (Macrotask + Microtask)</h3><p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208230953801.png"></p>
<p>这个 Event Loop 模型运⾏机制如下：</p>
<ol>
<li>选择当前要执⾏的宏任务队列，选择任务队列中最先进⼊的任务 ( oldest task )，如果<br>宏任务队列为空即 null，则执⾏跳转到微任务（MicroTask）的执⾏步骤。</li>
<li>将事件循环中的任务设置为已选择任务。</li>
<li>执⾏任务。当执⾏栈中的函数调⽤到⼀些异步执⾏的 API（例如异步 Ajax，DOM 事件，<br>setTimeout 等 API），则会开启对应的线程（Http 异步请求线程，事件触发线程和定时<br>器触发线程）进⾏监控和控制，当异步任务的事件满⾜触发条件时，对应的线程则会把<br>该事件的回调函数推进任务队列 (task queue) 中，等待主线程读取执⾏。</li>
<li>任务结束后，将事件循环中当前运⾏任务设置为 null，同时将已经运⾏完成的任务从任<br>务队列中删除。</li>
<li>microtasks 步骤：进⼊ microtask 检查点。⽤户代理会执⾏以下步骤：<br>5.1 设置 microtask 检查点标志为 true。<br>5.2 当事件循环 microtask 执⾏不为空时：选择⼀个最先进⼊的 microtask 队列的<br>microtask，将事件循环的 microtask 设置为已选择的 microtask，运⾏ microtask，将已<br>经执⾏完成的 microtask 置为 null，移出 microtask 中的 microtask。<br>5.3 清理 IndexDB 事务<br>5.4 设置进⼊ microtask 检查点的标志为 false。</li>
<li>更新界⾯渲染。</li>
<li>返回第⼀步。</li>
</ol>
<p>流程图：</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231715951.png"></p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231021363.png"></p>
<p>之前说的所有异步都放进⼀个任务消息队列⾥，现在也就是分为两个任务队列了，⽐较容易理解。</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231721785.png"></p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231723029.png"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;    </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve1&#x27;</span>)</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">// 创建微任务 micro_1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">// 创建了⼀个setTimeout的宏任务 macro_1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve2&#x27;</span>)</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">// 创建微任务 micro_2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>整体 script 作为第⼀个宏任务进⼊主线程，console 输出 script start ，</p>
</li>
<li><p>遇到 new Promise, ⼊栈处理，发现是同步回调，直接执⾏，console 输出 resolve1 ；<br>遇到 then，⼊栈处理，发现是异步回调函数（创建微任务 micro_1），出栈，移交给对应Web API 处理，将回调函数加⼊微任务队列尾部；</p>
</li>
<li><p>遇到 setTimeout ⼊栈处理，发现是异步回调函数（创建宏任务 macro_1），出栈，移交给 Web API（此处为定时器触发线程）处理 (0 秒等待后，将回调函数加到宏任务队列尾部)；</p>
</li>
<li><p>遇到 new Promise, ⼊栈处理，发现是同步回调，直接执⾏，console 输出 resolve2；遇到 then，⼊栈处理，发现是异步回调（创建微任务 micro2），出栈，移交给 Web API 处理，将回调函数加⼊微任务队列尾部；</p>
</li>
<li><p>执⾏到 script 任务末尾，console 输出 script end , 此时执⾏栈已清空 (将当前任务从任<br>务队列移除)，进⼊ microtask 检查点，此时任务队列情况如下：</p>
<table>
<thead>
<tr>
<th>任务队列</th>
<th>任务1</th>
<th>任务2</th>
</tr>
</thead>
<tbody><tr>
<td>宏任务队列1</td>
<td>macro_1</td>
<td></td>
</tr>
<tr>
<td>微任务队列</td>
<td>micro_1</td>
<td>micro_2</td>
</tr>
</tbody></table>
</li>
<li><p>取出第⼀个微任务，⼊栈处理，console 直接输出 promise1 , 出栈；</p>
</li>
<li><p>继续从微任务队列中取下⼀个，⼊栈处理，console 直接输出 promise2 ，出栈，</p>
</li>
<li><p>继续从微任务队列中取下⼀个，发现微任务队列已清空，</p>
</li>
<li><p>渲染界⾯，结束第⼀轮事件循环；</p>
</li>
<li><p>从宏任务队列中取出第⼀个宏任务，⼊栈处理，发现是 console 直接输出 timeout，未发现有微任务，再次渲染界⾯，结束本轮事件循环。</p>
</li>
</ol>
<h4 id="任务的优先级"><a href="#任务的优先级" class="headerlink" title="任务的优先级"></a>任务的优先级</h4><p>Event Loop事件循环是通过任务队列的机制来协调⼯作的。⼀个 Event Loop 中，可以有⼀个或者多个任务队列 (task queue)，⼀个任务队列便是⼀系列有序任务 (task) 的集合；每个任务都有⼀个任务源 (task source)，源⾃同⼀个任务源的 task 必须放到同⼀个任务队列，从不同源来的则被添加到不同队列。</p>
<p>一个事件循环有一个或多个任务队列。 任务队列是一组任务。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;outer&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;inner&quot;</span>&gt;</span>点击我试试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> $inner = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#inner&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> $outer = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#outer&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">handler</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;click&#x27;</span>) <span class="comment">// 直接输出 (js同步代码)</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function"><span class="params">_</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise&#x27;</span>)) <span class="comment">// 注册微任务</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function"><span class="params">_</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&gt;promise&#x27;</span>))</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;) <span class="comment">// 注册宏任务</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">requestAnimationFrame</span>(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;animationFrame&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function"><span class="params">_</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;animationFrame&gt;promise&#x27;</span>))</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;) <span class="comment">// 注册宏任务</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    $outer.<span class="title function_">setAttribute</span>(<span class="string">&#x27;data-random&#x27;</span>, <span class="title class_">Math</span>.<span class="title function_">random</span>()) <span class="comment">// DOM属性修改，触发微任务</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;observer&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;).<span class="title function_">observe</span>($outer, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">attributes</span>: <span class="literal">true</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  $inner.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handler)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  $outer.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handler)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 左边是⾼优先级</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 宏任务: requestAnimationFrame=&gt;setTimeout =&gt; setInterval </span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// =&gt; setImmediate(nodeJS) =&gt; I/O =&gt; UI Rendering</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 微任务: process.nextTick(nodeJS)</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// =&gt; Promise(Promise.then)/mutationObserver</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>点击#outter 输出结果，可以看出：requestAnimationFrame 优先级⽐ setTimeout ⾼</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tick1</span></span><br><span class="line">click</span><br><span class="line">resolve1</span><br><span class="line">promise</span><br><span class="line">observer</span><br><span class="line"><span class="comment">// Tick2</span></span><br><span class="line">animationFrame</span><br><span class="line">animationFrame&gt;promise</span><br><span class="line"><span class="comment">// Tick3</span></span><br><span class="line">timeout</span><br><span class="line">timeout&gt;promise</span><br></pre></td></tr></table></figure>

<p>点击#inner 输出结果，可以看出：每个 macroTask 队列中的 macroTask 按顺序执⾏，在每<br>macroTask 之间渲染⻚⾯</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tick1</span></span><br><span class="line">click</span><br><span class="line">resolve1</span><br><span class="line">promise</span><br><span class="line">observer</span><br><span class="line">click</span><br><span class="line">resolve1</span><br><span class="line">promise</span><br><span class="line">animationFrame&gt;promise1</span><br><span class="line">observer</span><br><span class="line"><span class="comment">// Tick2</span></span><br><span class="line">animationFrame</span><br><span class="line">animationFrame&gt;promise</span><br><span class="line"><span class="comment">// Tick3</span></span><br><span class="line">animationFrame</span><br><span class="line">animationFrame&gt;promise</span><br><span class="line"><span class="comment">// Tick4</span></span><br><span class="line">timeout</span><br><span class="line">timeout&gt;promise</span><br><span class="line"><span class="comment">// Tick5</span></span><br><span class="line">timeout</span><br><span class="line">timeout&gt;promise</span><br></pre></td></tr></table></figure>

<p>每个 macroTask 队列中的 macroTask 按顺序执⾏，在每个 macroTask 之间渲染⻚⾯<br>⼀个 macroTask 执⾏结束 (即 js 执⾏栈中为空)，会⽴即处理 macroTask 执⾏过程中产⽣<br>的 microTask 并且按顺序执⾏。microTask 产⽣的 macroTask 会⾃动加⼊相应的宏任务<br>队列。<br>每次循环会把这次宏任务产⽣的所有微任务执⾏完，再进⾏下⼀次 loop。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本⽂回答了渲染进程如何利⽤消息队列和事件循环机制完成⻚⾯协调各个线程⼯作的。</p>
<h3 id="1-JS为什么是单线程的？"><a href="#1-JS为什么是单线程的？" class="headerlink" title="1. JS为什么是单线程的？"></a>1. JS为什么是单线程的？</h3><p>想象⼀下，假设浏览器中的 JS 是多线程的（⼀个进程中资源共享），如果现在有 2 个线程，thread1 thread2, 由于是多线程的 JS, 所以他们可以对同⼀个 dom, 同时进⾏操作thread1 删除了该 dom, ⽽ thread2 编辑了该 dom,2 个⽭盾的命令同时下达，浏览器究竟该如何执⾏呢？<br>虽然 JS 是单线程，但是浏览器总共开了四个线程参与了 JS 的执⾏，其他三个只是辅助，不参与解析与执⾏： 1. JS 引擎线程（主线程，只有这个线程负责解析和执⾏ JS 代码） 2. 事件触发线程 3. 定时器触发线程 4. HTTP 异步请求线程<br>永远只有 JS 引擎线程在执⾏ JS 脚本程序，其他三个线程只负责将满⾜触发条件的处理函数推进任务队列，等待 JS 引擎线程执⾏</p>
<h3 id="2-为什么需要异步？"><a href="#2-为什么需要异步？" class="headerlink" title="2. 为什么需要异步？"></a>2. 为什么需要异步？</h3><p>如果 JS 中不存在异步，只能⾃上⽽下执⾏，如果上⼀⾏解析执⾏时间很⻓，那么下⾯的代码就会被阻塞。 对于⽤户⽽⾔，阻塞就意味着 “卡死”, 这样就导致了很差的⽤户体验。</p>
<h3 id="3-既然-JS-是单线程的，只能在一条线程上执行，又是如何实现的异步呢？"><a href="#3-既然-JS-是单线程的，只能在一条线程上执行，又是如何实现的异步呢？" class="headerlink" title="3. 既然 JS 是单线程的，只能在一条线程上执行，又是如何实现的异步呢？"></a>3. 既然 JS 是单线程的，只能在一条线程上执行，又是如何实现的异步呢？</h3><p>答案就是事件循环(Event loop)</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve1&#x27;</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">  &#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">// 创建微任务 micro_1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve2&#x27;</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">  &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">// 创建微任务 micro_2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231426418.png"></p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">111</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"><span class="title function_">fetch</span>(url) <span class="comment">// 假设该http请求花了3秒钟</span></span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">333</span>)</span><br><span class="line">&#125;)</span><br><span class="line">dom.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 假设⽤户在4秒钟时点击了dom</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">444</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">555</span>)</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="number">555</span></span><br><span class="line"><span class="number">222</span></span><br><span class="line"><span class="number">333</span></span><br><span class="line"><span class="number">444</span></span><br></pre></td></tr></table></figure>

<p>步骤1：</p>
<p>主线程只执⾏了 var a &#x3D; 111; 和 console.log (555) 两⾏代码，其他的代码分别交给了其他三个线程，因为其他线程需要 2、3、4 秒钟才成功并回调，所以在 2 秒之前，主线程⼀直在空闲，不断的探查队列是否不为空。<br>此时主线程⾥其实已经是空的了（因为执⾏完那两⾏代码了）</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231656730.png"></p>
<p>步骤2：</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231658682.png"></p>
<p>步骤3：</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231700021.png"></p>
<p>步骤4：</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231701462.png"></p>
<p>图⾥的队列⾥都只有⼀个回调函数，实际上有很多个回调函数，如果主线程⾥执⾏的代码复杂需要很⻓时间，这时队列⾥的函数们就排着，等着主线程啥时执⾏完，再来队列⾥取</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231706622.png"></p>
<p>所以从这⾥能看出来，对于 setTimeout，setInterval 的定时，不⼀定完全按照设想的时间的，因为主线程⾥的代码可能复杂到执⾏很久，所以会发⽣你定时 3 秒后执⾏，实际上是 3.5 秒后执⾏（主线程花费了 0.5 秒）</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">  process.<span class="title function_">nextTick</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">  process.<span class="title function_">nextTick</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;11&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;12&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 执⾏结果为1,7,6,8,2,4,3,5,9,11,10,12</span></span><br></pre></td></tr></table></figure>

<p>每次执⾏完⼀个宏任务后都要去检查微任务就可以了。</p>
<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer3&#x27;</span>)</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise3&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise4&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise5&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>执⾏结果：start &gt; promise4 &gt; end &gt; promise5 &gt; timer1 &gt; promise1 &gt; timer2 &gt; promise2 &gt; timer3 &gt; promise3</p>
<h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script end&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>宏任务：执行整体代码（相当于<script>中的代码）：</p>
<p>输出: script start  </p>
<p>遇到 setTimeout，加入宏任务队列，当前宏任务队列(setTimeout)  </p>
<p>遇到 promise，加入微任务，当前微任务队列(promise1)  </p>
<p>输出：script end</p>
</li>
<li><p>微任务：执行微任务队列（promise1）</p>
<p>输出：promise1，then 之后产生一个微任务，加入微任务队列，当前微任务队列（promise2）</p>
<p>执行 then，输出promise2</p>
</li>
<li><p>执行渲染操作，更新界面（敲黑板划重点）。</p>
</li>
<li><p>宏任务：执行 setTimeout</p>
<p>输出：setTimeout</p>
</li>
</ol>
<h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>new Promise(..)中的代码，也是同步代码，会立即执行。只有then之后的代码，才是异步执行的代码，是一个微任务。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;timeout1&quot;</span>);</span><br><span class="line">&#125;, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;timeout2&quot;</span>), <span class="number">10</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;then1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>步骤解析：</p>
<ul>
<li>当前任务队列：微任务: [], 宏任务：[<script>]<br>宏任务：</li>
</ul>
<p>输出: script start<br>遇到 timeout1，加入宏任务<br>遇到 Promise，输出promise1，直接 resolve，将 then 加入微任务，遇到 timeout2，加入宏任务。<br>输出script end<br>宏任务第一个执行结束</p>
<ul>
<li>当前任务队列：微任务[then1]，宏任务[timeou1, timeout2]<br>微任务：</li>
</ul>
<p>执行 then1，输出then1<br>微任务队列清空</p>
<ul>
<li>当前任务队列：微任务[]，宏任务[timeou1, timeout2]<br>宏任务：</li>
</ul>
<p>输出timeout1<br>输出timeout2</p>
<ul>
<li>当前任务队列：微任务[]，宏任务[timeou2]</li>
</ul>
<p>微任务：</p>
<p>为空跳过</p>
<p>当前任务队列：微任务[]，宏任务[timeou2]<br>宏任务：</p>
<p>输出timeout2</p>
<h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p>async 和 await 其实就是 Generator 和 Promise 的语法糖。</p>
<p>async 函数和普通 函数没有什么不同，他只是表示这个函数里有异步操作的方法，并返回一个 Promise 对象</p>
<p>翻译过来其实就是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async/await 写法</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Promise 写法</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title function_">async2</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>步骤解析：</p>
<p>当前任务队列：宏任务：[<script>]，微任务: []<br>宏任务：</p>
<p>输出：async1 start<br>遇到 async2，输出：async2，并将 then（async1 end）加入微任务<br>遇到 setTimeout，加入宏任务。<br>遇到 Promise，输出：promise1，直接 resolve，将 then(promise2)加入微任务<br>输出：script end</p>
<p>当前任务队列：微任务[async1 end,promise2]，宏任务[timeout]<br>微任务：</p>
<p>输出：async1 end<br>async1 end 出队</p>
<p>输出：promise2<br>promise2 出队<br>微任务队列清空</p>
<p>当前任务队列：微任务[]，宏任务[timeout]<br>宏任务：</p>
<p>输出：timeout<br>timeout 出队，宏任务清空</p>
<h3 id="8"><a href="#8" class="headerlink" title="8"></a>8</h3><p>setTimeout 是一个宏任务，会被添加到宏任务队列当中去，按顺序执行，如果前面有。</p>
<p>setTimeout() 的第二个参数是为了告诉 JavaScript 再过多长时间把当前任务添加到队列中。</p>
<p>如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。</p>
<p>看代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getSeconds</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;then1&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getSeconds</span>() - s &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;while&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>因为then是一个微任务，会先于setTimeout执行，所以，虽然setTimeout是在两秒后加入的宏任务，但是因为then中的在while操作被延迟了4s，所以一直推迟到了4s秒后才执行的setTimeout。</p>
<p>所以输出的顺序是：script start、promise、script end、then1。<br>四秒后输出：while、timeout</p>
<p>关于 setTimeout 要补充的是，即便主线程为空，0 毫秒实际上也是达不到的。根据 HTML 的标准，最低是 4 毫秒。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/20/Vue%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%AB%98%E9%98%B6%E6%8C%87%E5%8D%97/" rel="prev" title="Vue学习（五）————高阶指南">
      <i class="fa fa-chevron-left"></i> Vue学习（五）————高阶指南
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">进程与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.2.</span> <span class="nav-text">多线程与多进程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="nav-number">3.</span> <span class="nav-text">浏览器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JS-%E5%BC%95%E6%93%8E%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.1.</span> <span class="nav-text">JS 引擎线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%EF%BC%89"><span class="nav-number">3.1.1.</span> <span class="nav-text">消息队列（任务队列）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.2.</span> <span class="nav-text">其他线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EventLoop-%E8%BD%AE%E8%AF%A2%E5%A4%84%E7%90%86%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.3.</span> <span class="nav-text">EventLoop 轮询处理线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Event-Loop%EF%BC%88%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">Event Loop（事件循环）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#callback"><span class="nav-number">4.1.</span> <span class="nav-text">callback</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5vs%E5%BC%82%E6%AD%A5"><span class="nav-number">4.2.</span> <span class="nav-text">同步vs异步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3JS%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="nav-number">4.2.1.</span> <span class="nav-text">从同步异步角度理解JS的执行机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="nav-number">4.3.</span> <span class="nav-text">异步任务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1VS%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="nav-number">4.3.1.</span> <span class="nav-text">宏任务VS微任务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Event-Loop-%E7%9A%84%E6%A8%A1%E5%9E%8B-Macrotask-Microtask"><span class="nav-number">4.4.</span> <span class="nav-text">Event Loop 的模型 (Macrotask + Microtask)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">4.4.1.</span> <span class="nav-text">任务的优先级</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%90%8E"><span class="nav-number">5.</span> <span class="nav-text">最后</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-JS%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F"><span class="nav-number">5.1.</span> <span class="nav-text">1. JS为什么是单线程的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%BC%82%E6%AD%A5%EF%BC%9F"><span class="nav-number">5.2.</span> <span class="nav-text">2. 为什么需要异步？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%97%A2%E7%84%B6-JS-%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%8C%E5%8F%AA%E8%83%BD%E5%9C%A8%E4%B8%80%E6%9D%A1%E7%BA%BF%E7%A8%8B%E4%B8%8A%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%8F%88%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%91%A2%EF%BC%9F"><span class="nav-number">5.3.</span> <span class="nav-text">3. 既然 JS 是单线程的，只能在一条线程上执行，又是如何实现的异步呢？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90"><span class="nav-number">6.</span> <span class="nav-text">例子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1"><span class="nav-number">6.1.</span> <span class="nav-text">1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2"><span class="nav-number">6.2.</span> <span class="nav-text">2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3"><span class="nav-number">6.3.</span> <span class="nav-text">3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4"><span class="nav-number">6.4.</span> <span class="nav-text">4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5"><span class="nav-number">6.5.</span> <span class="nav-text">5</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">gjbe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">gjbe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '0345980f9d756faa9ef0',
      clientSecret: '403968f743ab1c228a563989e36b914904436d8e',
      repo        : 'comments',
      owner       : 'gjbegjbe',
      admin       : ['gjbegjbe'],
      id          : '5a4712d4c3d13698b3e5949daacff2e0',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
