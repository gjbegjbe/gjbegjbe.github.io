<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gjbegjbe.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. 浏览器缓存强缓存&amp;协商缓存强缓存：不需要发送HTTP请求 协商缓存：需要发送HTTP请求 强缓存不需要发送HTTP请求。 HTTP&#x2F;1.0：Expires HTTP&#x2F;1.1：Cache-Control ExpiresExpires即过期时间，存在于服务端返回的响应头中，告诉浏览器这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。   表示资源过期的时间。">
<meta property="og:type" content="article">
<meta property="og:title" content="浏览器相关知识">
<meta property="og:url" content="https://gjbegjbe.github.io/2022/03/14/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="gjbe">
<meta property="og:description" content="1. 浏览器缓存强缓存&amp;协商缓存强缓存：不需要发送HTTP请求 协商缓存：需要发送HTTP请求 强缓存不需要发送HTTP请求。 HTTP&#x2F;1.0：Expires HTTP&#x2F;1.1：Cache-Control ExpiresExpires即过期时间，存在于服务端返回的响应头中，告诉浏览器这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。   表示资源过期的时间。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/gjbegjbe/pics/main/pics20220315094320.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gjbegjbe/pics/main/pics20220315095603.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gjbegjbe/pics/main/pics20220315095014.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gjbegjbe/pics/main/pics20220315100135.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gjbegjbe/pics/main/pics20220315100614.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gjbegjbe/pics/main/pics20220315100858.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gjbegjbe/pics/main/pics20220315102212.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gjbegjbe/pics/main/pics20220315135819.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gjbegjbe/pics/main/pics20220315140655.png">
<meta property="og:image" content="https://github.com/gjbegjbe/pics/raw/main/202205161732674.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gjbegjbe/pics/main/202205171352062.png">
<meta property="og:image" content="https://github.com/gjbegjbe/pics/raw/main/202205171407788.png">
<meta property="og:image" content="c:/Users/ThinkPad/AppData/Roaming/marktext/images/2022-08-17-14-11-31-image.png">
<meta property="og:image" content="c:/Users/ThinkPad/AppData/Roaming/marktext/images/2022-08-17-14-44-06-image.png">
<meta property="og:image" content="c:/Users/ThinkPad/AppData/Roaming/marktext/images/2022-08-17-14-55-54-image.png">
<meta property="og:image" content="c:/Users/ThinkPad/AppData/Roaming/marktext/images/2022-08-17-17-00-23-image.png">
<meta property="og:image" content="c:/Users/ThinkPad/AppData/Roaming/marktext/images/2022-08-17-17-52-01-image.png">
<meta property="og:image" content="c:/Users/ThinkPad/AppData/Roaming/marktext/images/2022-08-18-10-09-04-image.png">
<meta property="og:image" content="c:/Users/ThinkPad/AppData/Roaming/marktext/images/2022-08-18-10-15-25-image.png">
<meta property="og:image" content="c:/Users/ThinkPad/AppData/Roaming/marktext/images/2022-08-18-10-40-56-image.png">
<meta property="og:image" content="c:/Users/ThinkPad/AppData/Roaming/marktext/images/2022-08-18-10-50-16-image.png">
<meta property="article:published_time" content="2022-03-14T11:18:45.000Z">
<meta property="article:modified_time" content="2022-08-18T09:39:17.017Z">
<meta property="article:author" content="gjbe">
<meta property="article:tag" content="浏览器">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/gjbegjbe/pics/main/pics20220315094320.png">

<link rel="canonical" href="https://gjbegjbe.github.io/2022/03/14/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>浏览器相关知识 | gjbe</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-MXN04CBZXN"></script>
    <script data-pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-MXN04CBZXN');
      }
    </script>


  <script data-pjax>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?49e659bd9c945277731a2e39ec566e9d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="gjbe" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">gjbe</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/gjbegjbe" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gjbegjbe.github.io/2022/03/14/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gjbe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gjbe">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          浏览器相关知识
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-14 19:18:45" itemprop="dateCreated datePublished" datetime="2022-03-14T19:18:45+08:00">2022-03-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-18 17:39:17" itemprop="dateModified" datetime="2022-08-18T17:39:17+08:00">2022-08-18</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="1-浏览器缓存"><a href="#1-浏览器缓存" class="headerlink" title="1. 浏览器缓存"></a>1. 浏览器缓存</h2><h3 id="强缓存-amp-协商缓存"><a href="#强缓存-amp-协商缓存" class="headerlink" title="强缓存&amp;协商缓存"></a>强缓存&amp;协商缓存</h3><p>强缓存：不需要发送HTTP请求</p>
<p>协商缓存：需要发送HTTP请求</p>
<h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>不需要发送HTTP请求。</p>
<p>HTTP&#x2F;1.0：Expires</p>
<p>HTTP&#x2F;1.1：Cache-Control</p>
<h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h5><p>Expires即过期时间，存在于服务端返回的响应头中，告诉浏览器这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/pics20220315094320.png" alt="image-20220315094313721"></p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/pics20220315095603.png" alt="image-20220315095603481"></p>
<p>表示资源过期的时间。</p>
<p>问题是服务器的时间可能和浏览器的时间不一致，那么服务器返回的这个时间可能是不准确的。</p>
<p>在HTTP&#x2F;1.1被抛弃</p>
<h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><p>与Expires的区别就是它没有采用具体的过期时间点的形式，而是采用过期时长来控制缓存。max-age</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/pics20220315095014.png" alt="image-20220315095013941"></p>
<p>可以组合非常多的指令，完成更多场景的缓存判断：</p>
<h6 id="public"><a href="#public" class="headerlink" title="public"></a>public</h6><p>客户端和代理服务器都可以缓存。因为一个请求要经过不同的代理服务器才能到达目标服务器，所以不仅仅浏览器，中间的任何代理节点都可以缓存。</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/pics20220315100135.png" alt="image-20220315100135600"></p>
<h6 id="private"><a href="#private" class="headerlink" title="private"></a>private</h6><p>只有浏览器能缓存，中间的代理服务器不能缓存。</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/pics20220315100614.png" alt="image-20220315100614544"></p>
<h6 id="no-cache"><a href="#no-cache" class="headerlink" title="no-cache"></a>no-cache</h6><p>跳过当前强缓存，直接发送HTTP请求，进入协商缓存阶段。</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/pics20220315100858.png" alt="image-20220315100858357"></p>
<h6 id="s-maxage"><a href="#s-maxage" class="headerlink" title="s-maxage"></a>s-maxage</h6><p>针对代理服务器的缓存时间。</p>
<p>当Expires和Cache-Control同时存在的时候，Cache-Control会优先考虑。</p>
<p>强缓存失效了，就会进入协商缓存。</p>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>强缓存失效之后，浏览器在请求头中携带相应的缓存tag来向服务器发送请求，由服务器根据tag来决定是否使用缓存，这就是协商缓存。</p>
<p>缓存tag分为两种：Last-Modified和ETag</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/pics20220315102212.png" alt="image-20220315102212062"></p>
<h5 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h5><p>最后修改时间。浏览器第一次向服务器发送请求后，服务器会在响应头中加上这个字段。</p>
<p>浏览器接收到后，如果再次请求，会在请求头中携带If-Modified-Since字段，这个字段的值也就是服务器传来的最后修改时间。</p>
<p>服务器拿到请求头中的If-Modified-Since字段后，会和这个服务器中该资源最后修改时间对比：</p>
<p>如果这个值小于最后修改时间，说明是时候更新了，返回新的资源，和常规的HTTP请求流程一样。</p>
<p>否则返回304，告诉浏览器直接用缓存。</p>
<h5 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h5><p>ETag是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值传给浏览器。</p>
<p>浏览器收到ETag的值，会在下次请求时，将这个值作为If-None-Match这个字段的内容，并放到请求头中，然后发给服务器。</p>
<p>服务器接收到If-None-Match后，会跟服务器上该资源的ETag进行比对：</p>
<p>如果两者不一样，说明要更新了。返回新的资源，和常规的HTTP请求响应的流程一样。</p>
<p>否则返回304，告诉浏览器直接用缓存。</p>
<h5 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h5><ol>
<li>在精准度上，ETag优于Last-Modified。优于ETag是按照内容给资源上标识，因此能准确感知资源的变化。而Last-Modified就不一样了，在以下情况不能准确感知变化：<ul>
<li>编辑了资源文件，但是文件内容没有更改，会造成缓存失效</li>
<li>Last-Modified能够感知的时间是秒，如果文件在1秒内改变了多次，那么这时候的Last-Modified就无法体现修改。</li>
</ul>
</li>
<li>在性能上，Last-Modified优于ETag，也很简单理解，Last-Modified仅仅只是记录一个时间点，而ETag需要根据具体的文件内容生成哈希值。</li>
</ol>
<p>如果两种方式都支持，服务器优先考虑ETag。</p>
<h3 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h3><p>当强缓存命中或者协商缓存服务器返回304，直接从缓存的位置获取资源。</p>
<p>Service Worker、Memory Cache、Disk Cache、Push Cache</p>
<h4 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h4><p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/pics20220315135819.png" alt="image-20220315135819839"></p>
<p>Service Worker借鉴了Web Worker的思路，即让JS运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问DOM。可以完成离线缓存、消息推送和网络代理的功能。其中离线缓存靠的是Service Worker Cache。离线缓存就是Service Worker Cache。</p>
<p>也是PWA的重要实现机制。</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/pics20220315140655.png" alt="image-20220315140655167"></p>
<h4 id="Memory-Cache和Disk-Cache"><a href="#Memory-Cache和Disk-Cache" class="headerlink" title="Memory Cache和Disk Cache"></a>Memory Cache和Disk Cache</h4><h5 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h5><p>内存缓存，效率上最快。存活时间最短，当渲染进程结束后，内存缓存不存在了。</p>
<h5 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h5><p>是磁盘缓存，存取效率慢，优势在存储容量和时长。</p>
<h5 id="使用策略"><a href="#使用策略" class="headerlink" title="使用策略"></a>使用策略</h5><p>比较大的js、css放入磁盘，否则放入内存</p>
<p>内存占用率高的时候，放入磁盘</p>
<h4 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h4><p>推送缓存，是HTTP&#x2F;2的内容</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>首先通过Cache-Control验证强缓存是否可用</li>
<li><ol>
<li>如果强缓存可用直接使用</li>
<li>否则进入协商缓存，发送HTTP请求，服务器通过请求头中的If-Modified-Since或者If-None-Match检查资源是否更新<ol>
<li>如果资源更新返回200，和资源</li>
<li>否则返回304告诉浏览器直接从缓存获取</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="2-浏览器本地存储"><a href="#2-浏览器本地存储" class="headerlink" title="2. 浏览器本地存储"></a>2. 浏览器本地存储</h2><p>主要分为Cookie、WebStorage（localStorage和sessionStorage）和indexedDB。</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie最开始不是做本地存储的，而是为了弥补HTTP在状态管理上的不足。</p>
<p>HTTP协议是一个无状态协议，客户端向服务器发请求，服务器返回响应，下次发请求如何让服务端知道客户端是谁？</p>
<p>因此就产生了Cookie。</p>
<p>Cookie本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对存储。</p>
<p><img src="https://github.com/gjbegjbe/pics/raw/main/202205161732674.png"></p>
<p>向同一个域名下发送请求，都会携带相同的Cookie，服务器拿到Cookie进行解析，就能拿到客户端的状态。</p>
<h4 id="Cookie的缺陷"><a href="#Cookie的缺陷" class="headerlink" title="Cookie的缺陷"></a>Cookie的缺陷</h4><ol>
<li><p>容量缺陷。容量只有4KB，只能存储少量信息。</p>
</li>
<li><p>性能缺陷。不管域名下面的某个地址是否需要这个Cookie，请求都会携带完整的Cookie，因此请求数增多会造成巨大的性能浪费。</p>
</li>
<li><p>安全缺陷。以纯文本形式传递，很容易被非法用户截获并篡改，相当危险。在HttpOnly为false情况下，Cookie信息能够通过js脚本直接读取。</p>
</li>
</ol>
<h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><h4 id="localStorage和Cookie的异同点"><a href="#localStorage和Cookie的异同点" class="headerlink" title="localStorage和Cookie的异同点"></a>localStorage和Cookie的异同点</h4><p>和Cookie一样，对同一个同一个域名都会有相同的localStorage。</p>
<p>区别：</p>
<ol>
<li><p>容量。上限5M，比Cookie的4K大。5M针对某个域名，永久存储。</p>
</li>
<li><p>只存在客户端，默认不参与服务端的通信。避免了Cookie带来的性能和安全问题。</p>
</li>
<li><p>接口封装。通过localStorage暴露在全局，通过setItem和getItem进行操作，非常方便。</p>
</li>
</ol>
<h4 id="操作方式"><a href="#操作方式" class="headerlink" title="操作方式"></a>操作方式</h4><p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202205171352062.png"></p>
<p>接着进入相同的域名时就能拿到相应的值：</p>
<p><img src="https://github.com/gjbegjbe/pics/raw/main/202205171407788.png"></p>
<p>localStorage存储的都是字符串，如果是存储对象需要调用JSON的stringfy方法，并且用JSON.parse解析成对象。</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>利用localStorage的较大容量和持久特性，可以利用localStorage存储一些内容稳定的资源，比如官网的logo，存储Base64格式的图片资源。</p>
<h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><h4 id="sessionStorage和localStorage的异同"><a href="#sessionStorage和localStorage的异同" class="headerlink" title="sessionStorage和localStorage的异同"></a>sessionStorage和localStorage的异同</h4><p>一致：</p>
<ol>
<li><p>容量。上限也是5M。</p>
</li>
<li><p>只存在客户端，不参与服务端通信。</p>
</li>
<li><p>接口封装。除了sessionStorage名字有所变化，存储方式、操作方式均和localStorage一样。</p>
</li>
</ol>
<p>区别：</p>
<p>sessionStorage只是会话级别的存储，不是持久化的存储。会话结束，也就是页面关闭，这部分sessionStorage也就不存在了。</p>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li><p>可以用它对表单信息进行维护，将表单信息存储在里面，保证页面即使刷新也不会让之前的表单信息丢失。</p>
</li>
<li><p>可以用它存储本地浏览记录。如果关闭页面后不需要，那么sessionStorage就很合适。</p>
</li>
</ol>
<h3 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h3><p>IndexedDB是运行在浏览器中的非关系型数据库，本质上是数据库，理论上容量没有上限。</p>
<p>IndexedDB重要特性，除了拥有数据库本身的特性，除了拥有数据库本身的特性，比如支持事务、存储二进制数据，还有这些特性：</p>
<ol>
<li><p>键值对存储。内部采用对象仓库存放数据，在这个对象仓库中数据采用键值对的方式来存储。</p>
</li>
<li><p>异步操作。数据库的读写属于I&#x2F;O操作，浏览器中对异步I&#x2F;O提供了支持。</p>
</li>
<li><p>受同源策略限制，即无法访问跨域的数据库。</p>
</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p>cookie并不适合存储，而且存在非常多的缺陷。</p>
</li>
<li><p>Web Storage包括localStorage和sessionStorage，默认不会参与和服务器的通信。</p>
</li>
<li><p>IndexedDB为运行在浏览器上的非关系型数据库，为大型数据的存储提供了接口。</p>
</li>
</ol>
<h2 id="3-从输入URL到页面呈现发生了什么？"><a href="#3-从输入URL到页面呈现发生了什么？" class="headerlink" title="3. 从输入URL到页面呈现发生了什么？"></a>3. 从输入URL到页面呈现发生了什么？</h2><p>在浏览器地址栏输入百度地址：<a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com/</a></p>
<h3 id="构建请求"><a href="#构建请求" class="headerlink" title="构建请求"></a>构建请求</h3><p>浏览器会构建请求行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求方法是GET，路径为根路径，HTTP协议版本为1.1</span></span><br><span class="line"><span class="variable constant_">GET</span> / <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br></pre></td></tr></table></figure>

<h3 id="查找强缓存"><a href="#查找强缓存" class="headerlink" title="查找强缓存"></a>查找强缓存</h3><p>先检查强缓存，如果命中直接使用，否则进入下一步。强缓存见前面。</p>
<h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>由于输入的是域名，数据包是通过IP地址传给对方。需要得到域名对应的IP地址。这个过程需要依赖一个服务系统，这个系统将域名和IP一一映射，这个系统就叫DNS（域名系统，domain name system）。得到具体IP的过程就是DNS解析。</p>
<p>浏览器提供了DNS数据缓存功能。即一个域名如果解析过，那会把解析的结果缓存下来，下次处理直接走缓存，不需要经过DNS解析。</p>
<p>如果不指定端口的话，默认采用对应IP的80端口。</p>
<h3 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a>建立TCP连接</h3><p>Chrome在同一个域名下要求同时最多有6个TCP连接，超过6个的话剩下的请求就得等待。</p>
<p>假如现在不需要等待，进入了TCP连接的建立阶段。首先解释一下什么是TCP：</p>
<p>TCP（transmission control protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<p>建立TCP连接经历了下面三个阶段：</p>
<ol>
<li><p>通过3次握手（总共发送3个数据包确认已经建立连接）建立客户端和服务器之间的连接。</p>
</li>
<li><p>进行数据传输。这里有一个重要的机制，接收方接收到数据包之后必须要向发送方确认，如果发送方没有接到这个确认的消息，就判定为数据包丢失，并重新发送该数据包。发送的过程还有一个优化的策略，把大的数据包拆成一个个小的数据包，一次传输到接收方，接收方按照这个小包的顺序把它们组装成完整数据包。</p>
</li>
<li><p>断开连接的阶段。数据传输完成，靠四次挥手来断开连接。</p>
</li>
</ol>
<p>TCP保证数据传输的可靠性的手段：1. 三次握手确认连接；2. 数据包校验保证数据到达接收方；3. 四次挥手断开连接。</p>
<p>关于握手的深入研究：<a href="">https://zhuanlan.zhihu.com/p/86426969</a></p>
<h3 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h3><p>TCP连接建立完毕，浏览器可以和服务器开始通信，开始发送HTTP请求。浏览器发HTTP请求要携带三样东西：请求行、请求头和请求体。</p>
<ol>
<li><p>首先，浏览器会向服务器发送请求行，之前构建请求的时候就构建了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求方法是GET，路径为根路径，HTTP协议版本为1.1</span></span><br><span class="line"><span class="variable constant_">GET</span> / <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br></pre></td></tr></table></figure>

<p>结构很简单，由请求方法、请求URI和HTTP版本协议组成。</p>
</li>
<li><p>同时也要带上请求头，比如Cache-Control、If-Modified-Since、If-None-Match都有可能放入请求头中作为缓存的标识信息。还有其他一些属性：</p>
<p><img src="C:\Users\ThinkPad\AppData\Roaming\marktext\images\2022-08-17-14-11-31-image.png"></p>
</li>
<li><p>最后是请求体，只有在POST方法下存在，常见的场景是表单提交。</p>
</li>
</ol>
<h3 id="网络响应"><a href="#网络响应" class="headerlink" title="网络响应"></a>网络响应</h3><p>HTTP请求到达服务器，服务器进行对应的处理。最后要把数据传给浏览器，也就是返回网络响应。</p>
<p>跟请求部分类似，网络响应具有三个部分：响应行、响应头和响应体。</p>
<p>响应行类似下面这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br></pre></td></tr></table></figure>

<p>由HTTP协议版本、状态码和状态描述组成。</p>
<p>响应头包含了服务器及其返回数据的一些信息，服务器生成数据的时间、返回的数据类型以及对即将写入的Cookie信息。</p>
<p>举例如下：</p>
<p><img src="C:\Users\ThinkPad\AppData\Roaming\marktext\images\2022-08-17-14-44-06-image.png"></p>
<p>响应完成之后TCP不一定断开。这时候要判断Connection字段，如果请求头或者响应头中含有Connection: Keep-Alive，表示建立了持久连接，这样TCP连接会一直保持，之后请求统一站点的资源会复用这个连接。否则断开TCP连接，请求-响应流程结束。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>总结浏览器端的网络请求过程：</p>
<p><img src="C:\Users\ThinkPad\AppData\Roaming\marktext\images\2022-08-17-14-55-54-image.png"></p>
<h2 id="4-从输入URL到页面呈现发生了什么？——解析算法篇"><a href="#4-从输入URL到页面呈现发生了什么？——解析算法篇" class="headerlink" title="4. 从输入URL到页面呈现发生了什么？——解析算法篇"></a>4. 从输入URL到页面呈现发生了什么？——解析算法篇</h2><p>完成了网络请求和响应，如果响应头中Content-Type的值是text&#x2F;html，那么接下来就是浏览器的解析和渲染工作了。</p>
<p>首先来介绍解析部分，主要分为以下几个步骤：构建DOM树、样式计算、生成布局树（Layout Tree）。</p>
<h3 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h3><p>由于浏览器无法直接理解HTML字符串，因此将这一系列的字节流转换为一种有意义并且方便操作的数据结构，这种数据结构就是DOM树。DOM树本质上是一个以document为根节点的多叉树。</p>
<h4 id="HTML文法的本质"><a href="#HTML文法的本质" class="headerlink" title="HTML文法的本质"></a>HTML文法的本质</h4><p>HTML的文法并不是上下文无关文法。</p>
<p>规范的HTML语法，是符合上下文无关文法的，能够体现它非上下文无关的是不标准的语法。</p>
<p>比如解析器扫描到form标签的时候，上下文无关文法的处理方式是直接创建对应form的DOM对象，而真实的HTML5场景中却不是这样，解析器会查看form标签的上下文，如果这个form标签的父标签也是form，那么直接跳过当前的form标签，否则才创建DOM对象。</p>
<p>常规的编程语言都是上下文无关的，而HTML却相反，也真是它非上下文无关的特性，决定了HTML Parser并不能使用常规编程语言的解析器来完成，需要另辟蹊径。</p>
<h4 id="解析算法"><a href="#解析算法" class="headerlink" title="解析算法"></a>解析算法</h4><p>HTML5规范详细地介绍了解析算法。这个算法分为两个阶段：标记化、建树。</p>
<p>对应的两个过程就是词法分析和语法分析。</p>
<h5 id="标记化算法"><a href="#标记化算法" class="headerlink" title="标记化算法"></a>标记化算法</h5><p>这个算法输入为HTML文本，输出为HTML标记，也称为标记生成器。其中运用有限自动状态机来完成。即在当前状态下，接收一个或多个字符，就会更新到下一个状态。</p>
<h5 id="建树算法"><a href="#建树算法" class="headerlink" title="建树算法"></a>建树算法</h5><p>DOM树是一个以document为根节点的多叉树。因此解析器首先会创建一个document对象。标记生成器会把每个标记的信息发送给建树器。建树器接收到相应的标记时，会创建对应的DOM对象。创建这个DOM对象后会做两件事情：1. 将DOM对象加入DOM树中；2. 将对应标记压入存放开放（与闭合标签意思对应）元素的栈中。</p>
<h4 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h4><p>HTML5强大的容错策略，容错能力非常强。</p>
<h3 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h3><p>关于CSS样式，来源一般是三种：</p>
<ol>
<li><p>link标签引用</p>
</li>
<li><p>style标签中的样式</p>
</li>
<li><p>元素的内嵌style属性</p>
</li>
</ol>
<h4 id="格式化样式表"><a href="#格式化样式表" class="headerlink" title="格式化样式表"></a>格式化样式表</h4><p>浏览器是无法识别css文本的，渲染引擎接收到css文本之后第一件事情就是将其转化为一个结构化的对象，即styleSheets。</p>
<p>格式化的过程过于复杂，对于不同的浏览器会有不同的优化策略。</p>
<p>在浏览器控制台可以通过document.styleSheets来查看这个最终的结构。</p>
<h4 id="标准化样式属性"><a href="#标准化样式属性" class="headerlink" title="标准化样式属性"></a>标准化样式属性</h4><p>有一些css样式的数值并不容易被渲染引擎所理解，因此需要在计算样式之前将他们标准化，如em-&gt;px，red-&gt;#ff0000，bold-&gt;700等。</p>
<h4 id="计算每个节点的具体样式"><a href="#计算每个节点的具体样式" class="headerlink" title="计算每个节点的具体样式"></a>计算每个节点的具体样式</h4><p>样式已经被格式化和标准化，接下来可以计算每个节点的具体样式信息。</p>
<p>两个规则：继承和层叠。</p>
<p>每个子节点都会默认继承父节点的样式属性，如果父节点中没有找到，就会采用浏览器默认样式，也叫UserAgent样式。这就是继承规则，非常容易理解。</p>
<p>然后是层叠规则，css最大的特点在于它的层叠性，也就是最终的样式取决于各个属性共同作用的效果。</p>
<p>计算完样式后，所有样式会被挂载到window.getComputedStyle上，可以通过js获取。</p>
<h3 id="生成布局树"><a href="#生成布局树" class="headerlink" title="生成布局树"></a>生成布局树</h3><p>现在已经生成了DOM树和DOM样式，接下来通过浏览器的布局系统确定元素的位置，生成一棵布局树。</p>
<p>布局树生成的大致工作：</p>
<ol>
<li><p>遍历生成的DOM树节点，并把它们添加到布局树中。</p>
</li>
<li><p>计算布局树节点的坐标位置。</p>
</li>
</ol>
<p>布局树只包含可见元素，对于head标签和设置了display:none的元素，将不会被放入其中。</p>
<p>Chrome现在已经没有生成Render Tree的功能。</p>
<p>从Chrome源码看浏览器如何layout布局<a target="_blank" rel="noopener" href="https://www.rrfed.com/2017/02/26/chrome-layout/">从Chrome源码看浏览器如何layout布局 &amp;#8211; 人人FED</a></p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><img src="C:\Users\ThinkPad\AppData\Roaming\marktext\images\2022-08-17-17-00-23-image.png"></p>
<h2 id="5-从输入URL到页面呈现发生了什么？——渲染过程篇"><a href="#5-从输入URL到页面呈现发生了什么？——渲染过程篇" class="headerlink" title="5. 从输入URL到页面呈现发生了什么？——渲染过程篇"></a>5. 从输入URL到页面呈现发生了什么？——渲染过程篇</h2><p>渲染分为以下几个步骤：</p>
<ol>
<li><p>建立图层树（Layer Tree）</p>
</li>
<li><p>生成绘制列表</p>
</li>
<li><p>生成图块并栅格化</p>
</li>
<li><p>显示器显示内容</p>
</li>
</ol>
<h3 id="建图层树"><a href="#建图层树" class="headerlink" title="建图层树"></a>建图层树</h3><p>一些复杂的场景，比如3D动画如何呈现出变换效果，当元素含有层叠上下文时如何控制显示和隐藏。所以浏览器在构建完布局树之后，还会对特定的节点进行分层，构建一棵图层树（Layer Tree）。</p>
<p>一般情况下，节点的图层默认属于父亲节点的图层（称为合成层）。什么时候能提升成为一个单独的合成层呢？</p>
<p>有两种分别讨论的情况：显式合成、隐式合成。</p>
<h4 id="显式合成"><a href="#显式合成" class="headerlink" title="显式合成"></a>显式合成</h4><p>显式合成的情况：</p>
<ol>
<li><p>拥有层叠上下文的节点。</p>
<ol>
<li><p>HTML根元素本身就具有层叠上下文。</p>
</li>
<li><p>普通元素设置position不为static并且设置了z-index属性，会产生层叠上下文。</p>
</li>
<li><p>元素的opacity值不是1。</p>
</li>
<li><p>元素的transform值不是none。</p>
</li>
<li><p>元素的filter值不是none。</p>
</li>
<li><p>元素的isolation值是isolate。</p>
</li>
<li><p>will-change指定的属性值为上面任意一个。</p>
</li>
</ol>
</li>
<li><p>需要剪裁的地方。比如一个div只给他设置100*100的大小，而在里面放了非常多的文字，超出的文字部分就要被剪裁。出现了滚动条，滚动条会被单独提升为一个图层。</p>
</li>
</ol>
<h4 id="隐式合成"><a href="#隐式合成" class="headerlink" title="隐式合成"></a>隐式合成</h4><p>层叠等级低的节点被提升为单独的图层后，所有层叠等级高的节点都会成为一个单独的图层。</p>
<p>这个隐式合成隐藏着巨大的风险，当一个z-index较低的图层被提升为单独的图层后，层叠在上面的元素都会被提升为单独的图层，可能会增加上千个图层，增加内存压力，让页面崩溃。这就是层爆炸。</p>
<p>需要repaint时，只需要repaint本身，不会影响到其他层。</p>
<h3 id="生成绘制列表"><a href="#生成绘制列表" class="headerlink" title="生成绘制列表"></a>生成绘制列表</h3><p>渲染引擎会将图层的绘制拆分成一个个绘制指令，比如先画背景再描绘边框。然后将这些指令按顺序组合成一个待绘制列表，相当于给后面的绘制操作做了一波计划。</p>
<p><img src="C:\Users\ThinkPad\AppData\Roaming\marktext\images\2022-08-17-17-52-01-image.png"></p>
<h3 id="生成图块和生成位图"><a href="#生成图块和生成位图" class="headerlink" title="生成图块和生成位图"></a>生成图块和生成位图</h3><p>渲染进程中绘制操作由专门的线程完成的，这个线程叫合成线程。绘制列表准备好之后，渲染进程的主线程会给合成线程发送commit消息，把绘制列表提交给合成线程。</p>
<p>当页面非常大需要滑动的时候，全部绘制出来很浪费性能，将页面分块可以加速页面的首屏展示。</p>
<p>即使绘制一个图块也会耗时，所以Chrome首次合成先合成低分辨率图片，然后正常图块绘制完毕后，将低分辨率的替换。</p>
<p>渲染过程中专门维护了一个栅格化线程池，专门负责把图块转换为位图数据。然后合成线程会选择视口附近图块交给栅格化线程池生成位图。</p>
<p>生成位图的过程实际上都会使用GPU进行加速，生成的位图最后发送给合成线程。</p>
<h3 id="显示器显示内容"><a href="#显示器显示内容" class="headerlink" title="显示器显示内容"></a>显示器显示内容</h3><p>栅格化操作完成后，合成线程会生成一个绘制命令，即“DrawQuad”，并发送给浏览器进程。</p>
<p>浏览器的viz组件接收到命令，根据命令发送到内存，再发送到显卡。</p>
<p>屏幕都有一个固定的刷新频率。</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><img src="C:\Users\ThinkPad\AppData\Roaming\marktext\images\2022-08-18-10-09-04-image.png"></p>
<h2 id="6-对重绘和回流的理解"><a href="#6-对重绘和回流的理解" class="headerlink" title="6. 对重绘和回流的理解"></a>6. 对重绘和回流的理解</h2><p>渲染流水线的流程：</p>
<p><img src="C:\Users\ThinkPad\AppData\Roaming\marktext\images\2022-08-18-10-15-25-image.png"></p>
<h3 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h3><p>回流也叫重排。</p>
<h4 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h4><p>对DOM结构修改引发DOM几何尺寸变化的时候，会发生回流的过程。</p>
<p>以下的操作会触发回流：</p>
<ol>
<li><p>一个DOM元素的几何属性变化，width、height、padding、margin、left、top、border。</p>
</li>
<li><p>DOM节点发生增减或移动。</p>
</li>
<li><p>读写offset族、scroll族和client族属性的时候，浏览器为了获取这些值，需要进行回流操作。</p>
</li>
<li><p>调用window.getComputedStyle方法。</p>
</li>
</ol>
<h4 id="回流过程"><a href="#回流过程" class="headerlink" title="回流过程"></a>回流过程</h4><p>触发回流的时候，如果DOM结构发生改变，重新渲染DOM树，然后将后面的流程全部走一遍。开销非常大。</p>
<p><img src="C:\Users\ThinkPad\AppData\Roaming\marktext\images\2022-08-18-10-40-56-image.png"></p>
<h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><h4 id="触发条件-1"><a href="#触发条件-1" class="headerlink" title="触发条件"></a>触发条件</h4><p>当DOM修改导致样式变化，并且没有影响几何属性的时候，会导致重绘（repaint）。</p>
<h4 id="重绘过程"><a href="#重绘过程" class="headerlink" title="重绘过程"></a>重绘过程</h4><p>没有导致DOM几何属性的变化，元素的位置信息不需要更新，省去了布局的过程。流程如下：</p>
<p><img src="C:\Users\ThinkPad\AppData\Roaming\marktext\images\2022-08-18-10-50-16-image.png"></p>
<p>跳过生成布局树和建图层树，直接绘制列表，然后继续进行分块生成位图等后面一系列操作。</p>
<p>重绘不一定导致回流，回流一定导致重绘。</p>
<h3 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h3><p>CSS3的transform、opacity、filter这些属性可以实现合成的效果，也就是GPU加速。</p>
<h4 id="GPU加速的原因"><a href="#GPU加速的原因" class="headerlink" title="GPU加速的原因"></a>GPU加速的原因</h4><p>在合成的情况下，直接跳过布局和绘制流程，直接进入非主线程处理的部分，直接交给合成线程处理。交给它处理的好处：</p>
<ol>
<li><p>能够充分发挥GPU的优势。合成线程生成位图的过程中会调用线程池，并在其中使用GPU进行加速生成，GPU擅长处理位图数据。</p>
</li>
<li><p>没有占用主线程的资源，即使主线程卡住了，效果依然能够流畅地展示。</p>
</li>
</ol>
<h3 id="实践意义"><a href="#实践意义" class="headerlink" title="实践意义"></a>实践意义</h3><ol>
<li><p>避免频繁使用style，而是采用修改class的方式。</p>
</li>
<li><p>使用createDocumentFragment进行批量的DOM操作。</p>
</li>
<li><p>对resize、scroll进行防抖&#x2F;节流处理。</p>
</li>
<li><p>添加will-change: tranform，让渲染引擎为其单独实现一个图层，当这些变换发生时，仅仅需要合成线程处理这些变换，而不牵扯到主线程，提高渲染效率。</p>
</li>
</ol>
<h2 id="7-XSS攻击"><a href="#7-XSS攻击" class="headerlink" title="7. XSS攻击"></a>7. XSS攻击</h2><h3 id="XSS攻击的定义"><a href="#XSS攻击的定义" class="headerlink" title="XSS攻击的定义"></a>XSS攻击的定义</h3><p>XSS全称是Cross Site Scripting（跨站脚本）。XSS攻击是指浏览器中执行恶意脚本（无论跨域还是同域），从而拿到用户的信息并进行操作。这些操作可以：1. 窃取cookie；2. 监听用户行为；比如输入账号密码后直接发送到服务器；3. 修改DOM伪造登录表单；4. 页面中生成浮窗广告。</p>
<p>XSS攻击的三种实现方式：存储型、反射型、文档型。</p>
<h4 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h4><p>将恶意脚本存储到服务端的数据库，然后在客户端执行这些脚本，从而达到攻击的效果。</p>
<p>在留言评论区提交一段脚本代码，在页面渲染过程中直接执行，相当于直接执行一段未知逻辑的XSS代码。</p>
<h4 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h4><p>恶意脚本作为网络请求的一部分。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http</span>:<span class="comment">//sanyuan.com?q=&lt;script&gt;alert(&quot;你完蛋了&quot;)&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>服务器端会拿到q参数，然后将内容返回到浏览器端，浏览器将这些内容作为HTML的一部分解析，发现是一个脚本，直接执行，这样就被攻击了。</p>
<p>恶意脚本通过作为网络请求的参数，经过服务器，反射到HTML文档中，执行解析。服务器并不会存储这些恶意脚本。</p>
<h4 id="文档型"><a href="#文档型" class="headerlink" title="文档型"></a>文档型</h4><p>XSS攻击并不会经过服务端，而是作为中间人，传书过程中劫持数据包，修改里面的html文档。包括WIFI路由器劫持和本地恶意软件。</p>
<h3 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h3><ol>
<li><p>不要相信任何用户的输入，无论在前端还是服务端都要对用户的输入进行转码或过滤。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">alert</span>(<span class="string">&#x27;你完蛋了&#x27;</span>)&lt;/script&gt;</span><br><span class="line"><span class="comment">// 转为</span></span><br><span class="line">&amp;lt;script&amp;gt;<span class="title function_">alert</span>(&amp;#<span class="number">39</span>;你完蛋了&amp;#<span class="number">39</span>;)&amp;lt;/script&amp;gt;</span><br></pre></td></tr></table></figure>

<p>也可以利用关键词过滤的方式，将script标签删除。</p>
</li>
<li><p>利用CSP，即浏览器中的内容安全策略。核心思想是服务器决定加载哪些资源。</p>
<ol>
<li><p>限制其他域下的资源加载。</p>
</li>
<li><p>禁止向其他域提交数据。</p>
</li>
<li><p>提供上报机制，帮助我们及时发现XSS攻击。</p>
</li>
</ol>
</li>
<li><p>利用HttpOnly。XSS攻击很多是窃取Cookie，设置Cookie的HttpOnly属性后，JS无法读取Cookie值，这样防范了攻击。</p>
</li>
</ol>
<h2 id="8-CSRF攻击"><a href="#8-CSRF攻击" class="headerlink" title="8. CSRF攻击"></a>8. CSRF攻击</h2><h3 id="CSRF攻击的定义"><a href="#CSRF攻击的定义" class="headerlink" title="CSRF攻击的定义"></a>CSRF攻击的定义</h3><p>CSRF(Cross-site request forgery)，跨站请求伪造，黑客诱导用户打开链接，打开黑客的网站，然后利用用户目前的登录状态发起跨站请求。</p>
<p>攻击方式：</p>
<h4 id="自动发GET请求"><a href="#自动发GET请求" class="headerlink" title="自动发GET请求"></a>自动发GET请求</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;https://xxx.com/info?user=hhh&amp;count=100&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>进入页面后自动发送get请求，会自动带上xxx.com的cookie信息。假如服务器端没有相应的验证机制，可能认为发请求的是一个正常用户，因为携带了相应的cookie，然后进行相应的操作，可能是转账汇款相关的操作。</p>
<h4 id="自动发POST请求"><a href="#自动发POST请求" class="headerlink" title="自动发POST请求"></a>自动发POST请求</h4><p>黑客可能自己填一个表单，写一段自动提交的脚本。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&#x27;hacker-form&#x27;</span> <span class="attr">action</span>=<span class="string">&quot;https://xxx.com/info&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hhh&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;hacker-form&#x27;</span>).<span class="title function_">submit</span>();</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同样也会携带相应的用户cookie信息，让服务器误以为是一个正常的用户在操作，让各种恶意的操作成为可能。</p>
<h4 id="诱导点击发送GET请求"><a href="#诱导点击发送GET请求" class="headerlink" title="诱导点击发送GET请求"></a>诱导点击发送GET请求</h4><p>黑客的网站上可能放一个链接诱导你来点击：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://xxx/info?user=hhh&amp;count=100&quot;</span> <span class="attr">taget</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>点击进⼊修仙世界<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>点击后自动发get请求。然后和自动发GET请求部分同理。</p>
<p>和XSS攻击相比，CSRF并不要将恶意代码注入到用户当前页面的html中，而是跳转到新的页面，利用服务器的验证漏洞和用户之前的登录状态模拟用户操作。</p>
<h3 id="防范措施-1"><a href="#防范措施-1" class="headerlink" title="防范措施"></a>防范措施</h3><h4 id="利用Cookie的SameSite属性"><a href="#利用Cookie的SameSite属性" class="headerlink" title="利用Cookie的SameSite属性"></a>利用Cookie的SameSite属性</h4><p>CRSF攻击重要的一环就是自动发送目标站点下的Cookie，这份Cookie模拟了用户的身份。</p>
<p>Cookie中有一个关键字段SameSite，可以对请求中Cookie携带做一些限制。</p>
<p>SameSite有三个值，Strict、Lax和None。</p>
<ol>
<li><p>Strict模式下，浏览器完全禁止第三方请求携带Cookie。比如请求sanyuan.com网站只能在sanyuan.com才能请求携带Cookie，在其他网站请求都不能。</p>
</li>
<li><p>在Lax模式，只有get方法提交表单或者a标签发送get请求的情况下可以携带Cookie，其他情况不能。</p>
</li>
<li><p>None模式，默认模式，请求会自动携带Cookie。</p>
</li>
</ol>
<h4 id="验证来源站点"><a href="#验证来源站点" class="headerlink" title="验证来源站点"></a>验证来源站点</h4><p>用到请求头的两个字段：Origin和Referer。</p>
<p>Origin只包含域名信息，Referer包含具体的URL路径。</p>
<p>这两者都可以伪造，通过Ajax自定义请求头，安全性略差。</p>
<h4 id="CSRF-Token"><a href="#CSRF-Token" class="headerlink" title="CSRF Token"></a>CSRF Token</h4><p>浏览器向服务器发送请求时，服务器生成一个字符串，植入到返回的页面中。浏览器如果要发送请求，就必须带上这个字符串，然后服务器验证是否合法，如果不合法不予响应。</p>
<p>这个字符串是CSRF Token，通过第三方站点无法拿到，会被服务器拒绝。</p>
<h2 id="9-HTTPS为什么让数据传输更安全？"><a href="#9-HTTPS为什么让数据传输更安全？" class="headerlink" title="9. HTTPS为什么让数据传输更安全？"></a>9. HTTPS为什么让数据传输更安全？</h2><p>HTTP的特性是明文传输，传输的每个环节数据都可能被第三方窃取或者篡改。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag"># 浏览器</a>
              <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"># 面试题</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/11/Vue%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E8%BF%87%E6%B8%A1%E5%92%8C%E5%8A%A8%E7%94%BB/" rel="prev" title="Vue学习（三）——过渡和动画">
      <i class="fa fa-chevron-left"></i> Vue学习（三）——过渡和动画
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/06/11/%E3%80%8ATypeScript%E7%BC%96%E7%A8%8B%E3%80%8B%E9%98%85%E8%AF%BB/" rel="next" title="《TypeScript编程》阅读">
      《TypeScript编程》阅读 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98"><span class="nav-number">1.</span> <span class="nav-text">1. 浏览器缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98-amp-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="nav-number">1.1.</span> <span class="nav-text">强缓存&amp;协商缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98"><span class="nav-number">1.1.1.</span> <span class="nav-text">强缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Expires"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">Expires</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Cache-Control"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">Cache-Control</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#public"><span class="nav-number">1.1.1.2.1.</span> <span class="nav-text">public</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#private"><span class="nav-number">1.1.1.2.2.</span> <span class="nav-text">private</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#no-cache"><span class="nav-number">1.1.1.2.3.</span> <span class="nav-text">no-cache</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#s-maxage"><span class="nav-number">1.1.1.2.4.</span> <span class="nav-text">s-maxage</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="nav-number">1.1.2.</span> <span class="nav-text">协商缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Last-Modified"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">Last-Modified</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ETag"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">ETag</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E8%80%85%E5%AF%B9%E6%AF%94"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">两者对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E4%BD%8D%E7%BD%AE"><span class="nav-number">1.2.</span> <span class="nav-text">缓存位置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Service-Worker"><span class="nav-number">1.2.1.</span> <span class="nav-text">Service Worker</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Memory-Cache%E5%92%8CDisk-Cache"><span class="nav-number">1.2.2.</span> <span class="nav-text">Memory Cache和Disk Cache</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Memory-Cache"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">Memory Cache</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Disk-Cache"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">Disk Cache</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">使用策略</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Push-Cache"><span class="nav-number">1.2.3.</span> <span class="nav-text">Push Cache</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="nav-number">2.</span> <span class="nav-text">2. 浏览器本地存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Cookie"><span class="nav-number">2.1.</span> <span class="nav-text">Cookie</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Cookie%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="nav-number">2.1.1.</span> <span class="nav-text">Cookie的缺陷</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#localStorage"><span class="nav-number">2.2.</span> <span class="nav-text">localStorage</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#localStorage%E5%92%8CCookie%E7%9A%84%E5%BC%82%E5%90%8C%E7%82%B9"><span class="nav-number">2.2.1.</span> <span class="nav-text">localStorage和Cookie的异同点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="nav-number">2.2.2.</span> <span class="nav-text">操作方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.2.3.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sessionStorage"><span class="nav-number">2.3.</span> <span class="nav-text">sessionStorage</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sessionStorage%E5%92%8ClocalStorage%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">2.3.1.</span> <span class="nav-text">sessionStorage和localStorage的异同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-number">2.3.2.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IndexedDB"><span class="nav-number">2.4.</span> <span class="nav-text">IndexedDB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">2.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">3. 从输入URL到页面呈现发生了什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E8%AF%B7%E6%B1%82"><span class="nav-number">3.1.</span> <span class="nav-text">构建请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E5%BC%BA%E7%BC%93%E5%AD%98"><span class="nav-number">3.2.</span> <span class="nav-text">查找强缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS%E8%A7%A3%E6%9E%90"><span class="nav-number">3.3.</span> <span class="nav-text">DNS解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.4.</span> <span class="nav-text">建立TCP连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81HTTP%E8%AF%B7%E6%B1%82"><span class="nav-number">3.5.</span> <span class="nav-text">发送HTTP请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%93%8D%E5%BA%94"><span class="nav-number">3.6.</span> <span class="nav-text">网络响应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number">3.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F%E2%80%94%E2%80%94%E8%A7%A3%E6%9E%90%E7%AE%97%E6%B3%95%E7%AF%87"><span class="nav-number">4.</span> <span class="nav-text">4. 从输入URL到页面呈现发生了什么？——解析算法篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BADOM%E6%A0%91"><span class="nav-number">4.1.</span> <span class="nav-text">构建DOM树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTML%E6%96%87%E6%B3%95%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">4.1.1.</span> <span class="nav-text">HTML文法的本质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90%E7%AE%97%E6%B3%95"><span class="nav-number">4.1.2.</span> <span class="nav-text">解析算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E5%8C%96%E7%AE%97%E6%B3%95"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">标记化算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BB%BA%E6%A0%91%E7%AE%97%E6%B3%95"><span class="nav-number">4.1.2.2.</span> <span class="nav-text">建树算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E9%94%99%E6%9C%BA%E5%88%B6"><span class="nav-number">4.1.3.</span> <span class="nav-text">容错机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B7%E5%BC%8F%E8%AE%A1%E7%AE%97"><span class="nav-number">4.2.</span> <span class="nav-text">样式计算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A0%B7%E5%BC%8F%E8%A1%A8"><span class="nav-number">4.2.1.</span> <span class="nav-text">格式化样式表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%8C%96%E6%A0%B7%E5%BC%8F%E5%B1%9E%E6%80%A7"><span class="nav-number">4.2.2.</span> <span class="nav-text">标准化样式属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%85%B7%E4%BD%93%E6%A0%B7%E5%BC%8F"><span class="nav-number">4.2.3.</span> <span class="nav-text">计算每个节点的具体样式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E5%B8%83%E5%B1%80%E6%A0%91"><span class="nav-number">4.3.</span> <span class="nav-text">生成布局树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-3"><span class="nav-number">4.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F%E2%80%94%E2%80%94%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E7%AF%87"><span class="nav-number">5.</span> <span class="nav-text">5. 从输入URL到页面呈现发生了什么？——渲染过程篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E5%9B%BE%E5%B1%82%E6%A0%91"><span class="nav-number">5.1.</span> <span class="nav-text">建图层树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E5%90%88%E6%88%90"><span class="nav-number">5.1.1.</span> <span class="nav-text">显式合成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E5%90%88%E6%88%90"><span class="nav-number">5.1.2.</span> <span class="nav-text">隐式合成</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E7%BB%98%E5%88%B6%E5%88%97%E8%A1%A8"><span class="nav-number">5.2.</span> <span class="nav-text">生成绘制列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E5%9B%BE%E5%9D%97%E5%92%8C%E7%94%9F%E6%88%90%E4%BD%8D%E5%9B%BE"><span class="nav-number">5.3.</span> <span class="nav-text">生成图块和生成位图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E5%99%A8%E6%98%BE%E7%A4%BA%E5%86%85%E5%AE%B9"><span class="nav-number">5.4.</span> <span class="nav-text">显示器显示内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-4"><span class="nav-number">5.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%AF%B9%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">6.</span> <span class="nav-text">6. 对重绘和回流的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%B5%81"><span class="nav-number">6.1.</span> <span class="nav-text">回流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="nav-number">6.1.1.</span> <span class="nav-text">触发条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E6%B5%81%E8%BF%87%E7%A8%8B"><span class="nav-number">6.1.2.</span> <span class="nav-text">回流过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E7%BB%98"><span class="nav-number">6.2.</span> <span class="nav-text">重绘</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6-1"><span class="nav-number">6.2.1.</span> <span class="nav-text">触发条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E7%BB%98%E8%BF%87%E7%A8%8B"><span class="nav-number">6.2.2.</span> <span class="nav-text">重绘过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E6%88%90"><span class="nav-number">6.3.</span> <span class="nav-text">合成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GPU%E5%8A%A0%E9%80%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">6.3.1.</span> <span class="nav-text">GPU加速的原因</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B5%E6%84%8F%E4%B9%89"><span class="nav-number">6.4.</span> <span class="nav-text">实践意义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-XSS%E6%94%BB%E5%87%BB"><span class="nav-number">7.</span> <span class="nav-text">7. XSS攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#XSS%E6%94%BB%E5%87%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">7.1.</span> <span class="nav-text">XSS攻击的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%9E%8B"><span class="nav-number">7.1.1.</span> <span class="nav-text">存储型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E5%9E%8B"><span class="nav-number">7.1.2.</span> <span class="nav-text">反射型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E6%A1%A3%E5%9E%8B"><span class="nav-number">7.1.3.</span> <span class="nav-text">文档型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%B2%E8%8C%83%E6%8E%AA%E6%96%BD"><span class="nav-number">7.2.</span> <span class="nav-text">防范措施</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-CSRF%E6%94%BB%E5%87%BB"><span class="nav-number">8.</span> <span class="nav-text">8. CSRF攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CSRF%E6%94%BB%E5%87%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">8.1.</span> <span class="nav-text">CSRF攻击的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%8F%91GET%E8%AF%B7%E6%B1%82"><span class="nav-number">8.1.1.</span> <span class="nav-text">自动发GET请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%8F%91POST%E8%AF%B7%E6%B1%82"><span class="nav-number">8.1.2.</span> <span class="nav-text">自动发POST请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B1%E5%AF%BC%E7%82%B9%E5%87%BB%E5%8F%91%E9%80%81GET%E8%AF%B7%E6%B1%82"><span class="nav-number">8.1.3.</span> <span class="nav-text">诱导点击发送GET请求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%B2%E8%8C%83%E6%8E%AA%E6%96%BD-1"><span class="nav-number">8.2.</span> <span class="nav-text">防范措施</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%94%A8Cookie%E7%9A%84SameSite%E5%B1%9E%E6%80%A7"><span class="nav-number">8.2.1.</span> <span class="nav-text">利用Cookie的SameSite属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%E6%9D%A5%E6%BA%90%E7%AB%99%E7%82%B9"><span class="nav-number">8.2.2.</span> <span class="nav-text">验证来源站点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CSRF-Token"><span class="nav-number">8.2.3.</span> <span class="nav-text">CSRF Token</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-HTTPS%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%A9%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%9B%B4%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="nav-number">9.</span> <span class="nav-text">9. HTTPS为什么让数据传输更安全？</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">gjbe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">gjbe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '0345980f9d756faa9ef0',
      clientSecret: '403968f743ab1c228a563989e36b914904436d8e',
      repo        : 'comments',
      owner       : 'gjbegjbe',
      admin       : ['gjbegjbe'],
      id          : '4c217c4de09cd89de14ff75c27cbd7ff',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
