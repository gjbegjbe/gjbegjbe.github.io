<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gjbegjbe.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="gjbe">
<meta property="og:url" content="https://gjbegjbe.github.io/index.html">
<meta property="og:site_name" content="gjbe">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="gjbe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://gjbegjbe.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>gjbe</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-MXN04CBZXN"></script>
    <script data-pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-MXN04CBZXN');
      }
    </script>


  <script data-pjax>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?49e659bd9c945277731a2e39ec566e9d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="gjbe" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">gjbe</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/gjbegjbe" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gjbegjbe.github.io/2022/11/25/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gjbe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gjbe">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/25/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-25 01:13:22" itemprop="dateCreated datePublished" datetime="2022-11-25T01:13:22+08:00">2022-11-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-14 11:58:54" itemprop="dateModified" datetime="2022-02-14T11:58:54+08:00">2022-02-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gjbegjbe.github.io/2022/08/30/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gjbe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gjbe">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/30/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">js数据类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-30 20:08:44" itemprop="dateCreated datePublished" datetime="2022-08-30T20:08:44+08:00">2022-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-31 17:48:44" itemprop="dateModified" datetime="2022-08-31T17:48:44+08:00">2022-08-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类"></a>数据类型分类</h2><p>JS的数据类型分为两大类，一类是原始类型(primitive type)，一类是对象类型(object<br>type)。</p>
<h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h3><p>原始类型又称为基本类型，分为 Number , String , Boolean , Undefined , Null 几类。比较特殊的是， undefined 是 Undefined 类型中的唯一一个值；同样地， null 是 Null 类型中的唯一一个值。</p>
<p>ES6 引入了一个比较特殊的原始类型 Symbol ，用于表示一个独一无二的值。Symbol是原始类型，不是对象类型。因为Symbol 是没有构造函数 constructor 的，不能通过new Symbol() 获得实例。</p>
<p>但是获取 symbol 类型的值是通过调用Symbol 函数得到的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> symbol1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;Tusi&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>Symbol 值是唯一的，所以下面的等式是不成立的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Symbol</span>(<span class="number">1</span>) === <span class="title class_">Symbol</span>(<span class="number">1</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>对象类型也叫引用类型，简单地理解呢，对象就是键值对 key:value 的集合。常见的对象类型有 Object , Array , Function , Date , RegExp 等。</p>
<p>JS还有全局对象。全局对象并不意味着它就是一种对象类型。比如JSON是一个全局对象，但是它不是一个对象类型。</p>
<p>对象可以 new 出来，所以对象类型都有构造函数， Object 类型对应的构造函数是Object() ， Array 类型对应的构造函数是 Array()。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>() <span class="comment">// 不过我们⼀般也不会这么写⼀个普通对象</span></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>) <span class="comment">// 创建⼀个length是1的空数组</span></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 创建数组[1, 2]</span></span><br></pre></td></tr></table></figure>

<h3 id="栈内存和堆内存"><a href="#栈内存和堆内存" class="headerlink" title="栈内存和堆内存"></a>栈内存和堆内存</h3><p>栈内存的优势是存取速度比堆内存快，考虑这一点可以优化代码性能。</p>
<h4 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a>栈内存</h4><p>原始类型是按值访问的，其值存储在栈内存中，所占内存大小是已知的或是有范围的；</p>
<p>对基本类型变量的重新赋值，其本质上是进行压栈操作，写入新的值，并让变量指向一块栈顶元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>; <span class="comment">// 压栈，1成为栈顶元素，其值赋给变量a</span></span><br><span class="line">a = <span class="number">2</span>; <span class="comment">// 压栈，2成为栈顶元素，并赋值给变量a(内存地址变了)</span></span><br></pre></td></tr></table></figure>

<h4 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h4><p>对象类型是按引用访问的，通过指针访问对象。<br>指针是一个地址值，类似于基本类型，存储于栈内存中，是变量访问对象的中间媒介。<br>对象本身存储在堆内存中，其占用内存大小是可变的，未知的。</p>
<p>举例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tusi&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>运行这行代码，会在堆内存中开辟一段内存空间，存储对象 {name: ‘Tusi’} ，同时声明一个指针，其值为上述对象的内存地址，指针赋值给引用变量 b ，意味着 b 引用了上述对象。</p>
<p>对象可以新增或删除属性，所以说对象类型占用的内存大小一般是未知的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.<span class="property">age</span> = <span class="number">18</span>; <span class="comment">// 对象新增了age属性</span></span><br></pre></td></tr></table></figure>

<p>按引用访问是对引用变量进行对象操作，其本质上改变的是引用变量所指向的堆内存地址中的对象本身。</p>
<p>如果有两个或两个以上的引用变量指向同一个对象，那么对其中一个引用变量的对象操作，会影响指向该对象的其他引用变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = &#123; <span class="attr">name</span>: <span class="string">&#x27;Tusi&#x27;</span> &#125;; <span class="comment">// 创建对象，变量b指向该对象</span></span><br><span class="line"><span class="keyword">var</span> c = b; <span class="comment">// 声明变量c，指向与b⼀致</span></span><br><span class="line">b.<span class="property">age</span> = <span class="number">18</span>; <span class="comment">// 通过变量b修改对象</span></span><br><span class="line"><span class="comment">// 产⽣副作⽤，c受到影响</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// &#123;name: &quot;Tusi&quot;, age: 18&#125;</span></span><br></pre></td></tr></table></figure>

<p>考虑到对象操作的副作用，我们会在业务代码中经常使用深拷贝来规避这个问题。</p>
<h2 id="数据类型的判断"><a href="#数据类型的判断" class="headerlink" title="数据类型的判断"></a>数据类型的判断</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p><code>typeof</code>操作符返回一个字符串，表示未经计算的操作数的类型。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>运算结果</th>
</tr>
</thead>
<tbody><tr>
<td>Undefined</td>
<td>“undefined”</td>
</tr>
<tr>
<td>Null</td>
<td>“object”</td>
</tr>
<tr>
<td>Boolean</td>
<td>“boolean”</td>
</tr>
<tr>
<td>Number</td>
<td>“number”</td>
</tr>
<tr>
<td>String</td>
<td>“string”</td>
</tr>
<tr>
<td>Symbol</td>
<td>“symbol”</td>
</tr>
<tr>
<td>Function</td>
<td>“function”</td>
</tr>
<tr>
<td>其他对象</td>
<td>“object”</td>
</tr>
<tr>
<td>宿主对象（由JS环境提供，如Nodejs有global，浏览器有window）</td>
<td>取决于具体实现</td>
</tr>
</tbody></table>
<ol>
<li><code>typeof null</code>的结果也是<code>&quot;object&quot;</code></li>
<li>对象的种类很多，<code>typeof</code>得到的结果无法判断出数组，普通对象，其他特殊对象</li>
</ol>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p><code>instanceof</code> 运算符用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p>
<p>利用<code>instanceof</code>，我们可以判断一个对象是不是某个构造函数的实例。那么结合<code>typeof</code>，我们可以封装一个基本的判断数据类型的函数。</p>
<p>基本思想是：首先看<code>typeof</code>是不是返回<code>&quot;object&quot;</code>，如果不是，说明是普通数据类型，那么直接返回<code>typeof</code>运算结果即可；如果是，则需要先把<code>null</code>这个坑货摘出来，然后依次判断其他对象类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getType</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> type = <span class="keyword">typeof</span> val;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// null不是对象，所以不能用instanceof判断</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;null&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val <span class="keyword">instanceof</span> <span class="title class_">Array</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;array&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;date&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">// 其他对象的instanceof判断) &#123;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val <span class="keyword">instanceof</span> <span class="title class_">Object</span>) &#123;</span><br><span class="line">            <span class="comment">// 所有对象都是Object的实例，所以放最后</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;object&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试下</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="title class_">Symbol</span>(<span class="number">1</span>)) <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="literal">null</span>) <span class="comment">// &quot;null&quot;</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()) <span class="comment">// &quot;date&quot;</span></span><br><span class="line"><span class="title function_">getType</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// &quot;array&quot;</span></span><br><span class="line"><span class="title function_">getType</span>(&#123;&#125;) <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><p><code>Object.prototype.toString</code>。也可以判断<code>ES6</code>引入的一些新的对象类型，比如<code>Map</code>, <code>Set</code>等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用了Object.prototype.toString和正则表达式的捕获组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getType</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(val).<span class="title function_">replace</span>(<span class="regexp">/\[object\s(\w+)\]/</span>, <span class="string">&#x27;$1&#x27;</span>).<span class="title function_">toLowerCase</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getType</span>(<span class="keyword">new</span> <span class="title class_">Map</span>()) <span class="comment">// &quot;map&quot;</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="keyword">new</span> <span class="title class_">Set</span>()) <span class="comment">// &quot;set&quot;</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;&#125;)) <span class="comment">// &quot;promise&quot;</span></span><br></pre></td></tr></table></figure>

<p>为什么普通的调用<code>toString</code>不能判断数据类型，而<code>Object.prototype.toString</code>可以呢？</p>
<p>因为<code>Object</code>是基类，而各个派生类，如<code>Date</code>， <code>Array</code>等在继承<code>Object</code>的时候，一般都重写(<code>overwrite</code>)了<code>toString</code>方法，用以表达自身业务，从而失去了判断类型的能力。</p>
<h2 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h2><p>把原始类型转换为对应的对象类型的操作称为装箱，反之是拆箱。</p>
<h3 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h3><p>只有对象才可以拥有属性和方法，但是我们在使用一些基本类型数据的时候，却可以直接调用它们的一些属性或方法，这是怎么回事呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">a.<span class="title function_">toFixed</span>(<span class="number">2</span>); <span class="comment">// &quot;1.00&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;I love study&#x27;</span>;</span><br><span class="line">b.<span class="property">length</span>; <span class="comment">// 12</span></span><br><span class="line">b.<span class="title function_">substring</span>(<span class="number">2</span>, <span class="number">6</span>); <span class="comment">// &quot;love&quot;</span></span><br></pre></td></tr></table></figure>

<p>其实在读取一些基本类型数据的属性或方法时，<code>javascript</code>会创建临时对象（也称为“包装对象”），通过这个临时对象来读取属性或方法。以上代码等价于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> aObj = <span class="keyword">new</span> <span class="title class_">Number</span>(a);</span><br><span class="line">aObj.<span class="title function_">toFixed</span>(<span class="number">2</span>); <span class="comment">// &quot;1.00&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;I love study&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> bObj1 = <span class="keyword">new</span> <span class="title class_">String</span>(b);</span><br><span class="line">bObj1.<span class="property">length</span>; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">var</span> bObj2 = <span class="keyword">new</span> <span class="title class_">String</span>(b);</span><br><span class="line">bObj2.<span class="title function_">substring</span>(<span class="number">2</span>, <span class="number">6</span>); <span class="comment">// &quot;love&quot;</span></span><br></pre></td></tr></table></figure>

<p>临时对象是只读的，可以理解为它们在发生读操作后就销毁了，所以不能给它们定义新的属性，也不能修改它们现有的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">c.<span class="property">name</span> = <span class="string">&#x27;jack&#x27;</span>; <span class="comment">// 给临时对象加新属性是无效的</span></span><br><span class="line">c.<span class="property">name</span>; <span class="comment">// undefined</span></span><br><span class="line">c.<span class="property">length</span>; <span class="comment">// 3</span></span><br><span class="line">c.<span class="property">length</span> = <span class="number">2</span>; <span class="comment">// 修改临时对象的属性值，是无效的</span></span><br><span class="line">c.<span class="property">length</span>; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>我们也可以显示地进行装箱操作，即通过<code>String()</code>, <code>Number()</code>, <code>Boolean()</code>构造函数来显示地创建包装对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;I love study&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> bObj = <span class="keyword">new</span> <span class="title class_">String</span>(b);</span><br></pre></td></tr></table></figure>

<h3 id="拆箱"><a href="#拆箱" class="headerlink" title="拆箱"></a>拆箱</h3><p>对象的拆箱操作是通过<code>valueOf</code>和<code>toString</code>完成的。</p>
<h2 id="类型的转换"><a href="#类型的转换" class="headerlink" title="类型的转换"></a>类型的转换</h2><p><code>javascript</code>在某些场景会自动执行类型转换操作，而我们也会根据业务的需要进行数据类型的转换。类型的转换规则如下：</p>
<p><img src="https://github.com/gjbegjbe/pics/blob/main/202208311703006.png?raw=true" alt="202208311703006.png"></p>
<h3 id="对象到原始值的转换"><a href="#对象到原始值的转换" class="headerlink" title="对象到原始值的转换"></a>对象到原始值的转换</h3><h4 id="toString"><a href="#toString" class="headerlink" title="toString"></a>toString</h4><p><code>toString()</code>是默认的对象到字符串的转换方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">a.<span class="title function_">toString</span>(); <span class="comment">// &quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure>

<p>但是很多类都自定义了<code>toString()</code>方法，举例如下：</p>
<ul>
<li>Array：将数组元素用逗号拼接成字符串作为返回值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.<span class="title function_">toString</span>(); <span class="comment">// 1,2,3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Function：返回一个字符串，字符串的内容是函数源代码。</li>
<li>Date：返回一个日期时间字符串。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">a.<span class="title function_">toString</span>(); <span class="comment">// &quot;Sun May 10 2020 11:19:29 GMT+0800 (中国标准时间)&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>RegExp：返回表示正则表达式直接量的字符串。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="regexp">/\d+/</span>;</span><br><span class="line">a.<span class="title function_">toString</span>(); <span class="comment">// &quot;/\d+/&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h4><p><code>valueOf()</code>会默认地返回对象本身，包括<code>Object</code>, <code>Array</code>, <code>Function</code>, <code>RegExp</code>。</p>
<p>日期类<code>Date</code>重写了<code>valueOf()</code>方法，返回一个1970年1月1日以来的毫秒数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">a.<span class="title function_">toString</span>(); <span class="comment">// 1589095600419</span></span><br></pre></td></tr></table></figure>

<h4 id="对象–-gt-布尔值"><a href="#对象–-gt-布尔值" class="headerlink" title="对象–&gt;布尔值"></a>对象–&gt;布尔值</h4><p>从上表可见，对象（包括数组和函数）转换为布尔值都是<code>true</code>。</p>
<h4 id="对象–-gt-字符串"><a href="#对象–-gt-字符串" class="headerlink" title="对象–&gt;字符串"></a>对象–&gt;字符串</h4><p>对象转字符串的基本规则如下：</p>
<ul>
<li>如果对象具有<code>toString()</code>方法，则调用这个方法。如果它返回字符串，则作为转换的结果；如果它返回其他原始值，则将原始值转为字符串，作为转换的结果。</li>
<li>如果对象没有<code>toString()</code>方法，或<code>toString()</code>不返回原始值（不返回原始值这种情况好像没见过，一般是自定义类的<code>toString()</code>方法吧），那么<code>javascript</code>会调用<code>valueOf()</code>方法。如果存在<code>valueOf()</code>方法并且<code>valueOf()</code>方法返回一个原始值，<code>javascript</code>将这个值转换为字符串（如果这个原始值本身不是字符串），作为转换的结果。</li>
<li>否则，<code>javascript</code>无法从<code>toString()</code>或<code>valueOf()</code>获得一个原始值，会抛出异常。</li>
</ul>
<h4 id="对象–-gt-数字"><a href="#对象–-gt-数字" class="headerlink" title="对象–&gt;数字"></a>对象–&gt;数字</h4><p>与对象转字符串的规则类似，只不过是优先调用<code>valueOf()</code>。</p>
<ul>
<li>如果对象具有<code>valueOf()</code>方法，且<code>valueOf()</code>返回一个原始值，则<code>javascript</code>将这个原始值转换为数字（如果原始值本身不是数字），作为转换结果。</li>
<li>否则，如果对象有<code>toString()</code>方法且返回一个原始值，<code>javascript</code>将这个原始值转换为数字，作为转换结果。</li>
<li>否则，<code>javascript</code>将抛出一个类型错误异常。</li>
</ul>
<h3 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h3><p>使用<code>String()</code>, <code>Number()</code>, <code>Boolean()</code>函数强制转换类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="title class_">String</span>(a); <span class="comment">// &quot;1&quot;</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="title class_">Boolean</span>(a); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><h4 id="加法运算符"><a href="#加法运算符" class="headerlink" title="加法运算符+"></a>加法运算符+</h4><p>因为加法运算符<code>+</code>可以用于数字加法，也可以用于字符串连接，所以加法运算符的两个操作数可能是类型不一致的。</p>
<ul>
<li>如果其中一个运算符是对象，则会遵循对象到原始值的转换规则，对于非日期对象来说，对象到原始值的转换基本上是对象到数字的转换，所以首先调用<code>valueOf()</code>，然而大部分对象的<code>valueOf()</code>返回的值都是对象本身，不是一个原始值，所以最后也是调用<code>toString()</code>去获得原始值。对于日期对象来说，会使用对象到字符串的转换，所以首先调用<code>toString()</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + &#123;&#125;; <span class="comment">// &quot;1[object Object]&quot;</span></span><br><span class="line"><span class="number">1</span> + <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">// &quot;1Sun May 10 2020 22:53:24 GMT+0800 (中国标准时间)&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在进行了对象到原始值的转换后，如果加法运算符<code>+</code>的其中一个操作数是字符串的话，就将另一个操作数也转换为字符串，然后进行字符串连接。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125; + <span class="literal">false</span>; <span class="comment">// &quot;[object Object]false&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">1</span> + []; <span class="comment">// &quot;1&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>否则，两个操作数都将转换为数字（或者NaN），然后进行加法操作。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> + <span class="literal">true</span>; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">1</span> + <span class="literal">undefined</span>; <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">1</span> + <span class="literal">null</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h4 id="x3D-x3D"><a href="#x3D-x3D" class="headerlink" title="[] &#x3D;&#x3D; ![]"></a>[] &#x3D;&#x3D; ![]</h4><p><code>[] == ![]</code>，其结果是<code>true</code>。</p>
<ol>
<li><p>首先，我们要知道运算符的优先级是这样的，一元运算符<code>!</code>的优先级高于关系运算符<code>==</code>。</p>
<p><img src="https://github.com/gjbegjbe/pics/blob/main/202208311745552.png?raw=true" alt="202208311745552.png"></p>
</li>
<li><p>所以，右侧的<code>![]</code>首先会执行，而逻辑非运算符<code>!</code>会首先将其操作数转为布尔值，再进行求反。<code>[]</code>转为布尔值是<code>true</code>，所以<code>![]</code>的结果是<code>false</code>。此时的比较变成了<code>[] == false</code>。</p>
</li>
<li><p>根据比较规则，如果<code>==</code>的其中一个值是<code>false</code>，则将其转换为数字<code>0</code>，再与另一个操作数比较。此时的比较变成了<code>[] == 0</code>。</p>
</li>
<li><p>接着，再参考比较规则，如果一个值是对象，另一个值是数字或字符串，则将对象转为原始值，再进行比较。左侧的<code>[]</code>转为原始值是空字符串<code>&quot;&quot;</code>，所以此时的比较变成了<code>&quot;&quot; == 0</code>。</p>
</li>
<li><p>最后，如果一个值是数字，另一个是字符串，先将字符串转换为数字，再进行比较。空字符串会转为数字<code>0</code>，<code>0</code>与<code>0</code>自然是相等的。</p>
</li>
</ol>
<p>也可以分析下为什么<code>&#123;&#125; == !&#123;&#125;</code>的结果是<code>false</code>了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gjbegjbe.github.io/2022/08/30/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gjbe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gjbe">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/30/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/" class="post-title-link" itemprop="url">前端浏览器缓存知识梳理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-30 14:03:24 / 修改时间：17:14:42" itemprop="dateCreated datePublished" datetime="2022-08-30T14:03:24+08:00">2022-08-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>缓存就是，当第一次访问网站的时候，电脑会把图片和数据下载到电脑上，再次访问时，网站就会直接加载出来。</p>
<p>缓存的好处：</p>
<ol>
<li>缓解服务器压力，不用每次都去请求某些数据了。</li>
<li>提升性能，打开本地资源肯定会比请求服务器来的快。</li>
<li>减少带宽消耗，当我们使用缓存时，只会产生很小的网络消耗，至于为什么打开本地资源也会产生网络消耗，下面会有说明。</li>
</ol>
<p>Web 缓存种类： 数据库缓存，CDN 缓存，代理服务器缓存，浏览器缓存。</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208301425142.png"></p>
<p>所谓浏览器缓存其实就是指在本地使用的计算机中开辟⼀个内存区，同时也开辟一个硬盘区作为数据传输的缓冲区，然后用这个缓冲区来暂时保存用户以前访问过的信息。</p>
<p>浏览器缓存过程：强缓存，协商缓存。</p>
<p>浏览器缓存位置⼀般分为四类： Service Worker–&gt;Memory Cache–&gt;Disk Cache–&gt;Push Cache。</p>
<h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>强缓存是当我们访问 URL 的时候，不会向服务器发送请求，直接从缓存中读取资源，但是会返回200 的状态码。</p>
<p>如何设置强缓存？</p>
<p>我们第⼀次进入页面，请求服务器，然后服务器进行应答，浏览器会根据 response Header 来判断是否对资源进行缓存，如果响应头中 expires、pragma 或者 cache-control 字段，代表这是强缓存，浏览器就会把资源缓存在 memory cache 或 disk cache 中。</p>
<p>第二次请求时，浏览器判断请求参数，如果符合强缓存条件就直接返回状态码 200，从本地缓存中拿数据。否则把响应参数存在 request header 请求头中，看是否符合协商缓存，符合则返回状态码 304，不符合则服务器会返回全新资源。</p>
<p><img src="https://github.com/gjbegjbe/pics/blob/main/202208301502686.png?raw=true" alt="202208301502686.png"></p>
<h3 id="expires"><a href="#expires" class="headerlink" title="expires"></a>expires</h3><p>是 HTTP1.0 控制网页缓存的字段，值为一个时间戳，准确来讲是格林尼治时间，服务器返回该请求结果缓存的到期时间，意思是，再次发送请求时，如果未超过过期时间，直接使用该缓存，如果过期了则重新请求。</p>
<p>有个缺点，就是它判断是否过期是用本地时间来判断的，本地时间是可以自己修改的。</p>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>是 HTTP1.1 中控制网页缓存的字段，当 Cache-Control 都存在时，Cache-Control 优先级更高，主要取值为：</p>
<p>public：资源客户端和服务器都可以缓存。<br>privite：资源只有客户端可以缓存。<br>no-cache：客户端缓存资源，但是是否缓存需要经过协商缓存来验证。<br>no-store：不使用缓存。<br>max-age：缓存保质期。</p>
<p><img src="https://github.com/gjbegjbe/pics/blob/main/202208301526543.png?raw=true" alt="202208301526543.png"></p>
<p>Cache-Control 使用了 max-age 相对时间，解决了 expires 的问题。</p>
<h3 id="pragma"><a href="#pragma" class="headerlink" title="pragma"></a>pragma</h3><p>这个是 HTTP1.0 中禁用网页缓存的字段，其取值为 no-cache，和 Cache-Control 的 no-cache效果⼀样。</p>
<p><img src="https://github.com/gjbegjbe/pics/blob/main/202208301530413.png?raw=true" alt="202208301530413.png"></p>
<h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><p>什么资源放在memory cache，什么资源放在 disk cache 中？</p>
<p><img src="https://github.com/gjbegjbe/pics/blob/main/202208301535610.png?raw=true" alt="202208301535610.png"></p>
<p>存储图像和网页等资源主要缓存在 disk cache，操作系统缓存文件等资源大部分都会缓存在memory cache 中。具体操作浏览器自动分配，看谁的资源利用率不高就分给谁。</p>
<p>memory cache 请求时间都是 0ms</p>
<p>查找浏览器缓存时会按顺序查找: Service Worker–&gt;Memory Cache–&gt;Disk Cache–&gt;Push Cache。</p>
<h3 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h3><p>是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</p>
<h3 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h3><p>内存中的缓存，主要包含的是当前中页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。</p>
<p>读取内存中的数据肯定比磁盘快，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。⼀旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</p>
<h3 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h3><p>存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。</p>
<p>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源⼀旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自Disk Cache。</p>
<p>memory cache 要比 disk cache 快的多。举个例子：从远程 web 服务器直接提取访问文件可能需要 500 毫秒 (半秒)，那么磁盘访问可能需要 10-20 毫秒，而内存访问只需要 100 纳秒，更高级的还有 L1 缓存访问 (最快和最小的 CPU 缓存) 只需要 0.5 纳秒。</p>
<p><img src="https://github.com/gjbegjbe/pics/blob/main/202208301604901.png?raw=true" alt="202208301604901.png"></p>
<p>prefetch cache (预取缓存)</p>
<p>link 标签上带了 prefetch，再次加载会出现。</p>
<p>prefetch 是预加载的一种方式，被标记为 prefetch 的资源，将会被浏览器在空闲时间加载。</p>
<h3 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h3><p>Push Cache（推送缓存）是 HTTP&#x2F;2 中的内容，当以上三种缓存都没有命中时，它才会被使用。<br>它只在会话（Session）中存在，⼀旦会话结束就被释放，并且缓存时间也很短暂，在Chrome 浏览器中只有 5 分钟左右，同时它也并非严格执行HTTP 头中的缓存指令。</p>
<h3 id="CPU、内存、硬盘"><a href="#CPU、内存、硬盘" class="headerlink" title="CPU、内存、硬盘"></a>CPU、内存、硬盘</h3><p>CPU、内存、硬盘都是计算机的主要组成部分。</p>
<p>CPU：中央处理单元 (CentralProcessingUnit) 的缩写，也叫处理器，是计算机的运算核心和控制核心。电脑靠 CPU 来运算、控制。让电脑的各个部件顺利工作，起到协调和控制作用。</p>
<p>硬盘：存储资料和软件等数据的设备，有容量大，断电数据不丢失的特点。</p>
<p>内存：负责硬盘等硬件上的数据与 CPU 之间数据交换处理。特点是体积小，速度快，有电可存，无电清空，即电脑在开机状态时内存中可存储数据，关机后将自动清空其中的所有数据。</p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>协商缓存就是强缓存失效后，浏览器携带缓存标识向服务器发送请求，由服务器根据缓存标识来决定是否使用缓存的过程。</p>
<p>以下两种情况：</p>
<p>协商缓存生效，返回 304<br><img src="https://github.com/gjbegjbe/pics/blob/main/202208301638199.png?raw=true" alt="202208301638199.png"></p>
<p>协商缓存失效，返回 200 和请求结果<br><img src="https://github.com/gjbegjbe/pics/blob/main/202208301640340.png?raw=true" alt="202208301640340.png"></p>
<p>如何设置协商缓存？</p>
<h3 id="Last-Modified-x2F-If-Modified-Since"><a href="#Last-Modified-x2F-If-Modified-Since" class="headerlink" title="Last-Modified&#x2F;If-Modified-Since"></a>Last-Modified&#x2F;If-Modified-Since</h3><p>Last-Modified 是服务器响应请求时，返回该资源文件在服务器最后被修改的时间。</p>
<p><img src="https://github.com/gjbegjbe/pics/blob/main/202208301647514.png?raw=true" alt="202208301647514.png"></p>
<p>If-Modified-Since 则是客户端再次发起该请求时，携带上次请求返回的 Last-Modified 值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有 If-Modified-Since 字段，则会根据 If-Modified-Since 的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于 If-Modified-Since 的字段值，则重新返回资源，状态码为 200；否则则返回 304，代表资源无更新，可继续使用缓存文件。</p>
<p><img src="https://github.com/gjbegjbe/pics/blob/main/202208301654404.png?raw=true" alt="202208301654404.png"></p>
<h3 id="Etag-x2F-If-None-Match"><a href="#Etag-x2F-If-None-Match" class="headerlink" title="Etag&#x2F;If-None-Match"></a>Etag&#x2F;If-None-Match</h3><p>Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识 (由服务器生成)。</p>
<p><img src="https://github.com/gjbegjbe/pics/blob/main/202208301658330.png?raw=true" alt="202208301658330.png"></p>
<p>If-None-Match 是客户端再次发起该请求时，携带上次请求返回的唯⼀标识 Etag 值，通过此字段值告诉服务器该资源上次请求返回的唯⼀标识值。服务器收到该请求后，发现该请求头中含有 If-None-Match，则会根据 If-None-Match 的字段值与该资源在服务器的 Etag 值做对比，一致则返回 304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为 200。</p>
<p><img src="https://github.com/gjbegjbe/pics/blob/main/202208301700729.png?raw=true" alt="202208301700729.png"></p>
<p>Etag &#x2F; If-None-Match 优先级高于 Last-Modified &#x2F; If-Modified-Since，同时存在则只有Etag &#x2F; If-None-Match 生效。</p>
<h2 id="缓存方案"><a href="#缓存方案" class="headerlink" title="缓存方案"></a>缓存方案</h2><p>目前的项目大多使用这种缓存方案的：<br>HTML: 协商缓存；<br>css、js、图片：强缓存，文件名带上 hash。</p>
<h2 id="强缓存与协商缓存的区别"><a href="#强缓存与协商缓存的区别" class="headerlink" title="强缓存与协商缓存的区别"></a>强缓存与协商缓存的区别</h2><ol>
<li>强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。</li>
<li>大部分 web 服务器都默认开启协商缓存。</li>
</ol>
<h2 id="刷新对于强缓存和协商缓存的影响"><a href="#刷新对于强缓存和协商缓存的影响" class="headerlink" title="刷新对于强缓存和协商缓存的影响"></a>刷新对于强缓存和协商缓存的影响</h2><ol>
<li>当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存。</li>
<li>当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存。</li>
<li>浏览器地址栏中写入 URL，回车浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gjbegjbe.github.io/2022/08/29/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90CSS%E9%80%89%E6%8B%A9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gjbe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gjbe">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/29/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90CSS%E9%80%89%E6%8B%A9%E5%99%A8/" class="post-title-link" itemprop="url">深入解析CSS选择器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-29 09:38:41" itemprop="dateCreated datePublished" datetime="2022-08-29T09:38:41+08:00">2022-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-30 11:58:40" itemprop="dateModified" datetime="2022-08-30T11:58:40+08:00">2022-08-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>优先级是基于不同种类选择器组成的匹配规则。浏览器通过优先级来判断哪些样式与一个元素最为相关，从而在该元素上应用这些样式。</p>
<h2 id="CSS选择器的分类"><a href="#CSS选择器的分类" class="headerlink" title="CSS选择器的分类"></a>CSS选择器的分类</h2><p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208290943458.png"></p>
<h2 id="不同种类选择器的用法"><a href="#不同种类选择器的用法" class="headerlink" title="不同种类选择器的用法"></a>不同种类选择器的用法</h2><p>基本选择器以外的选择器的用法。</p>
<h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p>通过已经存在的属性名或属性值匹配元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span> &#123;  <span class="attribute">margin-top</span>: <span class="number">20px</span>;&#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 带有属性 title 的元素 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-attr">[title]</span>&#123;  <span class="attribute">background</span>: <span class="number">#faf3e0</span>; &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 带有属性 class 且值为 div1 的元素 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-attr">[class=div1]</span>&#123; <span class="attribute">background</span>: <span class="number">#eabf9f</span>;  &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 带有属性 attr 并且该属性是一个以空格作为分隔的值列表，其中至少有一个值为 attr-test2 的元素 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-attr">[attr~=attr-test2]</span>&#123;  <span class="attribute">background</span>: <span class="number">#b68973</span>; &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 带有属性 attr 且值以 te 为开头的元素 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-attr">[attr^=te]</span>&#123; <span class="attribute">background</span>: <span class="number">#f39189</span>; &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 带有属性 attr 且值以 Test 为结尾的元素 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-attr">[attr$=Test]</span>&#123; <span class="attribute">background</span>: <span class="number">#bb8082</span>; &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 带有属性 attr 且值包含 test3 的元素 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-attr">[attr*=test3]</span>&#123; <span class="attribute">background</span>: <span class="number">#6e7582</span>; &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 带有属性 attr 且值为 attr1 或以 attr1- 开头 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-attr">[attr|=attr1]</span>&#123; <span class="attribute">background</span>: <span class="number">#046582</span>; &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 属性选择器默认区分大小写，在属性选择器的右方括号前添加一个用空格隔开的字母 i（或 I），可忽略大小写 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-attr">[attr*=test5 i]</span>&#123; <span class="attribute">background</span>: <span class="number">#865858</span>; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">title</span>=<span class="string">&#x27;helloWorld&#x27;</span>&gt;</span>[title]<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div1&quot;</span>&gt;</span>[class=div1]<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">attr</span>=<span class="string">&#x27;attr-test1 attr-test2&#x27;</span>&gt;</span>[attr~=attr-test2]<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">attr</span>=<span class="string">&#x27;test&#x27;</span>&gt;</span>[attr^=te]<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">attr</span>=<span class="string">&#x27;attrTest&#x27;</span>&gt;</span>[attr$=Test]<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">attr</span>=<span class="string">&#x27;attr-test3&#x27;</span>&gt;</span>[attr*=test3]<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">attr</span>=<span class="string">&#x27;attr1-test4&#x27;</span>&gt;</span>[attr|=attr1]<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">attr</span>=<span class="string">&#x27;attr-Test5&#x27;</span>&gt;</span>attr*=test5 i<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208291919919.png"></p>
<h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208291922693.png"></p>
<h4 id="动态伪类（多用于超链接的样式）"><a href="#动态伪类（多用于超链接的样式）" class="headerlink" title="动态伪类（多用于超链接的样式）"></a>动态伪类（多用于超链接的样式）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="comment">/* 未访问的链接 */</span></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123; <span class="attribute">color</span>: <span class="number">#11698e</span>; &#125;</span></span><br><span class="line"><span class="language-css">  <span class="comment">/* 已访问过的链接  注:只要是当前浏览器有访问记录的都算作已访问的状态 */</span></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>: <span class="number">#9fb8ad</span>; &#125;</span></span><br><span class="line"><span class="language-css">  <span class="comment">/* 当鼠标悬浮在元素上方时 */</span> </span></span><br><span class="line"><span class="language-css">  <span class="comment">/* 注: 为了使点击过后的链接仍然受设置的伪类样式影响，在CSS 定义时 :hover 需设置在 :link 和 :visited 之后 */</span></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123; <span class="attribute">color</span>: <span class="number">#383e56</span>; &#125;</span></span><br><span class="line"><span class="language-css">  <span class="comment">/* 被激活的元素 (鼠标点下且为松开时) */</span> </span></span><br><span class="line"><span class="language-css">  <span class="comment">/* 注: 为了使点击过后的链接仍然受设置的伪类样式影响，在CSS 定义时 :active 需设置在 :hover 之后 */</span></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">a</span><span class="selector-pseudo">:active</span>&#123; <span class="attribute">color</span>: <span class="number">#fb743e</span>; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">href</span>=<span class="string">&#x27;https://juejin.cn/user/3456520257288974&#x27;</span>&gt;</span>超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>伪类的active在IOS下存在兼容问题。</p>
<h4 id="目标伪类、否定伪类、语言伪类"><a href="#目标伪类、否定伪类、语言伪类" class="headerlink" title="目标伪类、否定伪类、语言伪类"></a>目标伪类、否定伪类、语言伪类</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">html</span> &#123; <span class="attribute">font-size</span>: <span class="number">14px</span>; &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 目标伪类 :target: 代表一个唯一的页面元素(目标元素)，其 id 与当前URL片段匹配 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span><span class="selector-pseudo">:target</span> &#123; <span class="attribute">color</span>: <span class="number">#f05454</span>; &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 否定伪类 :not   注: 仅 Chrome、Firefox 和 Safari 高版本浏览器适用*/</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span><span class="selector-pseudo">:not</span>(<span class="selector-id">#p1</span>)&#123; <span class="attribute">color</span>: <span class="number">#e27802</span>; &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 语言伪类 :lang */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span><span class="selector-pseudo">:lang</span>(zh) &#123; <span class="attribute">color</span>: <span class="number">#ffc1b6</span>; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>目标伪类 :target<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span>&gt;</span>目标伪类: 这是 div1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div2&quot;</span>&gt;</span>目标伪类: 这是 div2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>否定伪类 :not<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>否定伪类: 这是 p1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p2&quot;</span>&gt;</span>否定伪类: 这是 p2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>语言伪类 :lang<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>语言伪类: 这是 en<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span>&gt;</span>语言伪类: 这是 zh<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208291932375.png"></p>
<h4 id="结构伪类"><a href="#结构伪类" class="headerlink" title="结构伪类"></a>结构伪类</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 父元素的第一个子元素且该子元素为 p 的元素 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-child &#123; <span class="attribute">background</span>: <span class="number">#046582</span>; &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 父元素中第一个 span 元素 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">span</span><span class="selector-pseudo">:first</span>-of-type &#123; <span class="attribute">background</span>: <span class="number">#6e7582</span>; &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 父元素中第 2n 个子元素且为 p 的元素 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>n) &#123; <span class="attribute">background</span>: <span class="number">#bb8082</span>; &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 父元素中第 2n 个 span 元素 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">span</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">2</span>n) &#123; <span class="attribute">background</span>: <span class="number">#f39189</span>; &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 父元素有且仅有一个为 i 的元素 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">i</span><span class="selector-pseudo">:only-child</span> &#123; <span class="attribute">background</span>: <span class="number">#865858</span>; &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 父元素有且仅有一个为 strong 的元素 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">strong</span><span class="selector-pseudo">:only-of-type</span> &#123; <span class="attribute">background</span>: <span class="number">#8e7f7f</span>; &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 没有子元素的元素 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span><span class="selector-pseudo">:empty</span> &#123; <span class="attribute">height</span>: <span class="number">16px</span>; <span class="attribute">background</span>: <span class="number">#bbb</span>; &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 根元素   HTML 中相当于 &lt;html&gt; */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-pseudo">:root</span> &#123; <span class="attribute">background</span>: <span class="number">#e2d5d5</span>; <span class="attribute">color</span>: <span class="number">#fff</span>; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>这是 p1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;p2&quot;</span>&gt;</span>这是 p2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;p3&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span>这是 p3<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;p4&quot;</span>&gt;</span>这是 p4<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;span1&quot;</span>&gt;</span>这是 span1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;span2&quot;</span>&gt;</span>这是 span2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;empty-p p5&quot;</span>&gt;</span>这是 p5<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">strong</span>&gt;</span>这是 strong<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208301041099.png"></p>
<h4 id="UI元素伪类"><a href="#UI元素伪类" class="headerlink" title="UI元素伪类"></a>UI元素伪类</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">   <span class="comment">/* :enabled 可用状态 */</span></span></span><br><span class="line"><span class="language-css">   <span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;radio&quot;</span>]</span><span class="selector-pseudo">:enabled</span> &#123;  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3px</span> <span class="number">#7c9473</span>; &#125;</span></span><br><span class="line"><span class="language-css">   <span class="comment">/* :disabled 禁用状态 */</span></span></span><br><span class="line"><span class="language-css">   <span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;radio&quot;</span>]</span><span class="selector-pseudo">:disabled</span> &#123;  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3px</span> <span class="number">#cfdac8</span>;  <span class="attribute">cursor</span>: not-allowed; &#125;</span></span><br><span class="line"><span class="language-css">   <span class="comment">/* :checked radio 或 checkbox 表单被勾选状态 */</span></span></span><br><span class="line"><span class="language-css">   <span class="comment">/* 注意书写顺序，选择元素相同时 :checked 应写在 :enabled/:disabled 后面 */</span></span></span><br><span class="line"><span class="language-css">   <span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;radio&quot;</span>]</span><span class="selector-pseudo">:checked</span> &#123;  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3px</span> <span class="number">#c0e218</span> ; &#125;</span></span><br><span class="line"><span class="language-css">   <span class="comment">/* :default 表示一组相关元素中的默认(选中)表单元素   此处 :default 应用于默认设置了 checked 的 radio 表单上 */</span></span></span><br><span class="line"><span class="language-css">   <span class="comment">/* 该选择器可以在 &lt;button&gt;, &lt;input type=&quot;checkbox&quot;&gt;, &lt;input type=&quot;radio&quot;&gt;, 以及 &lt;option&gt; 上使用 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;radio&quot;</span>]</span><span class="selector-pseudo">:default</span> &#123;  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3px</span> <span class="number">#86aba1</span>;&#125;</span></span><br><span class="line"><span class="language-css">   <span class="comment">/* :read-only 只读状态 */</span></span></span><br><span class="line"><span class="language-css">   <span class="selector-tag">input</span><span class="selector-pseudo">:read-write</span> &#123; <span class="attribute">background</span>: <span class="number">#7c9473</span>; &#125;</span></span><br><span class="line"><span class="language-css">   <span class="comment">/* :read-only 只读状态 */</span></span></span><br><span class="line"><span class="language-css">   <span class="selector-tag">input</span><span class="selector-pseudo">:read-only</span> &#123; <span class="attribute">background</span>: <span class="number">#cfdac8</span>; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;my-radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;radio1&quot;</span> <span class="attr">checked</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;radio1&quot;</span>&gt;</span>默认选中<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;my-radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;radio2&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;radio2&quot;</span>&gt;</span>未选中-可用<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;my-radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;radio1&quot;</span> <span class="attr">disabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;radio1&quot;</span>&gt;</span>未选中-禁用<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;input&quot;</span> <span class="attr">name</span>=<span class="string">&quot;my-input&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;input1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;input&quot;</span> <span class="attr">name</span>=<span class="string">&quot;my-input&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;input2&quot;</span> <span class="attr">readonly</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208301054532.png"></p>
<h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span> &#123; <span class="attribute">margin-left</span>: <span class="number">50px</span>;&#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* ::after 在选中元素的最后添加一个子元素，默认为行内元素 (替换元素上不生效) */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.div1</span><span class="selector-pseudo">::after</span> &#123; <span class="attribute">content</span>: <span class="string">&#x27;div1 的 after&#x27;</span>; <span class="attribute">margin-left</span>: <span class="number">10px</span>; <span class="attribute">color</span>: <span class="number">#ef4f4f</span> &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* ::before 在选中元素的第一个位置添加一个子元素 (其他用法同 ::after) */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.div2</span><span class="selector-pseudo">::before</span> &#123; <span class="attribute">content</span>: <span class="string">&#x27;div2 的 before&#x27;</span>; <span class="attribute">margin-right</span>: <span class="number">10px</span>; <span class="attribute">color</span>: <span class="number">#ee9595</span> &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* ::first-letter 匹配选中块级元素的第一行的第一个字符 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.div3</span><span class="selector-pseudo">::first-letter</span> &#123; <span class="attribute">color</span>: <span class="number">#ff4646</span> &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* ::first-line 匹配选中块级元素的第一行 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.div4</span><span class="selector-pseudo">::first-line</span> &#123; <span class="attribute">color</span>:  <span class="number">#9dab86</span> &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* ::marker 匹配选中有序或无序列表的序号或符号 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.div5</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">::marker</span> &#123; <span class="attribute">color</span>: <span class="number">#fdb827</span> &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* ::selection 匹配元素中被选中高亮的部分 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.div6</span><span class="selector-pseudo">::selection</span> &#123; <span class="attribute">background</span>: <span class="number">#9dab86</span>; <span class="attribute">color</span>: white &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div1&quot;</span>&gt;</span>div1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div2&quot;</span>&gt;</span>div2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div3&quot;</span>&gt;</span>div3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div4&quot;</span>&gt;</span>div4第一行<span class="tag">&lt;<span class="name">br</span>&gt;</span>div4第二行<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div5&quot;</span>&gt;</span>div5</span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>item2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>item3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div6&quot;</span>&gt;</span>div6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208301117769.png"></p>
<p>一个选择器中只能使用一个伪元素<br>CSS3 中伪元素应该用双冒号，以便区分伪元素和伪类。但是旧版的规范未做明确区分，所以大多数浏览器中支持部分伪元素使用单双冒号两种写法。</p>
<h3 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 后代选择器  空格隔开   匹配所有符合的后代元素*/</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span> <span class="selector-tag">span</span> &#123; <span class="attribute">margin-left</span>: <span class="number">10px</span>; <span class="attribute">background</span>: <span class="number">#ff8585</span>  &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 直接子后代选择器  &gt; 连接; 匹配符合的直接子元素; 不包括子元素的子元素 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.div1</span>&gt;<span class="selector-tag">span</span> &#123; <span class="attribute">color</span>: <span class="number">#6155a6</span> &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 群组选择器  逗号隔开 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.div1</span>, <span class="selector-class">.div2</span> &#123; <span class="attribute">color</span>: <span class="number">#a7c5eb</span> &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 相邻兄弟元素选择器  + 连接; 匹配某元素后紧邻的兄弟元素 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.div3</span> + <span class="selector-tag">div</span> &#123; <span class="attribute">color</span>: <span class="number">#fd3a69</span> &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 兄弟选择器   ~ 连接; 匹配某元素后所有同级的指定元素，强调的是所有的 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.div5</span> ~ <span class="selector-tag">div</span> &#123;  <span class="attribute">color</span>: <span class="number">#008891</span> ; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div1&quot;</span>&gt;</span>div1</span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;span1&quot;</span>&gt;</span>span1</span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;span1-1&quot;</span>&gt;</span>span1-1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div2&quot;</span>&gt;</span>div2<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;span2&quot;</span>&gt;</span>span2<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div3&quot;</span>&gt;</span>div3<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;span3&quot;</span>&gt;</span>span3<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div4&quot;</span>&gt;</span>div4<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;span4&quot;</span>&gt;</span>span4<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div5&quot;</span>&gt;</span>div5<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;span5&quot;</span>&gt;</span>span5<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div6&quot;</span>&gt;</span>div6<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;span6&quot;</span>&gt;</span>span6<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div7&quot;</span>&gt;</span>div7<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;span7&quot;</span>&gt;</span>span7<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div8&quot;</span>&gt;</span>div8<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;span8&quot;</span>&gt;</span>span8<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208301126178.png"></p>
<h2 id="CSS选择器优先级"><a href="#CSS选择器优先级" class="headerlink" title="CSS选择器优先级"></a>CSS选择器优先级</h2><p>基本选择器的优先级是：!important &gt; 内联 &gt; ID 选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通用选择器。那么它如何计算的呢？有这样一个计算表格。</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>示例</th>
<th>权重值</th>
</tr>
</thead>
<tbody><tr>
<td>!impotant</td>
<td>color: #fff !important;</td>
<td>正无穷</td>
</tr>
<tr>
<td>内联选择器</td>
<td>样式作用元素</td>
<td>1 0 0 0</td>
</tr>
<tr>
<td>ID 选择器</td>
<td>#id</td>
<td>1 0 0</td>
</tr>
<tr>
<td>类选择器、属性选择器、伪类选择器</td>
<td>.class</td>
<td>1 0</td>
</tr>
<tr>
<td>标签选择器、伪元素选择器</td>
<td>div</td>
<td>1</td>
</tr>
<tr>
<td>通用选择器</td>
<td>*</td>
<td>0</td>
</tr>
<tr>
<td>继承属性</td>
<td>样式作用元素</td>
<td>-1</td>
</tr>
</tbody></table>
<p>假设在一个拍卖会上，有以下几种筹码：</p>
<ul>
<li>一个<code>内联样式</code>相当于一千元</li>
<li>一个<code>ID 选择器</code>相当于一百元</li>
<li>一个<code>类选择器</code>相当于十元</li>
<li>一个<code>标签选择器</code>相当于一元</li>
<li>通用选择器为零元</li>
</ul>
<p>每出现一个上述选择器，就增加对应筹码的钱数，最终采用出钱最多的样式。但是，这里的钱数计算方法和生活中的计算方法不一样，这里的”单位”不会因为值的累加而进行换算。例如十个一百只能是“十百“，仍然小于一千。</p>
<h3 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    * &#123; <span class="attribute">color</span>: <span class="number">#31326f</span> &#125; <span class="comment">/* 通用 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span> &#123; <span class="attribute">background</span>: <span class="number">#9ddfd3</span> &#125; <span class="comment">/* 标签 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.div-class</span> &#123; <span class="attribute">background</span>: <span class="number">#dbf6e9</span> &#125; <span class="comment">/* 类 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.p1</span>, <span class="selector-class">.p2</span>, <span class="selector-class">.p3</span> &#123; <span class="attribute">background</span>: <span class="number">#ffdada</span>; <span class="attribute">color</span>: <span class="number">#060930</span> &#125; <span class="comment">/* 类 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#p1-1</span> &#123; <span class="attribute">background</span>: <span class="number">#595b83</span> &#125; <span class="comment">/* id */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.p3</span> &#123; <span class="attribute">color</span>: <span class="number">#595b83</span> <span class="meta">!important</span> &#125; <span class="comment">/* !important */</span></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div-class&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello word!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;p1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;p1-1&quot;</span>&gt;</span>Hello word!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;p2&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color: white&quot;</span>&gt;</span>Hello word!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment">&lt;!-- 内联样式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;p3&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color: white&quot;</span>&gt;</span>Hello word!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment">&lt;!-- 内联样式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208301151530.png"></p>
<h3 id="其他选择器"><a href="#其他选择器" class="headerlink" title="其他选择器"></a>其他选择器</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span> &#123; <span class="attribute">color</span>: <span class="number">#a20a0a</span> &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span> <span class="selector-class">.p1</span> ~ <span class="selector-tag">p</span> &#123; <span class="attribute">background</span>: <span class="number">#fceef5</span>; <span class="attribute">color</span>: <span class="number">#ffa36c</span>  &#125; <span class="comment">/* 总权重值: 12 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span> <span class="selector-tag">p</span> ~ <span class="selector-tag">p</span> &#123; <span class="attribute">background</span>: pink; &#125; <span class="comment">/* 总权重值: 3 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.div-class</span> <span class="selector-class">.p1</span> ~ <span class="selector-tag">p</span> &#123; <span class="attribute">color</span>: <span class="number">#799351</span> &#125; <span class="comment">/* 总权重值: 21 */</span></span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 以下两行样式若互换位置，则 .p1 的 ::after 文本颜色为 #333456 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.div-class</span> <span class="selector-tag">p</span><span class="selector-pseudo">::after</span> &#123; <span class="attribute">content</span>:<span class="string">&#x27;p-after&#x27;</span>; <span class="attribute">margin-left</span>: <span class="number">10px</span>; <span class="attribute">color</span>: <span class="number">#333456</span> &#125; <span class="comment">/* 总权重值: 0 0 1 2 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span> <span class="selector-class">.p1</span><span class="selector-pseudo">::after</span> &#123; <span class="attribute">color</span>: <span class="number">#42bfd8</span> &#125; <span class="comment">/* 总权重值: 12 */</span></span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 以下两行样式若互换位置，则 .p1 的文本颜色为 #92817a */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.p1</span> &#123; <span class="attribute">color</span>: <span class="number">#92817a</span> &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-attr">[name=<span class="string">&quot;p1&quot;</span>]</span> &#123; <span class="attribute">color</span>: <span class="number">#bedbbb</span> &#125; </span></span><br><span class="line"><span class="language-css">      <span class="comment">/* 同一元素样式存在冲突且同时存在 !important */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span> <span class="selector-class">.span1</span> &#123; <span class="attribute">color</span>: <span class="number">#0e918c</span> <span class="meta">!important</span>; &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.span1</span> &#123; <span class="attribute">color</span>: <span class="number">#6a097d</span> <span class="meta">!important</span>; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div-class&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello word!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;p1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>p1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;p2&quot;</span>&gt;</span>p2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;p3&quot;</span>&gt;</span>p3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;span1&quot;</span>&gt;</span>span1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208301154499.png"></p>
<p>权重值相同时，写在后面的样式生效<br>!important 是 CSS 选择器中的一个 “流氓” 属性，不论选择器的权重或者优先级的高低，只要加上！important，那么这个样式的优先级就是最高的<br>如果针对同一元素样式存在冲突且同时存在！important ，那么选择器总权重值高者生效</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span> &#123; <span class="attribute">max-width</span>: <span class="number">100px</span>; &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span>, <span class="selector-tag">p</span> &#123; <span class="attribute">background</span>: <span class="number">#bedbbb</span> &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.div1</span> &#123; <span class="attribute">width</span>: <span class="number">200px</span> <span class="meta">!important</span>; &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.p1</span> &#123; <span class="attribute">width</span>: <span class="number">200px</span>; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div1&quot;</span>&gt;</span> 这是 div1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;p1&quot;</span>&gt;</span> 这是 p1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208301157821.png"></p>
<p>对于一些互斥的样式，例如 max-width 与 width，选择器的权重值再高也是无能为力的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如你所见，CSS 选择器也是暗藏玄机的哦。不过到目前为止，暂时没有能够通过元素选择其父元素或其父元素相关元素的选择器，这就让人很是头疼。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gjbegjbe.github.io/2022/08/24/CSS%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gjbe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gjbe">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/24/CSS%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">CSS基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-24 09:32:05" itemprop="dateCreated datePublished" datetime="2022-08-24T09:32:05+08:00">2022-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-26 17:22:55" itemprop="dateModified" datetime="2022-08-26T17:22:55+08:00">2022-08-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>CSS的核心功能是将CSS属性设置为特定的值。一个属性与值的键值对称为声明。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">color</span>: red;</span><br></pre></td></tr></table></figure>

<p>将声明用{}包起来后，就组成了声明块。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择器和声明块组成了CSS规则集，常常简称CSS规则。</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208240952533.png"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CSS注释：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 单⾏注释 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    多⾏</span></span><br><span class="line"><span class="comment">    注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="规则"><a href="#规则" class="headerlink" title="@规则"></a>@规则</h2><p>CSS包含的@规则：</p>
<p>@namespace告诉CSS引擎必须考虑XML命名空间</p>
<p>@media如果满足媒体查询条件则条件规则组里的规则生效</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* At the top level of your code */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">900px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">article</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1rem</span> <span class="number">3rem</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Nested within another conditional at-rule */</span></span><br><span class="line"><span class="keyword">@supports</span> (<span class="attribute">display</span>: flex) &#123;</span><br><span class="line">  <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">900px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">article</span> &#123;</span><br><span class="line">      <span class="attribute">display</span>: flex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@page描述打印文档时布局的变化</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@page</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1cm</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@page</span> :first &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2cm</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@font-face描述将下载的外部字体</p>
<p>@keyframes描述CSS动画的关键帧</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> slidein &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0%</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">100%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@document文档样式表满足给定条件则条件规则组里的样式生效</p>
<p>@charset用于定义样式表使用的字符集，它必须是样式表的第一个元素。如果有多个@charset被声明，只有第一个被使用。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@charset</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>样式表用什么编码，浏览器的识别程序：</p>
<ol>
<li><p>文件开头的 Byte order mark 字符值，不过⼀般编辑器并不能看到文件头里的 BOM 值；</p>
</li>
<li><p>HTTP 响应头里的 content-type 字段包含的 charset 所指定的值，比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content</span>-Type: text/css; charset=utf-<span class="number">8</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>CSS文件头里定义的@charset规则里指定的字符编码</p>
</li>
<li><link>标签的charset属性，已在html5废除
</li>
<li><p>默认是UTF-8</p>
</li>
</ol>
<p>@import告诉CSS引擎引入一个外部样式表</p>
<p>link和@import都能导入样式文件，有什么区别：</p>
<ol>
<li><p>link 是 HTML 标签，除了能导入CSS 外，还能导入别的资源，比如图片、脚本和字体等；而@import 是 CSS 的语法，只能用来导入CSS；</p>
</li>
<li><p>link 导入的样式会在页面加载时同时加载，@import 导入的样式需等页面加载完成后再加载；</p>
</li>
<li><p>link没有兼容问题，@import不兼容ie5以及以下；</p>
</li>
<li><p>link 可以通过 JS 操作 DOM 动态引入样式表改变样式，而@import不可以。</p>
</li>
</ol>
<p>@support用于查询特定的CSS是否生效，可以结合not、and和or操作符决定后续的操作。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@supports</span> (<span class="attribute">display</span>: <span class="attribute">grid</span>) &#123;</span><br><span class="line">  <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@supports</span> <span class="keyword">not</span> (<span class="attribute">display</span>: <span class="attribute">grid</span>) &#123;</span><br><span class="line">  <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h2><p>越往下优先级越高：</p>
<ol>
<li><p>用户代理样式表中的声明（浏览器的默认样式，没有设置其他样式时使用）</p>
</li>
<li><p>作者样式表中的常规声明（开发人员设置的样式）</p>
</li>
<li><p>作者样式表中的!important声明</p>
</li>
</ol>
<p>针对同一个选择器，定义在后面的声明会覆盖前面的；作者定义的样式会比默认继承的样式优先级更高。</p>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h3><p>标签选择器：h1</p>
<p>类选择器：.checked</p>
<p>ID选择器：#picker</p>
<p>通配选择器：*</p>
<h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><p>[attr] ：指定属性的元素；<br>[attr&#x3D;val] ：属性等于指定值的元素；<br>[attr*&#x3D;val] ：属性包含指定值的元素；<br>[attr^&#x3D;val] ：属性以指定值开头的元素；<br>[attr$&#x3D;val] ：属性以指定值结尾的元素；<br>[attr~&#x3D;val] ：属性包含指定值(完整单词)的元素(不推荐使用)；<br>[attr|&#x3D;val] ：属性以指定值(完整单词)开头的元素(不推荐使用)；</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 存在 title 属性的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[title]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: purple;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存在 href 属性并且属性值匹配&quot;https://example.org&quot;的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href=<span class="string">&quot;https://example.org&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存在 href 属性并且属性值包含&quot;example&quot;的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href*=<span class="string">&quot;example&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存在 href 属性并且属性值结尾是&quot;.org&quot;的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=<span class="string">&quot;.org&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">font-style</span>: italic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存在 class 属性并且属性值包含以空格分隔的&quot;logo&quot;的&lt;a&gt;元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[class~=<span class="string">&quot;logo&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h3><p>相邻兄弟选择器： A + B<br>普通兄弟选择器： A ~ B<br>子选择器： A &gt; B<br>后代选择器： A B</p>
<h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><h4 id="条件伪类"><a href="#条件伪类" class="headerlink" title="条件伪类"></a>条件伪类</h4><p>:lang() ：基于元素语言来匹配页面元素；<br>:dir() ：匹配特定文字书写方向的元素；<br>:has() ：匹配包含指定元素的元素；<br>:is() ：匹配指定选择器列表里的元素；<br>:not() ：用来匹配不符合一组选择器的元素；</p>
<h4 id="行为伪类"><a href="#行为伪类" class="headerlink" title="行为伪类"></a>行为伪类</h4><p>:active ：鼠标激活的元素；<br>:hover ： 鼠标悬浮的元素；<br>::selection ：鼠标选中的元素；</p>
<h4 id="状态伪类"><a href="#状态伪类" class="headerlink" title="状态伪类"></a>状态伪类</h4><p>:target ：当前锚点的元素；<br>:link ：未访问的链接元素；<br>:visited ：已访问的链接元素；<br>:focus ：输入聚焦的表单元素；<br>:required ：输入必填的表单元素；<br>:valid ：输入合法的表单元素；<br>:invalid ：输入非法的表单元素；<br>:in-range ：输入范围以内的表单元素；<br>:out-of-range ：输入范围以外的表单元素；<br>:checked ：选项选中的表单元素；<br>:optional ：选项可选的表单元素；<br>:enabled ：事件启用的表单元素；<br>:disabled ：事件禁用的表单元素；<br>:read-only ：只读的表单元素；<br>:read-write ：可读可写的表单元素；<br>:blank ：输入为空的表单元素；<br>:current() ：浏览中的元素；<br>:past() ：已浏览的元素；<br>:future() ：未浏览的元素；</p>
<h4 id="结构伪类"><a href="#结构伪类" class="headerlink" title="结构伪类"></a>结构伪类</h4><p>:root ：文档的根元素；<br>:empty ：无子元素的元素；<br>:first-letter ：元素的首字母；<br>:first-line ：元素的首行；<br>:nth-child(n) ：元素中指定顺序索引的元素；<br>:nth-last-child(n) ：元素中指定逆序索引的元素；；<br>:first-child ：元素中为首的元素；<br>:last-child ：元素中为尾的元素；<br>:only-child ：父元素仅有该元素的元素；<br>:nth-of-type(n) ：标签中指定顺序索引的标签；<br>:nth-last-of-type(n) ：标签中指定逆序索引的标签；<br>:first-of-type ：标签中为首的标签；<br>:last-of-type ：标签中为尾标签；<br>:only-of-type ：父元素仅有该标签的标签；</p>
<h4 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h4><p>::before ：在元素前插入内容；<br>::after ：在元素后插入内容；</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208241427844.png"></p>
<p>权重分成如下几个等级，数值越大权重越高：</p>
<p>10000：!important；<br>01000：内联样式；<br>00100：ID 选择器；<br>00010：类选择器、伪类选择器、属性选择器；<br>00001：元素选择器、伪元素选择器；<br>00000：通配选择器、后代选择器、兄弟选择器；</p>
<h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2><p>在 CSS 中有一个很重要的特性就是子元素会继承父元素对应属性计算后的值。比如页面根元素html 的文本颜色默认是黑色的，页面中的所有其他元素都将继承这个颜色，当申明了如下样式后，H1 文本将变成橙色。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: inherit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208241502314.png"></p>
<p>存在默认继承的是那些不会影响到页面布局的属性，如下：</p>
<p>字体相关： font-family 、font-style 、font-size 、font-weight 等；<br>文本相关： text-align 、text-indent 、text-decoration 、text-shadow 、letterspacing、word-spacing 、white-space 、line-height 、color 等；<br>列表相关： list-style 、list-style-image 、list-style-type 、list-styleposition等；<br>其他属性： visibility 、cursor 等；</p>
<p>对于其他默认不继承的属性也可以通过以下几个属性值来控制继承行为：</p>
<p>inherit ：继承父元素对应属性的计算值；<br>initial ：应用该属性的默认值，比如 color 的默认值是 #000 ；<br>unset ：如果属性是默认可以继承的，则取 inherit 的效果，否则同 initial ；<br>revert ：效果等同于 unset ，兼容性差。</p>
<h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><p>在 CSS 的世界中，会把内容按照从左到右、从上到下的顺序进行排列显示。正常情况下会把页面分割成一行一行的显示，而每行又可能由多列组成，所以从视觉上看起来就是从上到下从左到右，而这就是 CSS 中的流式布局，又叫文档流。文档流就像水⼀样，能够自适应所在的容器，一般它有如下几个特性：</p>
<ul>
<li><p>块级元素默认会占满整行，所以多个块级盒子之间是从上到下排列的；</p>
</li>
<li><p>内联元素默认会在一行里一列一列的排布，当一行放不下的时候，会自动切换到下一行继续按照列排布；</p>
</li>
</ul>
<h3 id="如何脱离文档流"><a href="#如何脱离文档流" class="headerlink" title="如何脱离文档流"></a>如何脱离文档流</h3><p>脱流文档流指节点脱流正常文档流后，在正常文档流中的其他节点将忽略该节点并填补其原先空间。文档⼀旦脱流，计算其父节点高度时不会将其高度纳入，脱流节点不占据空间。有两种方式可以让元素脱离文档流：浮动和定位。</p>
<ul>
<li><p>使用浮动（float）会将元素脱离文档流，移动到容器左&#x2F;右侧边界或者是另一个浮动元素旁边，该浮动元素之前占用的空间将被别的元素填补，另外浮动之后所占用的区域不会和别的元素之间发生重叠；</p>
</li>
<li><p>使用绝对定位（ position: absolute; ）或者固定定位（ position: fixed; ）也会使得元素脱离文档流，且空出来的位置将自动被后续节点填补。</p>
</li>
</ul>
<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>在 CSS 中任何元素都可以看成是⼀个盒子，而⼀个盒子是由 4 部分组成的：内容（content）、内边距（padding）、边框（border）和外边距（margin）。</p>
<p>盒模型有两种：标准盒模型和IE盒模型。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标准盒模型认为：盒子的实际尺寸 &#x3D; 内容（设置的宽&#x2F;高） + 内边距 + 边框</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208241556514.png"></p>
<p>所以 .box 元素内容的宽度就为 200px ，而实际的宽度则是 width + padding-left + padding-right + border-left-width + border-right-width &#x3D; 200 + 10 + 10 + 1 + 1 &#x3D; 222。</p>
<p>IE 盒模型认为：盒子的实际尺寸 &#x3D; 设置的宽&#x2F;高 &#x3D; 内容 + 内边距 + 边框</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208241602987.png"></p>
<p>.box 元素所占用的实际宽度为 200px ，而内容的真实宽度则是 width - padding-left -padding-right - border-left-width - border-right-width &#x3D; 200 - 10 - 10 - 1 - 1 &#x3D; 178。</p>
<p>高版本的浏览器默认使用标准盒模型。</p>
<p>CSS3中新增了一个属性box-sizing，指定盒子使用什么标准：</p>
<p>content-box ：标准盒模型；<br>border-box ：IE 盒模型。</p>
<h2 id="视觉格式化模型"><a href="#视觉格式化模型" class="headerlink" title="视觉格式化模型"></a>视觉格式化模型</h2><p>视觉格式化模型（Visual formatting model）是用来处理和在视觉媒体上显示文档时使用的计算规则。CSS 中一切皆盒子，而视觉格式化模型简单来理解就是规定这些盒子应该怎么样放置到页面中去，这个模型在计算的时候会依赖到很多的因素，比如：盒子尺寸、盒子类型、定位方案（是浮动还是定位）、兄弟元素或者子元素以及一些别的因素。</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208241619159.png"></p>
<p>盒子类型由 display 决定，同时给⼀个元素设置 display 后，将会决定这个盒子的 2 个显示类型（display type）：<br>outer display type（对外显示）：决定了该元素本身是如何布局的，即参与何种格式化上下文；<br>inner display type（对内显示）：其实就相当于把该元素当成了容器，规定了其内部子元素是如何布局的，参与何种格式化上下文；</p>
<h3 id="outer-display-type"><a href="#outer-display-type" class="headerlink" title="outer display type"></a>outer display type</h3><p>对外显示方面，盒子类型可以分成 2 类：block-level box（块级盒子） 和 inline-level box（行内级盒子）。<br>依据上图可以列出都有哪些块级和行内级盒子：<br>块级盒子：display 为 block、list-item、table、flex、grid、flow-root 等；<br>行内级盒子：display 为 inline、inline-block、inline-table 等；</p>
<p>所有块级盒子都会参与 BFC，呈现垂直排列；而所有行内级盒子都参会 IFC，呈现水平排列。</p>
<h4 id="block"><a href="#block" class="headerlink" title="block"></a>block</h4><p>占满一行，默认继承父元素的宽度；多个块元素将从上到下进行排列；<br>设置 width&#x2F;height 将会生效；<br>设置 padding 和 margin 将会生效；</p>
<h4 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h4><p>不会占满一行，宽度随着内容而变化；多个 inline 元素将按照从左到右的顺序在一行里排列显示，如果一行显示不下，则自动换行；<br>设置 width&#x2F;height 将不会生效；<br>设置竖直方向上的 padding 和 margin 将不会生效；</p>
<h4 id="inline-block"><a href="#inline-block" class="headerlink" title="inline-block"></a>inline-block</h4><p>是行内块元素，不单独占满一行，可以看成是能够在一行里进行左右排列的块元素；<br>设置 width&#x2F;height 将会生效；<br>设置 padding 和 margin 将会生效；</p>
<h3 id="inner-display-type"><a href="#inner-display-type" class="headerlink" title="inner display type"></a>inner display type</h3><p>对内方面，其实就是把元素当成了容器，里面包裹着文本或者其他子元素。container box 的类型依据 display 的值不同，分为 4 种：</p>
<p>block container：建立BFC 或者 IFC；<br>flex container：建立FFC；<br>grid container：建立GFC;<br>ruby container：接触不多，不做介绍。</p>
<p>值得⼀提的是如果把 img 这种替换元素（replaced element）申明为 block 是不会产生container box 的，因为替换元素比如 img 设计的初衷就仅仅是通过 src 把内容替换成图片，完全没考虑过会把它当成容器。</p>
<h2 id="格式化上下文"><a href="#格式化上下文" class="headerlink" title="格式化上下文"></a>格式化上下文</h2><p>格式化上下文（Formatting Context）说的是页面中一块渲染区域，规定了渲染区域内部的子元素是如何排版以及相互作用的。</p>
<p>不同的盒子有不同的格式化上下文，大概有四类：</p>
<p>BFC (Block Formatting Context) 块级格式化上下文；<br>IFC (Inline Formatting Context) 行内格式化上下文；<br>FFC (Flex Formatting Context) 弹性格式化上下文；<br>GFC (Grid Formatting Context) 格栅格式化上下文；</p>
<p>BFC和IFC扮演着非常重要的角色，因为它们直接影响了网页布局。</p>
<h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p>块格式化上下文，是一个独立的渲染区域，只有块级盒子参与，规定了内部的块级盒子如何布局，并且与这个区域外部毫不相干。</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208241656703.png"></p>
<h4 id="BFC渲染规则"><a href="#BFC渲染规则" class="headerlink" title="BFC渲染规则"></a>BFC渲染规则</h4><p>内部的盒子会在垂直方向，一个接一个地放置；<br>盒子垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠；<br>每个元素的 margin 的左边，与包含块 border 的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此；<br>BFC 的区域不会与 float 盒子重叠；<br>BFC 就是页面上的⼀个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。<br>计算 BFC 的高度时，浮动元素也参与计算。</p>
<h4 id="如何创建BFC"><a href="#如何创建BFC" class="headerlink" title="如何创建BFC"></a>如何创建BFC</h4><p>根元素：html<br>非溢出的可见元素：overflow 不为 visible<br>设置浮动：float 属性不为 none<br>设置定位：position 为 absolute 或 fixed<br>定义成块级的非块级元素：display: inline-block&#x2F;table-cell&#x2F;table-caption&#x2F;flex&#x2F;inlineflex&#x2F;grid&#x2F;inline-grid</p>
<h4 id="BFC应用场景"><a href="#BFC应用场景" class="headerlink" title="BFC应用场景"></a>BFC应用场景</h4><ol>
<li><p>自适应两栏布局</p>
<p>应用原理：BFC 的区域不会和浮动区域重叠，所以就可以把侧边栏固定宽度且左浮动，而对右侧内容触发 BFC，使得它的宽度自适应该行剩余宽度。<br><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208241733580.png"></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layout&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;aside&quot;</span>&gt;</span>aside<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span>main<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.aside</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  &lt;!-- 触发 BFC --&gt;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>清除内部浮动</p>
<p>浮动造成的问题就是父元素高度坍塌，所以清除浮动需要解决的问题就是让父元素的高度恢复正常。而用BFC 清除浮动的原理就是：计算 BFC 的高度时，浮动元素也参与计算。只要触发父元素的 BFC 即可。</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208241741417.png"></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>防止垂直margin合并</p>
<p>BFC 渲染原理之一：同一个 BFC 下的垂直 margin 会发生合并。所以如果让 2 个元素不在同一个BFC 中即可阻质止垂直 margin 合并。那如何让 2 个相邻的兄弟元素不在同⼀个 BFC 中呢？可以给其中一个元素外面包裹一层，然后触发其包裹层的 BFC，这样一来 2 个元素就不会在同一个 BFC中了。</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208241747015.png"></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layout&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;contain-b&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo3</span> <span class="selector-class">.a</span>,</span><br><span class="line"><span class="selector-class">.demo3</span> <span class="selector-class">.b</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.contain-b</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h3><p>IFC 的形成条件非常简单，块级元素中仅包含内联级别元素，需要注意的是当IFC中有块级元素插入时，会产生两个匿名块将父元素分割开来，产生两个 IFC。</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208241753583.png"></p>
<h4 id="IFC渲染规则"><a href="#IFC渲染规则" class="headerlink" title="IFC渲染规则"></a>IFC渲染规则</h4><p>子元素在水平方向上一个接一个排列，在垂直方向上将以容器顶部开始向下排列；<br>节点无法声明宽高，其中 margin 和 padding 在水平方向有效在垂直方向无效；<br>节点在垂直方向上以不同形式对齐；<br>能把在一行上的框都完全包含进去的⼀个矩形区域，被称为该行的线盒（line box）。线盒的宽度是由包含块（containing box）和与其中的浮动来决定；<br>IFC 中的 line box ⼀般左右边贴紧其包含块，但 float 元素会优先排列。<br>IFC 中的 line box 高度由 line-height 计算规则来确定，同个 IFC 下的多个 line box 高度可能会不同；<br>当内联级盒子的总宽度少于包含它们的 line box 时，其水平渲染规则由 text-align 属性值来决定；<br>当一个内联盒子超过父元素的宽度时，它会被分割成多盒子，这些盒子分布在多个 line box中。如果子元素未设置强制换行的情况下，inline box 将不可被分割，将会溢出父元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>It can get <span class="tag">&lt;<span class="name">strong</span>&gt;</span>very complicated<span class="tag">&lt;/<span class="name">storng</span>&gt;</span> once you start looking into it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208241800771.png"></p>
<p>p 标签是一个 block container，对内将产生一个 IFC；<br>由于一行没办法显示完全，所以产生了 2 个线盒（line box）；线盒的宽度就继承了 p 的宽度；高度是由里面的内联盒子的 line-height 决定；<br>It can get：匿名的内联盒子；<br>very complicated：strong 标签产生的内联盒子；<br>once you start：匿名的内联盒子；<br>looking into it.：匿名的内联盒子。</p>
<h4 id="IFC应用场景"><a href="#IFC应用场景" class="headerlink" title="IFC应用场景"></a>IFC应用场景</h4><p>水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生IFC，通过 text-align 则可以使其水平居中。<br>垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align: middle，其他行内元素则可以在此父元素下垂直居中。</p>
<h2 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h2><p>屏幕上水平是X轴，垂直是Y轴，屏幕到眼睛的方向是Z轴。元素根据属性的优先级在Z轴上排开。</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208241918067.png"></p>
<p>z-index 能够在层叠上下文中对元素的堆叠顺序其作用是必须配合定位才可以；<br>除了 z-index 之外，一个元素在 Z 轴上的显示顺序还受层叠等级和层叠顺序影响；</p>
<p>特定的 HTML 元素或者CSS 属性产生层叠上下文，符合以下任一条件的元素都会产生层<br>叠上下文：</p>
<p>html ⽂档根元素<br>声明 position: absolute&#x2F;relative 且 z-index 值不为 auto 的元素；<br>声明 position: fixed&#x2F;sticky 的元素；<br>flex 容器的子元素，且 z-index 值不为 auto；<br>grid 容器的子元素，且 z-index 值不为 auto；<br>opacity 属性值⼩于 1 的元素；<br>mix-blend-mode 属性值不为 normal 的元素；<br>以下任意属性值不为 none 的元素：<br>transform<br>filter<br>perspective<br>clip-path<br>mask &#x2F; mask-image &#x2F; mask-border<br>isolation 属性值为 isolate 的元素；<br>-webkit-overflow-scrolling 属性值为 touch 的元素；<br>will-change 值设定了任⼀属性而该属性在 non-initial 值时会创建层叠上下文的元素；<br>contain 属性值为 layout、paint 或包含它们其中之⼀的合成值（比如 contain: strict、<br>contain: content）的元素。</p>
<h3 id="层叠等级"><a href="#层叠等级" class="headerlink" title="层叠等级"></a>层叠等级</h3><p>层叠等级指节点在三维空间Z轴上的上下顺序。</p>
<p>在同⼀个层叠上下文中，它描述定义的是该层叠上下文中的层叠上下文元素在 Z 轴上的上下顺序；<br>在其他普通元素中，它描述定义的是这些普通元素在 Z 轴上的上下顺序；</p>
<p>普通元素的层叠等级由其所在的层叠上下文决定，层叠等级的比较只有在当前层叠上下文中才有意义，脱离当前层叠上下文的比较就无意义了。</p>
<h3 id="层叠顺序"><a href="#层叠顺序" class="headerlink" title="层叠顺序"></a>层叠顺序</h3><p>同一个层叠上下文如果有多个元素，它们之前的层叠顺序。</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208241929012.png"></p>
<p>层叠等级由低到高：</p>
<p>层叠上下文的 border 和 background<br>z-index &lt; 0 的子节点<br>标准流内块级非定位的子节点<br>浮动非定位的子节点<br>标准流内行内非定位的子节点<br>z-index: auto&#x2F;0 的子节点<br>z-index &gt; 0的子节点</p>
<h3 id="如何比较两个元素的层叠等级？"><a href="#如何比较两个元素的层叠等级？" class="headerlink" title="如何比较两个元素的层叠等级？"></a>如何比较两个元素的层叠等级？</h3><p>在同一个层叠上下文中，比较两个元素就是按照上图的介绍的层叠顺序进行比较。<br>如果不在同一个层叠上下文中的时候，那就需要比较两个元素分别所处的层叠上下文的等级。<br>如果两个元素都在同⼀个层叠上下文，且层叠顺序相同，则在 HTML 中定义越后面的层叠等级越高。</p>
<h2 id="值和单位"><a href="#值和单位" class="headerlink" title="值和单位"></a>值和单位</h2><p>数值：长度值 ，用于指定例如元素 width、border-width、font-size 等属性的值；<br>百分比：可以用于指定尺寸或长度，例如取决于父容器的 width、height 或默认的fontsize；<br>颜色：用于指定 background-color、color 等；<br>坐标位置：以屏幕的左上角为坐标原点定位元素的位置，比如常见的 background-position、top、right、bottom 和 left 等属性；<br>函数：用于指定资源路径或背景图片的渐变，比如 url()、linear-gradient() 等；</p>
<p>还有些值是需要带单位的，比如 width: 100px，这里的 px 就是表示长度的单位，长度单位除了px 外，比较常用的还有 em、rem、vw&#x2F;vh 等。</p>
<h3 id="px"><a href="#px" class="headerlink" title="px"></a>px</h3><p>屏幕分辨率是指在屏幕的横纵方向上的像素点数量，比如分辨率 1920×1080 意味着水平方向含有1920 个像素数，垂直方向含有 1080 个像素数。</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208251040736.png"></p>
<p>屏幕尺寸一致的情况下，屏幕分辨率越高，显示效果就越细腻。</p>
<h3 id="em"><a href="#em" class="headerlink" title="em"></a>em</h3><p>em 是 CSS 中的相对长度单位中的一个。</p>
<p>在 font-size 中使用是相对于父元素的 font-size 大小，比如父元素 font-size: 16px，当给子元素指定 font-size: 2em 的时候，经过计算后它的字体大小会是 32px；<br>在其他属性中使用是相对于自身的字体大小，如 width&#x2F;height&#x2F;padding&#x2F;margin 等；</p>
<p>每个浏览器都会给 HTML 根元素 html 设置一个默认的 font-size，而这个值通常是16px。这也就是为什么 1em &#x3D; 16px 的原因所在了。</p>
<h3 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h3><p>rem(root em) 和 em一样，也是一个相对长度单位，不过 rem 相对的是 HTML 的根元素html。</p>
<p>rem 由于是基于 html 的 font-size 来计算，所以通常用于自适应网站或者 H5 中。</p>
<h3 id="vw-x2F-vh"><a href="#vw-x2F-vh" class="headerlink" title="vw&#x2F;vh"></a>vw&#x2F;vh</h3><p>vw 和 vh 分别是相对于屏幕视口宽度和高度而言的长度单位：</p>
<ul>
<li><p>1vw &#x3D; 视口宽度均分成 100 份中 1 份的长度；</p>
</li>
<li><p>1vh &#x3D; 视口高度均分成 100 份中 1 份的长度；</p>
</li>
</ul>
<p>相对视口的单位，除了 vw&#x2F;vh 外，还有 vmin 和 vmax：</p>
<ul>
<li><p>vmin：取 vw 和 vh 中值较小的；</p>
</li>
<li><p>vmax：取 vw 和 vh 中值较大的；</p>
</li>
</ul>
<h2 id="颜色体系"><a href="#颜色体系" class="headerlink" title="颜色体系"></a>颜色体系</h2><p>根据 CSS 颜色草案 中提到的颜色值类型，大概可以把它们分为这几类：</p>
<ul>
<li><p>颜色关键字</p>
</li>
<li><p>transparent 关键字</p>
</li>
<li><p>currentColor 关键字</p>
</li>
<li><p>RGB 颜色</p>
</li>
<li><p>HSL 颜色</p>
</li>
</ul>
<h3 id="颜色关键字"><a href="#颜色关键字" class="headerlink" title="颜色关键字"></a>颜色关键字</h3><p>颜色关键字（color keywords）是不区分大小写的标识符，它表示一个具体的颜色，比如 white（白），黑（black）等；</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208251606458.png"></p>
<h3 id="transparent关键字"><a href="#transparent关键字" class="headerlink" title="transparent关键字"></a>transparent关键字</h3><p>transparent 关键字表示⼀个完全透明的颜色，即该颜色看上去将是背景色。</p>
<p>应用场景：</p>
<h4 id="实现三角形"><a href="#实现三角形" class="headerlink" title="实现三角形"></a>实现三角形</h4><p>等腰三角形：设置⼀条边有颜色，然后紧挨着的 2 边是透明，且宽度是有颜色边的⼀半；直角三角形：设置⼀条边有颜色，然后紧挨着的任何一边透明即可。</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208251618315.png"></p>
<h4 id="增大点击区域"><a href="#增大点击区域" class="headerlink" title="增大点击区域"></a>增大点击区域</h4><p>常常在移动端的时候点击的按钮的区域特别小，但是由于现实效果又不太好把它做大，所以常用的⼀个手段就是通过透明的边框来增大按钮的点击区域</p>
<h3 id="currentColor关键字"><a href="#currentColor关键字" class="headerlink" title="currentColor关键字"></a>currentColor关键字</h3><p>currentColor 会取当前元素继承父级元素的文本颜色值或声明的文本颜色值，即 computed 后的color 值。</p>
<h3 id="RGB-A-颜色"><a href="#RGB-A-颜色" class="headerlink" title="RGB[A]颜色"></a>RGB[A]颜色</h3><p>RGB[A] 颜色是由 R(red)-G(green)-B(blue)-A(alpha) 组成的色彩空间。</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208251643695.png"></p>
<h4 id="十六进制符号"><a href="#十六进制符号" class="headerlink" title="十六进制符号"></a>十六进制符号</h4><p>RGB 中的每种颜色的值范围是 00~ff，值越大表示颜色越深。所以⼀个颜色正常是 6 个十六进制字符加上 # 组成，比如红色就是 #ff0000。</p>
<p>如果 RGB 颜⾊需要加上不透明度，那就需要加上 alpha 通道的值，它的范围也是 00~ff，比如一个带不透明度为 67% 的红色可以这样写 #ff0000aa。</p>
<p>使用十六进制符号表示颜色的时候，都是用 2 个十六进制表示一个颜色，如果这 2 个字符相同，还可以缩减成只写 1 个，比如，红色 #f00；带 67% 不透明度的红色 #f00a。</p>
<h4 id="函数符"><a href="#函数符" class="headerlink" title="函数符"></a>函数符</h4><p>当 RGB 用函数表示的时候，每个值的范围是 0<del>255 或者 0%</del>100%，所以红色是 rgb(255, 0,0)， 或者 rgb(100%, 0, 0)。<br>如果需要使用函数来表示带不透明度的颜色值，值的范围是 0<del>1 及其之间的小数或者0%</del>100%，比如带 67% 不透明度的红色是 rgba(255, 0, 0, 0.67) 或者 rgba(100%, 0%, 0%, 67%)</p>
<p>要么都用数字，要么都用百分比，同时用是不对的，但是透明度不需要保持一致。rgb(100%, 0%, 0%, 0.67)</p>
<p>带 67% 不透明度的红色可以这样写 rgba(255 0 0 &#x2F; 0.67)</p>
<h3 id="HSL-A-颜色"><a href="#HSL-A-颜色" class="headerlink" title="HSL[A]颜色"></a>HSL[A]颜色</h3><p>HSL[A] 颜色是由色相(hue)-饱和度(saturation)-亮度(lightness)-不透明度组成的颜色体系。<br>色相（H）是色彩的基本属性，值范围是 0360 或者 0deg360deg， 0 (或 360) 为红色, 120为绿色, 240 为蓝色；<br>饱和度（S）是指色彩的纯度，越高色彩越纯，低则逐渐变灰，取 0<del>100% 的数值；0% 为灰色， 100% 全色；<br>亮度（L），取 0</del>100%，0% 为暗，100% 为白；<br>不透明度（A），取 0100%，或者01及之间的小数；</p>
<p>在 Chrome DevTools 中可以按住 shift + 鼠标左键可以切换颜色的表示方式。<br><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208251708206.png"></p>
<h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><p>媒体查询是指针对不同的设备、特定的设备特征或者参数进行定制化的修改网站的样式。</p>
<p>给 <link> 加上 media 属性来指定该样式文件只能对什么设备生效，不指定的话默认是 all，即对所有设备都生效：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">src</span>=<span class="string">&quot;styles.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">src</span>=<span class="string">&quot;styles.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;print&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>all：适用于所有设备；<br>print：适用于在打印预览模式下在屏幕上查看的分页材料和文档；<br>screen：主要用于屏幕；<br>speech：主要用于语音合成器。</p>
<p>除了通过 <link> 让指定设备生效外，还可以通过 @media 让 CSS 规则在特定的条件下才能生效。响应式页面就是使用了 @media 才让一个页面能够同时适配 PC、Pad 和手机端。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">1000px</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>媒体查询支持逻辑操作符：<br>and：查询条件都满足的时候才生效；<br>not：查询条件取反；<br>only：整个查询匹配的时候才生效，常用于兼容旧浏览器，使用时候必须指定媒体类型；<br>逗号或者 or：查询条件满足一项即可匹配；</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ⽤户设备的最⼩⾼度为680px或为纵向模式的屏幕设备 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-height</span>: <span class="number">680px</span>), screen <span class="keyword">and</span> (<span class="attribute">orientation</span>: portrait) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常见需求"><a href="#常见需求" class="headerlink" title="常见需求"></a>常见需求</h2><h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p>现在 CSS 里也支持了变量的用法。通过自定义属性就可以在想要使用的地方引用它。</p>
<p>自定义属性也和普通属性一样具有级联性，申明在 :root 下的时候，在全文档范围内可用，而如果是在某个元素下申明自定义属性，则只能在它及它的子元素下才可以使用。</p>
<p>自定义属性必须通过 –x 的格式申明，比如：–theme-color: red; 使用自定义属性的时候，需要用 var 函数。比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 定义⾃定义属性 --&gt;</span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attr">--theme-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 使⽤变量 --&gt;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--theme-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261005400.png"></p>
<h3 id="1px边框实现方案"><a href="#1px边框实现方案" class="headerlink" title="1px边框实现方案"></a>1px边框实现方案</h3><p>Retina 显示屏比普通的屏幕有着更高的分辨率，所以在移动端的 1px 边框就会看起比较粗，为了美观通常需要把这个线条细化处理。</p>
<p>只设置单条底部边框：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.scale-1px-bottom</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">border</span>:none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.scale-1px-bottom</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">  -webkit-<span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时设置 4 条边框：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.scale-1px</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border</span>:none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.scale-1px</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">  -webkit-<span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200%</span>;</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">  -webkit-<span class="attribute">transform-origin</span>: left top;</span><br><span class="line">  <span class="attribute">transform-origin</span>: left top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>浮动：浮动元素会脱离文档流并向左&#x2F;向右浮动，直到碰到父元素或者另⼀个浮动元素。</p>
<p>为什么要清除浮动：</p>
<p>因为浮动元素会脱离正常的文档流，并不会占据文档流的位置，所以如果⼀个父元素下面都是浮动元素，那么这个父元素就无法被浮动元素所撑开，这样⼀来父元素就丢失了高度，这就是所谓的浮动造成的父元素高度坍塌问题。</p>
<p>父元素高度一旦坍塌将对后面的元素布局造成影响。</p>
<p>两种方法：通过 BFC 来清除、通过 clear 来清除。</p>
<h4 id="BFC清除浮动"><a href="#BFC清除浮动" class="headerlink" title="BFC清除浮动"></a>BFC清除浮动</h4><p>前面介绍 BFC 的时候提到过，计算 BFC 高度的时候浮动子元素的高度也将计算在内，利用这条规则就可以清除浮动。</p>
<p>假设⼀个父元素 parent 内部只有 2 个子元素 child，且它们都是左浮动的，这个时候 parent 如果没有设置高度的话，因为浮动造成了高度坍塌，所以 parent 的高度会是 0，此时只要给 parent创造⼀个 BFC，那它的高度就能恢复了。</p>
<p>而产生BFC 的方式很多，我们可以给父元素设置overflow: auto 来简单的实现 BFC 清除浮动，但是为了兼容 IE 最好用overflow: hidden。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 overflow: hidden 来清除浮动并不完美，当元素有阴影或存在下拉菜单的时候会被截断，所以该方法使用比较局限。</p>
<h4 id="通过clear清除浮动"><a href="#通过clear清除浮动" class="headerlink" title="通过clear清除浮动"></a>通过clear清除浮动</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法的核心原理就是通过 ::after 伪元素为在父元素的最后一子元素后面生成一个内容为空的块级元素，然后通过 clear 将这个伪元素移动到所有它之前的浮动元素的后面，画个图来理解一下。</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261148888.png"></p>
<p>上面这个 demo 或者图里为了展示需要所以给伪元素的内容设置为了 ::after，实际使用的时候需要设置为空字符串，让它的高度为 0，从而父元素的高度都是由实际的子元素撑开。</p>
<h3 id="消除浏览器默认样式"><a href="#消除浏览器默认样式" class="headerlink" title="消除浏览器默认样式"></a>消除浏览器默认样式</h3><p>针对同⼀个类型的 HTML 标签，不同的浏览器往往有不同的表现，所以在网站制作的时候，开发者通常都是需要将这些浏览器的默认样式清除，让网页在不同的浏览器上能够保持一致。</p>
<p>reset.css，Normalize.css</p>
<h3 id="长文本处理"><a href="#长文本处理" class="headerlink" title="长文本处理"></a>长文本处理</h3><p>默认：字符太长溢出了容器</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261354729.png"></p>
<p>字符超出部分换行</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261356855.png"></p>
<p>字符超出位置使用连字符</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261357583.png"></p>
<p>单行文本超出省略</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261359730.png"></p>
<p>多行文本超出省略</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261401970.png"></p>
<h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><p>让元素在父元素中呈现水平垂直居中的几种情况：</p>
<p>单行的文本、inline 或者 inline-block 元素；<br>固定宽高的块级盒子；<br>不固定宽高的块级盒子；</p>
<h4 id="单行的文本、inline或inline-block元素"><a href="#单行的文本、inline或inline-block元素" class="headerlink" title="单行的文本、inline或inline-block元素"></a>单行的文本、inline或inline-block元素</h4><h5 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h5><p>此类元素需要水平居中，则父级元素必须是块级元素( block level )，且父级元素上需要这样设置样式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h5><p>方法一：通过设置上下内间距一致达到垂直居中的效果：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.single-line</span> &#123;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：通过设置 height 和 line-height 一致达到垂直居中：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.single-line</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="固定宽高的块级盒子"><a href="#固定宽高的块级盒子" class="headerlink" title="固定宽高的块级盒子"></a>固定宽高的块级盒子</h4><p>方法一：absolute + 负 margin</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261424466.png"></p>
<p>方法二：absolute + margin auto</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261426220.png"></p>
<p>方法三：absolute + calc</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261428683.png"></p>
<h4 id="不固定宽高的块级盒子"><a href="#不固定宽高的块级盒子" class="headerlink" title="不固定宽高的块级盒子"></a>不固定宽高的块级盒子</h4><p>方法一：absolute + transform</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261436430.png"></p>
<p>方法二：line-height + vertical-align</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261440863.png"></p>
<p>方法三：writing-mode<br><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261444964.png"></p>
<p>方法四：table-cell</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261447215.png"></p>
<p>方法五：flex</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261449587.png"></p>
<p>方法六：grid</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261453733.png"></p>
<h3 id="常用布局"><a href="#常用布局" class="headerlink" title="常用布局"></a>常用布局</h3><h4 id="两栏布局（边栏定宽主栏自适应）"><a href="#两栏布局（边栏定宽主栏自适应）" class="headerlink" title="两栏布局（边栏定宽主栏自适应）"></a>两栏布局（边栏定宽主栏自适应）</h4><p>方法一：float + overflow（BFC 原理）</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261500954.png"></p>
<p>方法二：float + margin</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261502161.png"></p>
<p>方法三：flex</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261504967.png"></p>
<p>方法四：grid</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261506790.png"></p>
<h4 id="三栏布局（两侧栏定宽主栏自适应）"><a href="#三栏布局（两侧栏定宽主栏自适应）" class="headerlink" title="三栏布局（两侧栏定宽主栏自适应）"></a>三栏布局（两侧栏定宽主栏自适应）</h4><p>方法一：圣杯布局</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261524833.png"></p>
<p>方法二：双飞翼布局</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261531438.png"></p>
<p>方法三：float + overflow（BFC 原理）</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261533265.png"></p>
<p>方法四：flex</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261537791.png"></p>
<p>方法五：grid</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261539396.png"></p>
<h4 id="多列等高布局"><a href="#多列等高布局" class="headerlink" title="多列等高布局"></a>多列等高布局</h4><p>方法一：padding + 负margin</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261544677.png"></p>
<p>方法二：设置父级背景图片</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261548035.png"></p>
<h4 id="三行布局（头尾定高主栏自适应）"><a href="#三行布局（头尾定高主栏自适应）" class="headerlink" title="三行布局（头尾定高主栏自适应）"></a>三行布局（头尾定高主栏自适应）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layout&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span>,</span><br><span class="line"><span class="selector-class">.layout</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">header</span>,</span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">overflow-y</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法一：calc</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261715404.png"></p>
<p>方法二：absolute</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261716044.png"></p>
<p>方法三：flex</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261719778.png"></p>
<p>方法四：grid</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208261721176.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gjbegjbe.github.io/2022/08/22/%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gjbe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gjbe">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/22/%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/" class="post-title-link" itemprop="url">任务队列与事件循环</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-22 15:48:40" itemprop="dateCreated datePublished" datetime="2022-08-22T15:48:40+08:00">2022-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-23 20:02:56" itemprop="dateModified" datetime="2022-08-23T20:02:56+08:00">2022-08-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每个tab页面都有自己的渲染进程，而每个渲染进程又由多个线程组成，每个渲染进程都有一个主线程，主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要⼀个系统来统筹调度这些任务。这个系统就是今天的主角 – 消息队列和事件循环系统。</p>
<p>JS为什么是单线程的？为什么需要异步？既然 JS 是单线程的，只能在⼀条线程上执⾏，⼜是如何实现的异步呢？</p>
<p>本文Event Loop 只针对浏览器，暂不为 node 展开讨论。</p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>JS是单线程执行的，指的是一个进程里有且只有一个主线程负责执行js代码。</p>
<p>进程是CPU资源分配的最小单位。线程是CPU调度的最小单位。</p>
<h3 id="多线程与多进程"><a href="#多线程与多进程" class="headerlink" title="多线程与多进程"></a>多线程与多进程</h3><p>多进程是指同一个时间里，同一个计算机系统允许两个或者两个以上的进程处于运行状态。比如可以在听歌的同时写代码。</p>
<p>多线程是指程序中包含多个执行流，一个程序中可以同时运行多个不同的线程来执行不同的任务，允许单个程序创建多个并行执行的线程来完成各自的任务。⽐如打开 QQ 的这个进程，可能同时有接收消息线程、传输⽂件线程、检测安全线程…… 所以⼀个⽹⻚能够正常的运⾏并和⽤户交互，也需要很多个进程之间相互配合。</p>
<p>浏览器打开一个Tab页就是创建了一个进程，一个进程可以有多个线程，JS 引擎线程、HTTP 请求线程、事件触发线程、GUI 渲染线程等等。发起请求是就创建了一个线程，请求结束后线程可能被销毁。</p>
<p>由于单线程原因，主线程一次只能执行一个任务，每次任务执行完成会去消息队列取新的任务执行。</p>
<ol>
<li>一个任务执行时间过长，导致主线程长期被霸占，如何优化？&#x3D;&#x3D;&gt; 引入异步编程，实现<br>非阻塞调用</li>
<li>如何处理任务优先级？ &#x3D;&#x3D;&#x3D;》引⼊任务队列，先进先出来管理任务执行顺序</li>
<li>紧急任务无法插队？&#x3D;&#x3D;&#x3D;》引入宏任务、微任务处理不同任务队列的优先级</li>
</ol>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>既然 JS 是单线程的，那么诸如 onclick 回调，setTimeout，Ajax 这些都是怎么实现的呢？是因为浏览器或 node（宿主环境）是多线程的，即浏览器搞了⼏个其他线程去辅助 JS 线程的运⾏。</p>
<p>浏览器有很多线程，例如：</p>
<ol>
<li>GUI 渲染线程</li>
<li>JS 引擎线程</li>
<li>定时器触发线程 (setTimeout)</li>
<li>浏览器事件线程 (onclick)</li>
<li>http 异步线程</li>
<li>EventLoop 轮询处理线程</li>
</ol>
<p>其中，1、2、4 为常驻线程。</p>
<p>分类：<br>类别 A：GUI 渲染线程<br>类别 B：JS 引擎线程<br>类别 C：EventLoop 轮询处理线程<br>类别 D：其他线程，有 定时器触发线程 (setTimeout)、http 异步线程、浏览器事件线程 (onclick)等等。</p>
<h3 id="JS-引擎线程"><a href="#JS-引擎线程" class="headerlink" title="JS 引擎线程"></a>JS 引擎线程</h3><p>JS 引擎线程，我们把它称为主线程，即运⾏ JS 代码的那个线程（不包括异步的那些代码）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>()</span><br><span class="line"><span class="title function_">ajax</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>()</span><br></pre></td></tr></table></figure>

<p>第 1、4 ⾏代码是同步代码，直接在主线程中运⾏；第 2、3 ⾏代码交给其他线程运⾏。<br>主线程运⾏ JS 代码时，会⽣成个执⾏栈，可以处理函数的嵌套。</p>
<h4 id="消息队列（任务队列）"><a href="#消息队列（任务队列）" class="headerlink" title="消息队列（任务队列）"></a>消息队列（任务队列）</h4><p>可以理解为⼀个静态的队列存储结构，⾮线程，只做存储，⾥⾯存的是⼀堆异步成功后的回调函数字符串，肯定是先成功的异步的回调函数在队列的前⾯，后成功的在后⾯。<br>注意：是<strong>异步成功后</strong>，才把其回调函数扔进队列中，⽽不是⼀开始就把所有异步的回调函数扔进队列。<strong>⽐如 setTimeout 3 秒后执⾏⼀个函数，那么这个函数是在 3 秒后才进队列的。</strong></p>
<h3 id="其他线程"><a href="#其他线程" class="headerlink" title="其他线程"></a>其他线程</h3><p>定时器触发线程 (setTimeout)、http 异步线程、浏览器事件线程 (onclick)<br>主线程执⾏ JS 代码时，碰到异步代码，就把它丢给各⾃相对应的线程去执⾏，⽐如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(fun A)</span><br><span class="line"><span class="title function_">ajax</span>(fun B)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>()</span><br><span class="line">dom.<span class="title function_">onclick</span>(func C)</span><br></pre></td></tr></table></figure>

<p>主线程在运⾏这段代码时，碰到 2 setTimeout (fun A)，把这⾏代码交给定时器触发线程去执⾏；碰到 3 ajax (fun B)，把这⾏代码交给 http 异步线程去执⾏；碰到 5 dom.onclick (func C) ，把这⾏代码交给浏览器事件线程去执⾏。<br>注意： 这⼏个异步代码的回调函数 fun A，fun B，fun C，各⾃的线程都会保存着的，因为需要在未来的某个时候，将回调函数交给主线程去执⾏。</p>
<p>作用：</p>
<ol>
<li>执⾏主线程扔过来的异步代码，并执⾏代码</li>
<li>保存回调函数，在未来的某个时刻，通知 EventLoop 轮询处理线程过来取相应的回调函数然后执⾏（下⾯会讲）</li>
</ol>
<p>区别：</p>
<ul>
<li><p>对于 setTimeout 代码，定时器触发线程在接收到代码时就开始计时，时间到了将回调函数扔进队列。</p>
</li>
<li><p>对于 ajax 代码，http 异步线程⽴即发起 http 请求，请求成功后将回调函数扔进队列。</p>
</li>
<li><p>对于 dom.onclick，浏览器事件线程会先监听 dom，直到 dom 被点击了，才将回调函数扔进队列。</p>
</li>
</ul>
<h3 id="EventLoop-轮询处理线程"><a href="#EventLoop-轮询处理线程" class="headerlink" title="EventLoop 轮询处理线程"></a>EventLoop 轮询处理线程</h3><ol>
<li>主线程，处理同步代码</li>
<li>类别 D 的⼏个异步线程，处理异步代码</li>
<li>消息队列，存储着异步成功后的回调函数，⼀个静态存储结构</li>
</ol>
<p>消息队列作⽤就是存放着未来要执⾏的回调函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<p>在⼀开始，消息队列是空的，在 2 秒后，⼀个 () &#x3D;&gt; { console.log (1) } 的函数进⼊队列，在 3 秒后，⼀个 () &#x3D;&gt; { console.log (2) } 的函数进⼊队列，此时队列⾥有两个元素，主线程从队列头中挨个取出并执⾏。</p>
<p>这需要⼀个中介去专⻔去沟通它们 3 个，⽽这个中介，就是 EventLoop 轮询处理线程</p>
<h2 id="Event-Loop（事件循环）"><a href="#Event-Loop（事件循环）" class="headerlink" title="Event Loop（事件循环）"></a>Event Loop（事件循环）</h2><p>JS是一种单线程语言，一次只能完成一个任务。如果有多个任务，就必须排队，前面一个任务完成再完成下面的任务。如果前面的任务过长，后面的就会一直等待，拖延整个程序。为了解决这个问题，引入Event Loop，将任务分为同步任务和异步任务，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会交给相应的WebAPIs 线程处理，在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231638678.png"></p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231742076.png"></p>
<p>事件循环可以理解为由三部分组成：</p>
<ol>
<li>主线程执行栈</li>
<li>异步任务等待触发：浏览器为异步任务单独开辟的几个辅佐线程 (事件触发线程、Http异步请求线程、GUI 渲染线程) 可以统⼀理解为 WebAPIs</li>
<li>异步任务队列：以队列的数据结构对事件任务进行管理，特点是先进先出，后进后出。</li>
</ol>
<p>模型特点：</p>
<ol>
<li>所有同步任务都会在主线程上执行，同时会形成一个执行栈（execution context<br>stack），直至栈空，即任务结束。</li>
<li>主线程之外，还存在一个任务队列（task queue）。只要异步任务有了运行结果，就在<br>任务队列之中放置⼀个事件。</li>
<li>一旦执行栈上的任务执行完毕，系统就会从任务队列读取新的任务，结束等待状态，进入执行栈，开始执行，循环往复。</li>
</ol>
<p>从C语言角度理解：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TaskQueue task_queue；</span><br><span class="line"><span class="type">void</span> <span class="title function_">ProcessTask</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ProcessDelayTask</span><span class="params">()</span>;</span><br><span class="line"><span class="type">bool</span> keep_running = <span class="literal">true</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MainThread</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (task_queue.waitForTask()) &#123;</span><br><span class="line">    Task task = task_queue.takeTask();<span class="comment">// 取出消息队列中任务</span></span><br><span class="line">    ProcessTask(task);<span class="comment">// 执⾏任务</span></span><br><span class="line">    ProcessDelayTask()<span class="comment">// 执⾏延迟队列中的任务</span></span><br><span class="line">    <span class="keyword">if</span>(!keep_running) <span class="comment">//如果设置了退出标志，那么直接退出线程循环</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h3><p>A callback is a function that is passed as an argument to another function and is executed after its parent function has completed.<br>回调是作为参数传递给另一个函数并在其父函数完成后执行的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步请求的回调函数</span></span><br><span class="line">$.<span class="title function_">get</span>(<span class="string">&#x27;api/find&#x27;</span>,<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 点击事件的回调函数</span></span><br><span class="line">$(<span class="string">&#x27;.btn&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;this is a callback of click event&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 数组中遍历每⼀项调⽤的回调函数</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 同步回调</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getNodes</span>(<span class="params">params,callback</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> list = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(params)</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line"><span class="title function_">callback</span>(list)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getNodes</span>(<span class="string">&#x27;[1,2,3]&#x27;</span>,<span class="keyword">function</span>(<span class="params">list</span>)&#123;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>既可以有同步回调，也可以有异步回调，还可以有事件处理回调和延迟函数回调。</p>
<h3 id="同步vs异步"><a href="#同步vs异步" class="headerlink" title="同步vs异步"></a>同步vs异步</h3><p>同步就是后⼀个任务等待前⼀个任务结束，然后再执⾏，程序的执⾏顺序与任务的排列顺序是⼀致的、同步的。</p>
<p>异步则完全不同，从程序⻆度来理解就是改变程序正常执⾏顺序的操作，每⼀个任务有⼀个或多个回调函数（callback），前⼀个任务结束后，不是执⾏后⼀个任务，⽽是执⾏回调函数，后⼀个任务则是不等前⼀个任务结束就执⾏，所以程序的执⾏顺序与任务的排列顺序是不⼀致的、异步的。</p>
<p>JS作为一种单线程的语言如何实现异步的？</p>
<p>JS 异步的实现靠的就是浏览器的多线程，当他遇到异步 API 时，就将这个任务交给对应的线程，当这个异步 API 满⾜回调条件时，对应的线程⼜通过事件触发线程将这个事件放⼊任务队列，然后主线程执⾏完主线任务后从任务队列取出任务事件继续执⾏。</p>
<p><strong>总结：</strong></p>
<p>同步 &#x2F; 异步指的是各个任务之间执⾏顺序的确定性。同时， 任务≠回调函数 , 不管是同步任务，异步任务都可以通过回调函数去实现。</p>
<h4 id="从同步异步角度理解JS的执行机制"><a href="#从同步异步角度理解JS的执行机制" class="headerlink" title="从同步异步角度理解JS的执行机制"></a>从同步异步角度理解JS的执行机制</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="comment">// 200ms后，新任务task_1进⼊ 任务队列</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;,<span class="number">200</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果是132，思路（暂不考虑宏任务微任务）：</p>
<ol>
<li>整体 script 作为第⼀个任务进⼊主线程，console 输出 1;</li>
<li>遇到异步 API setTimeout ，将异步回调函数交给 Web API 处理 (此处为定时器触发线程，200ms 之后，即满⾜触发条件后，将 task_1 推⼊任务队列 task queue )。</li>
<li>主线程继续往下执⾏，console 输出3，任务执⾏结束，调⽤栈为空</li>
<li>进⼊下⼀个循环，取出任务队列中的下个任务，此时任务队列为空，主线程进⼊等待状态。</li>
<li>直到 200ms 之后，发现新推⼊任务队列的 task_1 , 开始执⾏，console 输出 2</li>
</ol>
<h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><p>javascript 是⼀⻔单线程的脚本语⾔，也就意味着同⼀个时间只能做⼀件事，但是单线程有⼀个问题：⼀旦这个线程被阻塞就⽆法继续⼯作了，这肯定是不⾏的。上⾯谈的EventLoop 模型通过异步编程实现⾮阻塞的调⽤效果⽅式解决了⼀个任务⻓时间霸占线程问题，但由于队列是⼀种数据结构，可以存放要执⾏的任务。它符合队列先进先出的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取，但这不能解决任务优先级问题 (紧急任务插队的需求)。为解决这个问题引⼊宏任务，微任务概念。</p>
<h4 id="宏任务VS微任务"><a href="#宏任务VS微任务" class="headerlink" title="宏任务VS微任务"></a>宏任务VS微任务</h4><p>ES6 规范中，Microtask 称为 jobs，Macrotask 称为 task。即微任务是 ES 对异步的定义；⽽宏任务是浏览器对异步的定义。</p>
<p>宏任务与微任务都是独⽴于主执⾏栈之外的另外两个队列。<br>为了处理任务的优先级，权衡效率和实时性。浏览器端事件循环中的异步队列有两种：Macrotask（宏任务）队列和 Microtask（微任务）队列.</p>
<table>
<thead>
<tr>
<th></th>
<th>宏任务 (Macrotask)</th>
<th>微任务 (Microtask)</th>
</tr>
</thead>
<tbody><tr>
<td>谁发起</td>
<td>浏览器、Node</td>
<td>Javascript</td>
</tr>
<tr>
<td>具体事件</td>
<td>script（全局任务）, setTimeout, setInterval, setImmediate, I&#x2F;O, UI rendering</td>
<td>process.nextTick, Promise 的 then 或 catch, Object.observer, MutationObserver</td>
</tr>
</tbody></table>
<p>在事件循环这个机制当中，我们将进⾏⼀次循环操作称为 tick ，每⼀次 tick 的任务处理模型是⽐较复杂的，但关键步骤如下：</p>
<ol>
<li>进⼊循环，⾸先选择最先进⼊宏任务队列的任务 (oldest task)，如果有则执⾏ (⼀次)</li>
<li>检查是否存在 Microtasks，如果存在则不停地执⾏，直⾄清空微任务 (Microtasks Queue)，此时执⾏栈也为清空了。</li>
<li>GUI 线程更新 (render) 界⾯（与主线程互斥）</li>
<li>进⼊下⼀个 Tick 主线程重复执⾏上述步骤</li>
</ol>
<p>注意：new Promise 执⾏本身时是属于同步代码，只有.then 才是微任务</p>
<h3 id="Event-Loop-的模型-Macrotask-Microtask"><a href="#Event-Loop-的模型-Macrotask-Microtask" class="headerlink" title="Event Loop 的模型 (Macrotask + Microtask)"></a>Event Loop 的模型 (Macrotask + Microtask)</h3><p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208230953801.png"></p>
<p>这个 Event Loop 模型运⾏机制如下：</p>
<ol>
<li>选择当前要执⾏的宏任务队列，选择任务队列中最先进⼊的任务 ( oldest task )，如果<br>宏任务队列为空即 null，则执⾏跳转到微任务（MicroTask）的执⾏步骤。</li>
<li>将事件循环中的任务设置为已选择任务。</li>
<li>执⾏任务。当执⾏栈中的函数调⽤到⼀些异步执⾏的 API（例如异步 Ajax，DOM 事件，<br>setTimeout 等 API），则会开启对应的线程（Http 异步请求线程，事件触发线程和定时<br>器触发线程）进⾏监控和控制，当异步任务的事件满⾜触发条件时，对应的线程则会把<br>该事件的回调函数推进任务队列 (task queue) 中，等待主线程读取执⾏。</li>
<li>任务结束后，将事件循环中当前运⾏任务设置为 null，同时将已经运⾏完成的任务从任<br>务队列中删除。</li>
<li>microtasks 步骤：进⼊ microtask 检查点。⽤户代理会执⾏以下步骤：<br>5.1 设置 microtask 检查点标志为 true。<br>5.2 当事件循环 microtask 执⾏不为空时：选择⼀个最先进⼊的 microtask 队列的<br>microtask，将事件循环的 microtask 设置为已选择的 microtask，运⾏ microtask，将已<br>经执⾏完成的 microtask 置为 null，移出 microtask 中的 microtask。<br>5.3 清理 IndexDB 事务<br>5.4 设置进⼊ microtask 检查点的标志为 false。</li>
<li>更新界⾯渲染。</li>
<li>返回第⼀步。</li>
</ol>
<p>流程图：</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231715951.png"></p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231021363.png"></p>
<p>之前说的所有异步都放进⼀个任务消息队列⾥，现在也就是分为两个任务队列了，⽐较容易理解。</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231721785.png"></p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231723029.png"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;    </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve1&#x27;</span>)</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">// 创建微任务 micro_1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">// 创建了⼀个setTimeout的宏任务 macro_1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve2&#x27;</span>)</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">// 创建微任务 micro_2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>整体 script 作为第⼀个宏任务进⼊主线程，console 输出 script start ，</p>
</li>
<li><p>遇到 new Promise, ⼊栈处理，发现是同步回调，直接执⾏，console 输出 resolve1 ；<br>遇到 then，⼊栈处理，发现是异步回调函数（创建微任务 micro_1），出栈，移交给对应Web API 处理，将回调函数加⼊微任务队列尾部；</p>
</li>
<li><p>遇到 setTimeout ⼊栈处理，发现是异步回调函数（创建宏任务 macro_1），出栈，移交给 Web API（此处为定时器触发线程）处理 (0 秒等待后，将回调函数加到宏任务队列尾部)；</p>
</li>
<li><p>遇到 new Promise, ⼊栈处理，发现是同步回调，直接执⾏，console 输出 resolve2；遇到 then，⼊栈处理，发现是异步回调（创建微任务 micro2），出栈，移交给 Web API 处理，将回调函数加⼊微任务队列尾部；</p>
</li>
<li><p>执⾏到 script 任务末尾，console 输出 script end , 此时执⾏栈已清空 (将当前任务从任<br>务队列移除)，进⼊ microtask 检查点，此时任务队列情况如下：</p>
<table>
<thead>
<tr>
<th>任务队列</th>
<th>任务1</th>
<th>任务2</th>
</tr>
</thead>
<tbody><tr>
<td>宏任务队列1</td>
<td>macro_1</td>
<td></td>
</tr>
<tr>
<td>微任务队列</td>
<td>micro_1</td>
<td>micro_2</td>
</tr>
</tbody></table>
</li>
<li><p>取出第⼀个微任务，⼊栈处理，console 直接输出 promise1 , 出栈；</p>
</li>
<li><p>继续从微任务队列中取下⼀个，⼊栈处理，console 直接输出 promise2 ，出栈，</p>
</li>
<li><p>继续从微任务队列中取下⼀个，发现微任务队列已清空，</p>
</li>
<li><p>渲染界⾯，结束第⼀轮事件循环；</p>
</li>
<li><p>从宏任务队列中取出第⼀个宏任务，⼊栈处理，发现是 console 直接输出 timeout，未发现有微任务，再次渲染界⾯，结束本轮事件循环。</p>
</li>
</ol>
<h4 id="任务的优先级"><a href="#任务的优先级" class="headerlink" title="任务的优先级"></a>任务的优先级</h4><p>Event Loop事件循环是通过任务队列的机制来协调⼯作的。⼀个 Event Loop 中，可以有⼀个或者多个任务队列 (task queue)，⼀个任务队列便是⼀系列有序任务 (task) 的集合；每个任务都有⼀个任务源 (task source)，源⾃同⼀个任务源的 task 必须放到同⼀个任务队列，从不同源来的则被添加到不同队列。</p>
<p>一个事件循环有一个或多个任务队列。 任务队列是一组任务。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;outer&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;inner&quot;</span>&gt;</span>点击我试试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> $inner = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#inner&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> $outer = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#outer&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">handler</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;click&#x27;</span>) <span class="comment">// 直接输出 (js同步代码)</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function"><span class="params">_</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise&#x27;</span>)) <span class="comment">// 注册微任务</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function"><span class="params">_</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&gt;promise&#x27;</span>))</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;) <span class="comment">// 注册宏任务</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">requestAnimationFrame</span>(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;animationFrame&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function"><span class="params">_</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;animationFrame&gt;promise&#x27;</span>))</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;) <span class="comment">// 注册宏任务</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    $outer.<span class="title function_">setAttribute</span>(<span class="string">&#x27;data-random&#x27;</span>, <span class="title class_">Math</span>.<span class="title function_">random</span>()) <span class="comment">// DOM属性修改，触发微任务</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;observer&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;).<span class="title function_">observe</span>($outer, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">attributes</span>: <span class="literal">true</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  $inner.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handler)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  $outer.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handler)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 左边是⾼优先级</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 宏任务: requestAnimationFrame=&gt;setTimeout =&gt; setInterval </span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// =&gt; setImmediate(nodeJS) =&gt; I/O =&gt; UI Rendering</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 微任务: process.nextTick(nodeJS)</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// =&gt; Promise(Promise.then)/mutationObserver</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>点击#outter 输出结果，可以看出：requestAnimationFrame 优先级⽐ setTimeout ⾼</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tick1</span></span><br><span class="line">click</span><br><span class="line">resolve1</span><br><span class="line">promise</span><br><span class="line">observer</span><br><span class="line"><span class="comment">// Tick2</span></span><br><span class="line">animationFrame</span><br><span class="line">animationFrame&gt;promise</span><br><span class="line"><span class="comment">// Tick3</span></span><br><span class="line">timeout</span><br><span class="line">timeout&gt;promise</span><br></pre></td></tr></table></figure>

<p>点击#inner 输出结果，可以看出：每个 macroTask 队列中的 macroTask 按顺序执⾏，在每<br>macroTask 之间渲染⻚⾯</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tick1</span></span><br><span class="line">click</span><br><span class="line">resolve1</span><br><span class="line">promise</span><br><span class="line">observer</span><br><span class="line">click</span><br><span class="line">resolve1</span><br><span class="line">promise</span><br><span class="line">animationFrame&gt;promise1</span><br><span class="line">observer</span><br><span class="line"><span class="comment">// Tick2</span></span><br><span class="line">animationFrame</span><br><span class="line">animationFrame&gt;promise</span><br><span class="line"><span class="comment">// Tick3</span></span><br><span class="line">animationFrame</span><br><span class="line">animationFrame&gt;promise</span><br><span class="line"><span class="comment">// Tick4</span></span><br><span class="line">timeout</span><br><span class="line">timeout&gt;promise</span><br><span class="line"><span class="comment">// Tick5</span></span><br><span class="line">timeout</span><br><span class="line">timeout&gt;promise</span><br></pre></td></tr></table></figure>

<p>每个 macroTask 队列中的 macroTask 按顺序执⾏，在每个 macroTask 之间渲染⻚⾯<br>⼀个 macroTask 执⾏结束 (即 js 执⾏栈中为空)，会⽴即处理 macroTask 执⾏过程中产⽣<br>的 microTask 并且按顺序执⾏。microTask 产⽣的 macroTask 会⾃动加⼊相应的宏任务<br>队列。<br>每次循环会把这次宏任务产⽣的所有微任务执⾏完，再进⾏下⼀次 loop。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本⽂回答了渲染进程如何利⽤消息队列和事件循环机制完成⻚⾯协调各个线程⼯作的。</p>
<h3 id="1-JS为什么是单线程的？"><a href="#1-JS为什么是单线程的？" class="headerlink" title="1. JS为什么是单线程的？"></a>1. JS为什么是单线程的？</h3><p>想象⼀下，假设浏览器中的 JS 是多线程的（⼀个进程中资源共享），如果现在有 2 个线程，thread1 thread2, 由于是多线程的 JS, 所以他们可以对同⼀个 dom, 同时进⾏操作thread1 删除了该 dom, ⽽ thread2 编辑了该 dom,2 个⽭盾的命令同时下达，浏览器究竟该如何执⾏呢？<br>虽然 JS 是单线程，但是浏览器总共开了四个线程参与了 JS 的执⾏，其他三个只是辅助，不参与解析与执⾏： 1. JS 引擎线程（主线程，只有这个线程负责解析和执⾏ JS 代码） 2. 事件触发线程 3. 定时器触发线程 4. HTTP 异步请求线程<br>永远只有 JS 引擎线程在执⾏ JS 脚本程序，其他三个线程只负责将满⾜触发条件的处理函数推进任务队列，等待 JS 引擎线程执⾏</p>
<h3 id="2-为什么需要异步？"><a href="#2-为什么需要异步？" class="headerlink" title="2. 为什么需要异步？"></a>2. 为什么需要异步？</h3><p>如果 JS 中不存在异步，只能⾃上⽽下执⾏，如果上⼀⾏解析执⾏时间很⻓，那么下⾯的代码就会被阻塞。 对于⽤户⽽⾔，阻塞就意味着 “卡死”, 这样就导致了很差的⽤户体验。</p>
<h3 id="3-既然-JS-是单线程的，只能在一条线程上执行，又是如何实现的异步呢？"><a href="#3-既然-JS-是单线程的，只能在一条线程上执行，又是如何实现的异步呢？" class="headerlink" title="3. 既然 JS 是单线程的，只能在一条线程上执行，又是如何实现的异步呢？"></a>3. 既然 JS 是单线程的，只能在一条线程上执行，又是如何实现的异步呢？</h3><p>答案就是事件循环(Event loop)</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve1&#x27;</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">  &#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">// 创建微任务 micro_1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve2&#x27;</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">  &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">// 创建微任务 micro_2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231426418.png"></p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">111</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"><span class="title function_">fetch</span>(url) <span class="comment">// 假设该http请求花了3秒钟</span></span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">333</span>)</span><br><span class="line">&#125;)</span><br><span class="line">dom.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 假设⽤户在4秒钟时点击了dom</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">444</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">555</span>)</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="number">555</span></span><br><span class="line"><span class="number">222</span></span><br><span class="line"><span class="number">333</span></span><br><span class="line"><span class="number">444</span></span><br></pre></td></tr></table></figure>

<p>步骤1：</p>
<p>主线程只执⾏了 var a &#x3D; 111; 和 console.log (555) 两⾏代码，其他的代码分别交给了其他三个线程，因为其他线程需要 2、3、4 秒钟才成功并回调，所以在 2 秒之前，主线程⼀直在空闲，不断的探查队列是否不为空。<br>此时主线程⾥其实已经是空的了（因为执⾏完那两⾏代码了）</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231656730.png"></p>
<p>步骤2：</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231658682.png"></p>
<p>步骤3：</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231700021.png"></p>
<p>步骤4：</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231701462.png"></p>
<p>图⾥的队列⾥都只有⼀个回调函数，实际上有很多个回调函数，如果主线程⾥执⾏的代码复杂需要很⻓时间，这时队列⾥的函数们就排着，等着主线程啥时执⾏完，再来队列⾥取</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202208231706622.png"></p>
<p>所以从这⾥能看出来，对于 setTimeout，setInterval 的定时，不⼀定完全按照设想的时间的，因为主线程⾥的代码可能复杂到执⾏很久，所以会发⽣你定时 3 秒后执⾏，实际上是 3.5 秒后执⾏（主线程花费了 0.5 秒）</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">  process.<span class="title function_">nextTick</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">  process.<span class="title function_">nextTick</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;11&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;12&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 执⾏结果为1,7,6,8,2,4,3,5,9,11,10,12</span></span><br></pre></td></tr></table></figure>

<p>每次执⾏完⼀个宏任务后都要去检查微任务就可以了。</p>
<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer3&#x27;</span>)</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise3&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise4&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise5&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>执⾏结果：start &gt; promise4 &gt; end &gt; promise5 &gt; timer1 &gt; promise1 &gt; timer2 &gt; promise2 &gt; timer3 &gt; promise3</p>
<h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script end&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>宏任务：执行整体代码（相当于<script>中的代码）：</p>
<p>输出: script start  </p>
<p>遇到 setTimeout，加入宏任务队列，当前宏任务队列(setTimeout)  </p>
<p>遇到 promise，加入微任务，当前微任务队列(promise1)  </p>
<p>输出：script end</p>
</li>
<li><p>微任务：执行微任务队列（promise1）</p>
<p>输出：promise1，then 之后产生一个微任务，加入微任务队列，当前微任务队列（promise2）</p>
<p>执行 then，输出promise2</p>
</li>
<li><p>执行渲染操作，更新界面（敲黑板划重点）。</p>
</li>
<li><p>宏任务：执行 setTimeout</p>
<p>输出：setTimeout</p>
</li>
</ol>
<h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>new Promise(..)中的代码，也是同步代码，会立即执行。只有then之后的代码，才是异步执行的代码，是一个微任务。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;timeout1&quot;</span>);</span><br><span class="line">&#125;, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;timeout2&quot;</span>), <span class="number">10</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;then1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>步骤解析：</p>
<ul>
<li>当前任务队列：微任务: [], 宏任务：[<script>]<br>宏任务：</li>
</ul>
<p>输出: script start<br>遇到 timeout1，加入宏任务<br>遇到 Promise，输出promise1，直接 resolve，将 then 加入微任务，遇到 timeout2，加入宏任务。<br>输出script end<br>宏任务第一个执行结束</p>
<ul>
<li>当前任务队列：微任务[then1]，宏任务[timeou1, timeout2]<br>微任务：</li>
</ul>
<p>执行 then1，输出then1<br>微任务队列清空</p>
<ul>
<li>当前任务队列：微任务[]，宏任务[timeou1, timeout2]<br>宏任务：</li>
</ul>
<p>输出timeout1<br>输出timeout2</p>
<ul>
<li>当前任务队列：微任务[]，宏任务[timeou2]</li>
</ul>
<p>微任务：</p>
<p>为空跳过</p>
<p>当前任务队列：微任务[]，宏任务[timeou2]<br>宏任务：</p>
<p>输出timeout2</p>
<h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p>async 和 await 其实就是 Generator 和 Promise 的语法糖。</p>
<p>async 函数和普通 函数没有什么不同，他只是表示这个函数里有异步操作的方法，并返回一个 Promise 对象</p>
<p>翻译过来其实就是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async/await 写法</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Promise 写法</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title function_">async2</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>步骤解析：</p>
<p>当前任务队列：宏任务：[<script>]，微任务: []<br>宏任务：</p>
<p>输出：async1 start<br>遇到 async2，输出：async2，并将 then（async1 end）加入微任务<br>遇到 setTimeout，加入宏任务。<br>遇到 Promise，输出：promise1，直接 resolve，将 then(promise2)加入微任务<br>输出：script end</p>
<p>当前任务队列：微任务[async1 end,promise2]，宏任务[timeout]<br>微任务：</p>
<p>输出：async1 end<br>async1 end 出队</p>
<p>输出：promise2<br>promise2 出队<br>微任务队列清空</p>
<p>当前任务队列：微任务[]，宏任务[timeout]<br>宏任务：</p>
<p>输出：timeout<br>timeout 出队，宏任务清空</p>
<h3 id="8"><a href="#8" class="headerlink" title="8"></a>8</h3><p>setTimeout 是一个宏任务，会被添加到宏任务队列当中去，按顺序执行，如果前面有。</p>
<p>setTimeout() 的第二个参数是为了告诉 JavaScript 再过多长时间把当前任务添加到队列中。</p>
<p>如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。</p>
<p>看代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getSeconds</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;then1&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getSeconds</span>() - s &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;while&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script end&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>因为then是一个微任务，会先于setTimeout执行，所以，虽然setTimeout是在两秒后加入的宏任务，但是因为then中的在while操作被延迟了4s，所以一直推迟到了4s秒后才执行的setTimeout。</p>
<p>所以输出的顺序是：script start、promise、script end、then1。<br>四秒后输出：while、timeout</p>
<p>关于 setTimeout 要补充的是，即便主线程为空，0 毫秒实际上也是达不到的。根据 HTML 的标准，最低是 4 毫秒。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gjbegjbe.github.io/2022/07/20/Vue%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%AB%98%E9%98%B6%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gjbe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gjbe">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/20/Vue%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%AB%98%E9%98%B6%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">Vue学习（五）————高阶指南</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-20 15:05:43" itemprop="dateCreated datePublished" datetime="2022-07-20T15:05:43+08:00">2022-07-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-08 17:54:50" itemprop="dateModified" datetime="2022-08-08T17:54:50+08:00">2022-08-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、Vue与Web-Components"><a href="#一、Vue与Web-Components" class="headerlink" title="一、Vue与Web Components"></a>一、Vue与Web Components</h1><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components">Web Components</a> 是一组 Web 原生 API 的总称，允许开发人员创建可重用的自定义组件。</p>
<p>Vue 和 Web Components 大体上是互补的技术。Vue 能很好地解析和创建自定义元素。不论是在将自定义元素整合到已有的 Vue 应用中，还是使用 Vue 构建和分发自定义元素，你都能获得很好的支持。</p>
<h2 id="1-在Vue中使用自定义元素"><a href="#1-在Vue中使用自定义元素" class="headerlink" title="1. 在Vue中使用自定义元素"></a>1. 在Vue中使用自定义元素</h2><p>Vue 应用程序中解析出的自定义元素大体上和原生 HTML 元素相同，但需要牢记以下几点：</p>
<h3 id="1-1-跳过组件的解析"><a href="#1-1-跳过组件的解析" class="headerlink" title="1.1 跳过组件的解析"></a>1.1 跳过组件的解析</h3><p>默认情况下，Vue 会优先尝试将一个非原生的 HTML 标签解析为一个注册的 Vue 组件，如果失败则会将其渲染为自定义元素。这种行为会导致在开发模式下的 Vue 发出“failed to resolve component”的警告。如果你希望 Vue 能将某些确切的元素作为自定义元素处理并跳过组件解析，请指定 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/application-config.html#compileroptions"><code>compilerOptions.isCustomElement</code> 选项</a>。</p>
<p>如果你正在构建步骤中使用 Vue，则此选项需要通过构建配置传递，因为这是一个编译时选项。</p>
<h4 id="1-1-1-浏览器内配置示例"><a href="#1-1-1-浏览器内配置示例" class="headerlink" title="1.1.1 浏览器内配置示例"></a>1.1.1 浏览器内配置示例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仅当使用浏览器内编译时有效</span></span><br><span class="line"><span class="comment">// 如果你正在使用构建工具，请查看下方的配置示例</span></span><br><span class="line">app.<span class="property">config</span>.<span class="property">compilerOptions</span>.<span class="property">isCustomElement</span> = <span class="function"><span class="params">tag</span> =&gt;</span> tag.<span class="title function_">includes</span>(<span class="string">&#x27;-&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="1-1-2-Vite配置示例"><a href="#1-1-2-Vite配置示例" class="headerlink" title="1.1.2 Vite配置示例"></a>1.1.2 Vite配置示例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">vue</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: &#123;</span><br><span class="line">        <span class="attr">compilerOptions</span>: &#123;</span><br><span class="line">          <span class="comment">// 将所有包含短横线的标签作为自定义元素处理</span></span><br><span class="line">          <span class="attr">isCustomElement</span>: <span class="function"><span class="params">tag</span> =&gt;</span> tag.<span class="title function_">includes</span>(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-3-Vue-CLI配置示例"><a href="#1-1-3-Vue-CLI配置示例" class="headerlink" title="1.1.3 Vue CLI配置示例"></a>1.1.3 Vue CLI配置示例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">chainWebpack</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config.<span class="property">module</span></span><br><span class="line">      .<span class="title function_">rule</span>(<span class="string">&#x27;vue&#x27;</span>)</span><br><span class="line">      .<span class="title function_">use</span>(<span class="string">&#x27;vue-loader&#x27;</span>)</span><br><span class="line">      .<span class="title function_">tap</span>(<span class="function"><span class="params">options</span> =&gt;</span> (&#123;</span><br><span class="line">        ...options,</span><br><span class="line">        <span class="attr">compilerOptions</span>: &#123;</span><br><span class="line">          <span class="comment">// 将所有以 ion- 开头的标签作为自定义元素处理</span></span><br><span class="line">          <span class="attr">isCustomElement</span>: <span class="function"><span class="params">tag</span> =&gt;</span> tag.<span class="title function_">startsWith</span>(<span class="string">&#x27;ion-&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-传递-DOM-Property"><a href="#1-2-传递-DOM-Property" class="headerlink" title="1.2 传递 DOM Property"></a>1.2 传递 DOM Property</h3><p>由于 DOM attribute 只能是字符串，因此我们得将复杂数据作为 DOM property 传递给自定义元素。在自定义元素上配置 prop 时，Vue 3 会自动使用 <code>in</code> 操作符检查是否存在 DOM-property，如果此键存在则会优先将值配置为一个 DOM property。也就是说大多数情况下，如果自定义元素遵守<a target="_blank" rel="noopener" href="https://web.dev/index.md/">推荐的最佳实践</a>，则无需考虑这一点。</p>
<p>但是，在极少数情况下，数据必须作为 DOM property 传递，但自定义元素没有正确定义&#x2F;反映 property (导致 <code>in</code> 检查失败)。此时，可以使用 <code>.prop</code> 修饰符强制将一个 <code>v-bind</code> 绑定设置为一个 DOM property：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-element</span> <span class="attr">:user.prop</span>=<span class="string">&quot;&#123; name: &#x27;jack&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-element</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 等效的简写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-element</span> <span class="attr">.user</span>=<span class="string">&quot;&#123; name: &#x27;jack&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-element</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-使用-Vue-构建自定义元素"><a href="#2-使用-Vue-构建自定义元素" class="headerlink" title="2. 使用 Vue 构建自定义元素"></a>2. 使用 Vue 构建自定义元素</h2><p>自定义元素的一大好处就是它们可以与任何框架一起使用，甚至可以在没有框架的情况下使用。当你需要向可能使用不同前端技术栈的终端用户分发组件时，或者希望向最终应用程序隐藏其所用组件的实现细节时，使用自定义元素非常适合。</p>
<h3 id="2-1-defineCustomElement"><a href="#2-1-defineCustomElement" class="headerlink" title="2.1 defineCustomElement"></a>2.1 defineCustomElement</h3><p>Vue 支持使用 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/global-api.html#definecustomelement"><code>defineCustomElement</code></a> 方法创建自定义元素，并且使用与 Vue 组件完全一致的 API。该方法接受与 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/global-api.html#definecomponent"><code>defineComponent</code></a> 相同的参数，但是会返回一个扩展自 <code>HTMLElement</code> 的自定义元素构造函数：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-vue-element</span>&gt;</span><span class="tag">&lt;/<span class="name">my-vue-element</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineCustomElement &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyVueElement</span> = <span class="title function_">defineCustomElement</span>(&#123;</span><br><span class="line">  <span class="comment">// 在此提供正常的 Vue 组件选项</span></span><br><span class="line">  <span class="attr">props</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">emits</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`...`</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// defineCustomElement 独有特性: CSS 会被注入到隐式根 (shadow root) 中</span></span><br><span class="line">  <span class="attr">styles</span>: [<span class="string">`/* inlined css */`</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册自定义元素</span></span><br><span class="line"><span class="comment">// 注册完成后，此页面上的所有的 `&lt;my-vue-element&gt;` 标签会被更新</span></span><br><span class="line">customElements.<span class="title function_">define</span>(<span class="string">&#x27;my-vue-element&#x27;</span>, <span class="title class_">MyVueElement</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你也可以编程式地实例化这个元素：</span></span><br><span class="line"><span class="comment">// (只能在注册后完成此操作)</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">MyVueElement</span>(&#123;</span><br><span class="line">    <span class="comment">// initial props (optional)</span></span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="2-1-1-生命周期"><a href="#2-1-1-生命周期" class="headerlink" title="2.1.1 生命周期"></a>2.1.1 生命周期</h4><ul>
<li><p>当元素的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_custom_elements#%E4%BD%BF%E7%94%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><code>connectedCallback</code></a> 被首次调用时，Vue 自定义元素会在其隐式根部挂载一个内部的 Vue 组件实例。</p>
</li>
<li><p>当元素的 <code>disconnectedCallback</code> 被调用时，Vue 会在很短的时间后检查此元素是否已被移出页面。</p>
<ul>
<li><p>如果元素仍在文档中，说明是移动，组件实例将被保留；</p>
</li>
<li><p>如果元素已被移出文档，说明是移除，组件实例将被卸载。</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-1-2-Props"><a href="#2-1-2-Props" class="headerlink" title="2.1.2 Props"></a>2.1.2 Props</h4><ul>
<li><p>所有使用 <code>props</code> 选项声明的 prop 都将在自定义元素上定义为 property。Vue 将在合适的时候自动处理 attribute &#x2F; property 之间的映射。</p>
<ul>
<li><p>Attribute 总是映射为相应的 property。</p>
</li>
<li><p>基础类型 (<code>string</code>、<code>boolean</code> 或 <code>number</code>) 的 property 会被映射为 attribute。</p>
</li>
</ul>
</li>
<li><p>Vue 也会自动将声明为 <code>Boolean</code> 或 <code>Number</code> 类型的 attribute prop (始终为字符串)转换为所需的类型。例如给出以下 prop 声明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">  <span class="attr">selected</span>: <span class="title class_">Boolean</span>,</span><br><span class="line">  <span class="attr">index</span>: <span class="title class_">Number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及自定义元素用法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-element</span> <span class="attr">selected</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-element</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在组件中，<code>selected</code> 会被转换为 <code>true</code> (boolean)，<code>index</code> 会被转换为 <code>1</code> (number)。</p>
</li>
</ul>
<h4 id="2-1-3-事件"><a href="#2-1-3-事件" class="headerlink" title="2.1.3 事件"></a>2.1.3 事件</h4><p>在自定义元素中，通过 <code>this.$emit</code> 或在 setup 中的 <code>emit</code> 发出的事件会被调度为原生 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/Events/Creating_and_triggering_events#adding_custom_data_%E2%80%93_customevent">CustomEvents</a>。附加的事件参数 (payload) 会作为数组暴露在 CustomEvent 对象的 <code>details</code> property 上。</p>
<h4 id="2-1-4-插槽"><a href="#2-1-4-插槽" class="headerlink" title="2.1.4 插槽"></a>2.1.4 插槽</h4><p>在组件内部，可以像往常一样使用 <code>&lt;slot/&gt;</code> 渲染插槽。但是在解析最终生成的元素时，它只接受<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_templates_and_slots">原生插槽语法</a>：</p>
<ul>
<li><p>不支持<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/component-slots.html#scoped-slot#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD">作用域插槽</a>。</p>
</li>
<li><p>传递命名插槽时，请使用 <code>slot</code> attribute 而非 <code>v-slot</code> 指令：</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-element</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">&quot;named&quot;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-element</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-1-5-Provide-x2F-Inject"><a href="#2-1-5-Provide-x2F-Inject" class="headerlink" title="2.1.5 Provide&#x2F;Inject"></a>2.1.5 Provide&#x2F;Inject</h4><p><a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/component-provide-inject.html#provide-inject">Provide &#x2F; Inject API</a> 和<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/composition-api.html#provide-inject">组合式 API 中的 Provide &#x2F; Inject</a> 在 Vue 定义的自定义元素之间可以正常工作。但是请注意这<strong>仅适用于自定义元素之间</strong>，即 Vue 定义的自定义元素将无法注入非自定义元素的 Vue 组件提供的属性。</p>
<h3 id="2-2-将-SFC-作为自定义元素"><a href="#2-2-将-SFC-作为自定义元素" class="headerlink" title="2.2 将 SFC 作为自定义元素"></a>2.2 将 SFC 作为自定义元素</h3><p><code>defineCustomElement</code> 也适用于 Vue 单文件组件 (SFC)。但是，在默认工具链配置下，生产构建时 SFC 内部的 <code>&lt;style&gt;</code> 会被提取并合并到单独的 CSS 文件中。当使用 SFC 作为自定义元素时，通常需要将 <code>&lt;style&gt;</code> 标签注入自定义元素的隐式根。</p>
<p>官方 SFC 工具支持以“自定义元素模式”(需要 <code>@vitejs/plugin-vue@^1.4.0</code> 或 <code>vue-loader@^16.5.0</code> )导入 SFC。以自定义元素模式加载的 SFC 将其 <code>&lt;style&gt;</code> 标签作为 CSS 字符串内联，并在组件的 <code>styles</code> 选项中暴露出来，然后会被 <code>defineCustomElement</code> 获取并在实例化时注入隐式根。</p>
<p>要选用此模式，只需使用 <code>.ce.vue</code> 作为文件拓展名即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineCustomElement &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Example</span> <span class="keyword">from</span> <span class="string">&#x27;./Example.ce.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Example</span>.<span class="property">styles</span>) <span class="comment">// [&quot;/* 内联的 css */&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为自定义元素构造器</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ExampleElement</span> = <span class="title function_">defineCustomElement</span>(<span class="title class_">Example</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line">customElements.<span class="title function_">define</span>(<span class="string">&#x27;my-example&#x27;</span>, <span class="title class_">ExampleElement</span>)</span><br></pre></td></tr></table></figure>

<p>如果你希望指定应在自定义元素模式下导入的文件(例如将 <em>所有</em> SFC 视为自定义元素)，你可以将 <code>customElement</code> 选项传递给相应的构建插件：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/vitejs/vite/tree/main/packages/plugin-vue#using-vue-sfcs-as-custom-elements">@vitejs&#x2F;plugin-vue</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-loader/tree/next#v16-only-options">vue-loader</a></li>
</ul>
<h3 id="2-3-Vue自定义元素库的提示"><a href="#2-3-Vue自定义元素库的提示" class="headerlink" title="2.3 Vue自定义元素库的提示"></a>2.3 Vue自定义元素库的提示</h3><p>如果使用 Vue 构建自定义元素，则此元素将依赖于 Vue 的运行时。这会导致一个 16kb 左右的基础大小开销 (具体取决于使用了多少特性)。这意味着如果你准备发布单个自定义元素，使用 Vue 可能不是最佳方案——你可能想要使用纯 JavaScript，<a target="_blank" rel="noopener" href="https://github.com/vuejs/petite-vue">petite-vue</a>，或是其他专注于轻量化运行时的框架。但是，如果你要发布具有复杂逻辑的自定义元素集合，那么这点基础大小就会显得合理了，因为 Vue 可以使用非常精简的代码耦合每个组件。你准备发布的元素越多，开销权衡就越好。</p>
<p>如果自定义元素会在同样使用 Vue 的项目中使用，你可以选择从构建的包中外部化 Vue，这样元素就会使用与宿主应用程序相同的 Vue 副本。</p>
<p>我们推荐你提供一个导出独立元素的构造函数，这样你的用户就可以灵活地按需导入它们并使用他们所需的标签名注册自定义元素。你还可以导出一个能自动注册所有元素的函数以便于使用。这是一个 Vue 自定义元素库示例的入口点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineCustomElement &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Foo</span> <span class="keyword">from</span> <span class="string">&#x27;./MyFoo.ce.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Bar</span> <span class="keyword">from</span> <span class="string">&#x27;./MyBar.ce.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyFoo</span> = <span class="title function_">defineCustomElement</span>(<span class="title class_">Foo</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyBar</span> = <span class="title function_">defineCustomElement</span>(<span class="title class_">Bar</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出独立的元素</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="title class_">MyFoo</span>, <span class="title class_">MyBar</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">register</span>(<span class="params"></span>) &#123;</span><br><span class="line">  customElements.<span class="title function_">define</span>(<span class="string">&#x27;my-foo&#x27;</span>, <span class="title class_">MyFoo</span>)</span><br><span class="line">  customElements.<span class="title function_">define</span>(<span class="string">&#x27;my-bar&#x27;</span>, <span class="title class_">MyBar</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你有许多组件，你还可以利用构建工具提供的功能，例如 Vite 的 <a target="_blank" rel="noopener" href="https://cn.vitejs.dev/guide/features.html#glob-import">glob 导入</a>或是 webpack 的 <a target="_blank" rel="noopener" href="https://webpack.js.org/guides/dependency-management/#requirecontext"><code>require.context</code></a>。</p>
<h2 id="3-对比-Web-Components-与-Vue-组件"><a href="#3-对比-Web-Components-与-Vue-组件" class="headerlink" title="3. 对比 Web Components 与 Vue 组件"></a>3. 对比 Web Components 与 Vue 组件</h2><p>一些开发人员认为应该避免使用框架专有的组件模型，并且仅使用自定义元素以便应用程序“面向未来”。我们将在此处尝试解释为什么我们认为这种看法过于简单化了问题。</p>
<p>自定义元素和 Vue 组件之间确实存在一定程度的功能重叠：它们都允许我们定义具有数据传递、事件发出和生命周期管理功能的可重用组件。然而，Web Components API 是相对低级和简单的。为了构建一个实际可用的应用程序，我们需要很多平台没有涵盖的附加功能：</p>
<ul>
<li><p>一个声明式的、高效的模板系统；</p>
</li>
<li><p>一个有助于跨组件逻辑提取和重用的响应式状态管理系统；</p>
</li>
<li><p>一个能在服务器端渲染组件并在客户端集成的高效方法(SSR)，这对于 SEO 和 <a target="_blank" rel="noopener" href="https://web.dev/vitals/">Web 关键指标 (例如 LCP)</a> 来说很重要。原生自定义元素 SSR 通常涉及在 Node.js 中模拟 DOM，然后序列化被改变的 DOM，而 Vue SSR 会尽可能编译为字符串连接，后者的效率更高。</p>
</li>
</ul>
<p>作为一个考虑周到的系统，Vue 的组件模型在设计时就考虑到了这些需求。</p>
<p>如果你拥有一支称职的工程团队，或许可以基于原生自定义元素构建出近似效果的产品——但这也意味着你需要承担对内部框架的长期维护负担，同时失去了像 Vue 这样拥有生态系统和社区贡献的成熟的框架。</p>
<p>也有使用自定义元素作为其组件模型基础构建的框架，但它们都不可避免地要针对上面列出的问题引入自己的专有解决方案。使用这些框架需要学习或是购买他们对这些问题的技术决策——尽管他们可能会打广告宣传——这依旧无法使你免除后顾之忧。</p>
<p>我们还找到了一些自定义元素无法胜任的应用场景：</p>
<ul>
<li><p>激进的插槽定值会阻碍组件的整合。Vue 的<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/component-slots.html#scoped-slots">作用域插槽</a>提供了非常强大的组件整合机制，这是原生插槽所没有的，因为原生插槽的激进特性。激进特性插槽同样意味着接收组件无法控制何时或是否需要渲染一段插槽内容。</p>
</li>
<li><p>目前，发布带有隐式 DOM scoped CSS 的自定义元素需要将 CSS 嵌入到 JavaScript 中，以便它们可以在运行时注入到隐式根中。在 SSR 场景中，它们还会导致重复定义样式。该领域有一些<a target="_blank" rel="noopener" href="https://github.com/whatwg/html/pull/4898/">平台特性</a>正在开发中——但截至目前，它们尚未得到普遍支持，并且仍有生产环境性能&#x2F; SSR 问题需要解决。而与此同时，Vue SFC 已经提供了 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/sfc-style.html">CSS 作用域机制</a>，支持将样式提取到纯 CSS 文件中。</p>
</li>
</ul>
<p>Vue 将始终与 Web 平台中的最新标准保持同步，如果平台提供的任何内容能使我们的工作更轻松，我们将很乐意利用它。但是，我们的目标是提供运行良好且开箱即用的解决方案。这意味着我们必须以批判的心态整合新的平台功能——这会涉及到在遵循现有标准的前提下弥补标准的不足。</p>
<h1 id="二、响应性原理"><a href="#二、响应性原理" class="headerlink" title="二、响应性原理"></a>二、响应性原理</h1><h2 id="1-深入响应性原理"><a href="#1-深入响应性原理" class="headerlink" title="1. 深入响应性原理"></a>1. 深入响应性原理</h2><p>Vue 最独特的特性之一，是其非侵入性的响应性系统。数据模型是被代理的 JavaScript 对象。而当你修改它们时，视图会进行更新。这让状态管理非常简单直观，不过理解其工作原理同样重要，这样你可以避开一些常见的问题。在这个章节，我们将研究一下 Vue 响应性系统的底层的细节。</p>
<h3 id="1-1-什么是响应性"><a href="#1-1-什么是响应性" class="headerlink" title="1.1 什么是响应性"></a>1.1 什么是响应性</h3><p>响应性是一种允许我们以声明式的方式去适应变化的编程范例。人们通常展示的典型例子，是一份 excel 电子表格 (一个非常好的例子)。</p>
<p>如果将数字 2 放在第一个单元格中，将数字 3 放在第二个单元格中并要求提供 SUM，则电子表格会将其计算出来给你。不要惊奇，同时，如果你更新第一个数字，SUM 也会自动更新。</p>
<p>JavaScript 通常不是这样工作的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> val1 = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> val2 = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> sum = val1 + val2</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum) <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">val1 = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum) <span class="comment">// 仍然是 5</span></span><br></pre></td></tr></table></figure>

<p>如果我们更新第一个值，sum 不会被修改。</p>
<p>那么我们如何用 JavaScript 实现这一点呢？</p>
<p>作为一个高阶的概述，我们需要做到以下几点：</p>
<ol>
<li><strong>当一个值被读取时进行追踪</strong>，例如 <code>val1 + val2</code> 会同时读取 <code>val1</code> 和 <code>val2</code>。</li>
<li><strong>当某个值改变时进行检测</strong>，例如，当我们赋值 <code>val1 = 3</code>。</li>
<li><strong>重新运行代码来读取原始值</strong>，例如，再次运行 <code>sum = val1 + val2</code> 来更新 <code>sum</code> 的值。</li>
</ol>
<p>我们不能直接用前面的例子中的代码来继续，但是我们后面会再来看看这个例子，以及如何调整它来兼容 Vue 的响应性系统。</p>
<p>首先，让我们深入了解一下 Vue 是如何实现上述核心响应性要求的。</p>
<h3 id="1-2-Vue如何知道哪些代码在执行"><a href="#1-2-Vue如何知道哪些代码在执行" class="headerlink" title="1.2 Vue如何知道哪些代码在执行"></a>1.2 Vue如何知道哪些代码在执行</h3><p>为了能够在数值变化时，随时运行我们的总和，我们首先要做的是将其包裹在一个函数中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">updateSum</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  sum = val1 + val2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但我们如何告知 Vue 这个函数呢？</p>
<p>Vue 通过一个<em>副作用 (effect)</em> 来跟踪当前正在运行的函数。副作用是一个函数的包裹器，在函数被调用之前就启动跟踪。Vue 知道哪个副作用在何时运行，并能在需要时再次执行它。</p>
<p>为了更好地理解这一点，让我们尝试脱离 Vue 实现类似的东西，以看看它如何工作。</p>
<p>我们需要的是能够包裹总和的东西，像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">createEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  sum = val1 + val2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我们需要 <code>createEffect</code> 来跟踪和执行。我们的实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 维持一个执行副作用的栈</span></span><br><span class="line"><span class="keyword">const</span> runningEffects = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createEffect</span> = fn =&gt; &#123;</span><br><span class="line">  <span class="comment">// 将传来的 fn 包裹在一个副作用函数中</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">effect</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    runningEffects.<span class="title function_">push</span>(effect)</span><br><span class="line">    <span class="title function_">fn</span>()</span><br><span class="line">    runningEffects.<span class="title function_">pop</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 立即自动执行副作用</span></span><br><span class="line">  <span class="title function_">effect</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们的副作用被调用时，在调用 <code>fn</code> 之前，它会把自己推到 <code>runningEffects</code> 数组中。这个数组可以用来检查当前正在运行的副作用。</p>
<p>副作用是许多关键功能的起点。例如，组件的渲染和计算属性都在内部使用副作用。任何时候，只要有东西对数据变化做出奇妙的回应，你就可以肯定它已经被包裹在一个副作用中了。</p>
<p>虽然 Vue 的公开 API 不包括任何直接创建副作用的方法，但它确实暴露了一个叫做 <code>watchEffect</code> 的函数，它的行为很像我们例子中的 <code>createEffect</code> 函数。我们会在<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/reactivity-computed-watchers.html#watcheffect">该指南后面的部分</a>详细讨论这个问题。</p>
<p>但知道什么代码在执行只是难题的一部分。Vue 如何知道副作用使用了什么值，以及如何知道它们何时发生变化？</p>
<h3 id="1-3-Vue如何跟踪变化"><a href="#1-3-Vue如何跟踪变化" class="headerlink" title="1.3 Vue如何跟踪变化"></a>1.3 Vue如何跟踪变化</h3><p>我们不能像前面的例子中那样跟踪局部变量的重新分配，在 JavaScript 中没有这样的机制。我们可以跟踪的是对象 property 的变化。</p>
<p>当我们从一个组件的 <code>data</code> 函数中返回一个普通的 JavaScript 对象时，Vue 会将该对象包裹在一个带有 <code>get</code> 和 <code>set</code> 处理程序的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a> 中。Proxy 是在 ES6 中引入的，它使 Vue 3 避免了 Vue 早期版本中存在的一些响应性问题。</p>
<p>那看起来灵敏，不过，需要一些 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a> 的知识才能理解！所以让我们深入了解一下。有很多关于 Proxy 的文档，但你真正需要知道的是，<strong>Proxy 是一个对象，它包装了另一个对象，并允许你拦截对该对象的任何交互。</strong></p>
<p>我们这样使用它：<code>new Proxy(target, handler)</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dinner = &#123;</span><br><span class="line">  <span class="attr">meal</span>: <span class="string">&#x27;tacos&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;intercepted!&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> target[property]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(dinner, handler)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">meal</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// intercepted!</span></span><br><span class="line"><span class="comment">// tacos</span></span><br></pre></td></tr></table></figure>

<p>这里我们截获了读取目标对象 property 的举动。像这样的处理函数也称为一个*捕捉器 (trap)*。有许多可用的不同类型的捕捉器，每个都处理不同类型的交互。</p>
<p>除了控制台日志，我们可以在这里做任何我们想做的事情。如果我们愿意，我们甚至可以不返回实际值。这就是为什么 Proxy 对于创建 API 如此强大。</p>
<p>使用 Proxy 的一个难点是 <code>this</code> 绑定。我们希望任何方法都绑定到这个 Proxy，而不是目标对象，这样我们也可以拦截它们。值得庆幸的是，ES6 引入了另一个名为 <code>Reflect</code> 的新特性，它允许我们以最小的代价消除了这个问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dinner = &#123;</span><br><span class="line">  <span class="attr">meal</span>: <span class="string">&#x27;tacos&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, property, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(dinner, handler)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">meal</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// tacos</span></span><br></pre></td></tr></table></figure>

<p>使用 Proxy 实现响应性的第一步就是跟踪一个 property 何时被读取。我们在一个名为 <code>track</code> 的处理器函数中执行此操作，该函数可以传入 <code>target</code> 和 <code>property</code> 两个参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dinner = &#123;</span><br><span class="line">  <span class="attr">meal</span>: <span class="string">&#x27;tacos&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, property, receiver</span>) &#123;</span><br><span class="line">    <span class="title function_">track</span>(target, property)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(dinner, handler)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">meal</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// tacos</span></span><br></pre></td></tr></table></figure>

<p>这里没有展示 <code>track</code> 的实现。它将检查当前运行的是哪个<em>副作用</em>，并将其与 <code>target</code> 和 <code>property</code> 记录在一起。这就是 Vue 如何知道这个 property 是该副作用的依赖项。</p>
<p>最后，我们需要在 property 值更改时重新运行这个副作用。为此，我们需要在代理上使用一个 <code>set</code> 处理函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dinner = &#123;</span><br><span class="line">  <span class="attr">meal</span>: <span class="string">&#x27;tacos&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, property, receiver</span>) &#123;</span><br><span class="line">    <span class="title function_">track</span>(target, property)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) &#123;</span><br><span class="line">    <span class="title function_">trigger</span>(target, property)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(dinner, handler)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">meal</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// tacos</span></span><br></pre></td></tr></table></figure>

<p>还记得前面的表格吗？现在，我们对 Vue 如何实现这些关键步骤有了答案：</p>
<ol>
<li><strong>当一个值被读取时进行追踪</strong>：proxy 的 <code>get</code> 处理函数中 <code>track</code> 函数记录了该 property 和当前副作用。</li>
<li><strong>当某个值改变时进行检测</strong>：在 proxy 上调用 <code>set</code> 处理函数。</li>
<li><strong>重新运行代码来读取原始值</strong>：<code>trigger</code> 函数查找哪些副作用依赖于该 property 并执行它们。</li>
</ol>
<p>该被代理的对象对于用户来说是不可见的，但是在内部，它们使 Vue 能够在 property 的值被访问或修改的情况下进行依赖跟踪和变更通知。有一点需要注意，控制台日志会以不同的方式对 proxy 对象进行格式化，因此你可能需要安装 <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-devtools">vue-devtools</a>，以提供一种更易于检查的界面。</p>
<p>如果我们要用一个组件重写我们原来的例子，我们可以这样做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="title function_">createApp</span>(&#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">val1</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">val2</span>: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title function_">sum</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">val1</span> + <span class="variable language_">this</span>.<span class="property">val2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vm.<span class="property">sum</span>) <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">vm.<span class="property">val1</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vm.<span class="property">sum</span>) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p><code>data</code> 返回的对象将被包裹在响应式代理中，并存储为 <code>this.$data</code>。Property <code>this.val1</code> 和 <code>this.val2</code> 分别是 <code>this.$data.val1</code> 和 <code>this.$data.val2</code> 的别名，因此它们通过相同的代理。</p>
<p>Vue 将把 <code>sum</code> 的函数包裹在一个副作用中。当我们试图访问 <code>this.sum</code> 时，它将运行该副作用来计算数值。包裹 <code>$data</code> 的响应式代理将会追踪到，当副作用运行时，property <code>val1</code> 和 <code>val2</code> 被读取了。</p>
<p>从 Vue 3 开始，我们的响应性现在可以在一个<a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-next/tree/master/packages/reactivity">独立包</a>中使用。将 <code>$data</code> 包裹在一个代理中的函数被称为 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/basic-reactivity.html#reactive"><code>reactive</code></a>。我们可以自己直接调用这个函数，允许我们在不需要使用组件的情况下将一个对象包裹在一个响应式代理中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">val1</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">val2</span>: <span class="number">3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在指南接下来的几页中，我们将探索响应性包所暴露的功能。这包括我们已经见过的 <code>reactive</code> 和 <code>watchEffect</code> 等函数，以及使用其他响应性特性的方法，如不需要创建组件的 <code>computed</code> 和 <code>watch</code>。</p>
<h4 id="1-3-1-被代理的对象"><a href="#1-3-1-被代理的对象" class="headerlink" title="1.3.1 被代理的对象"></a>1.3.1 被代理的对象</h4><p>Vue 在内部跟踪所有已经被转成响应式的对象，所以它总是为同一个对象返回相同的代理。</p>
<p>当从一个响应式代理中访问一个嵌套对象时，该对象在被返回之前<em>也</em>被转换为一个代理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, property, receiver</span>) &#123;</span><br><span class="line">    <span class="title function_">track</span>(target, property)</span><br><span class="line">    <span class="keyword">const</span> value = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isObject</span>(value)) &#123;</span><br><span class="line">      <span class="comment">// 将嵌套对象包裹在自己的响应式代理中</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">reactive</span>(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-Proxy-vs-原始标识"><a href="#1-3-2-Proxy-vs-原始标识" class="headerlink" title="1.3.2 Proxy vs 原始标识"></a>1.3.2 Proxy vs 原始标识</h4><p>Proxy 的使用确实引入了一个需要注意的新警告：在身份比较方面，被代理对象与原始对象不相等 (<code>===</code>)。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> wrapped = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, handlers)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj === wrapped) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>其他依赖严格等于比较的操作也会受到影响，例如 <code>.includes()</code> 或 <code>.indexOf()</code>。</p>
<p>这里的最佳实践是永远不要持有对原始对象的引用，而只使用响应式版本。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;) <span class="comment">// 未引用原始</span></span><br></pre></td></tr></table></figure>

<p>这确保了等值的比较和响应性的行为都符合预期。</p>
<p>请注意，Vue 不会在 Proxy 中包裹数字或字符串等原始值，所以你仍然可以对这些值直接使用 <code>===</code> 来比较：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">count</span> === <span class="number">0</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-如何让渲染响应变化"><a href="#1-4-如何让渲染响应变化" class="headerlink" title="1.4 如何让渲染响应变化"></a>1.4 如何让渲染响应变化</h3><p>一个组件的模板被编译成一个 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/render-function.html"><code>render</code></a> 函数。渲染函数创建 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/render-function.html#%E8%99%9A%E6%8B%9F-dom-%E6%A0%91">VNodes</a>，描述该组件应该如何被渲染。它被包裹在一个副作用中，允许 Vue 在运行时跟踪被“触达”的 property。</p>
<p>一个 <code>render</code> 函数在概念上与一个 <code>computed</code> property 非常相似。Vue 并不确切地追踪依赖关系是如何被使用的，它只知道在函数运行的某个时间点上使用了这些依赖关系。如果这些 property 中的任何一个随后发生了变化，它将触发副作用再次运行，重新运行 <code>render</code> 函数以生成新的 VNodes。然后这些举动被用来对 DOM 进行必要的修改。</p>
<h2 id="2-响应性基础"><a href="#2-响应性基础" class="headerlink" title="2. 响应性基础"></a>2. 响应性基础</h2><h3 id="2-1-声明响应式状态"><a href="#2-1-声明响应式状态" class="headerlink" title="2.1 声明响应式状态"></a>2.1 声明响应式状态</h3><p>要为 JavaScript 对象创建响应式状态，可以使用 <code>reactive</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应式状态</span></span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>reactive</code> 相当于 Vue 2.x 中的 <code>Vue.observable()</code> API，为避免与 RxJS 中的 observables 混淆因此对其重命名。该 API 返回一个响应式的对象状态。该响应式转换是“深度转换”——它会影响传递对象的所有嵌套 property。</p>
<p>Vue 中响应式状态的基本用例是我们可以在渲染期间使用它。因为依赖跟踪的关系，当响应式状态改变时视图会自动更新。</p>
<p>这就是 Vue 响应性系统的本质。当从组件中的 <code>data()</code> 返回一个对象时，它在内部交由 <code>reactive()</code> 使其成为响应式对象。模板会被编译成能够使用这些响应式 property 的<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/render-function.html">渲染函数</a>。</p>
<p>在<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/basic-reactivity.html">响应性基础 API</a> 章节你可以学习更多关于 <code>reactive</code> 的内容。</p>
<h3 id="2-2-创建独立的响应式值作为-refs"><a href="#2-2-创建独立的响应式值作为-refs" class="headerlink" title="2.2 创建独立的响应式值作为 refs"></a>2.2 创建独立的响应式值作为 <code>refs</code></h3><p>想象一下，我们有一个独立的原始值 (例如，一个字符串)，我们想让它变成响应式的。当然，我们可以创建一个拥有相同字符串 property 的对象，并将其传递给 <code>reactive</code>。Vue 为我们提供了一个可以做相同事情的方法——<code>ref</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><code>ref</code> 会返回一个可变的响应式对象，该对象作为一个<strong>响应式的引用</strong>维护着它内部的值，这就是 <code>ref</code> 名称的来源。该对象只包含一个名为 <code>value</code> 的 property：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">count.<span class="property">value</span>++</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-1-Ref解包"><a href="#2-2-1-Ref解包" class="headerlink" title="2.2.1 Ref解包"></a>2.2.1 Ref解包</h4><p>当 ref 作为渲染上下文 (从 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/composition-api-setup.html">setup()</a> 中返回的对象) 上的 property 返回并可以在模板中被访问时，它将自动浅层次解包内部值。只有访问嵌套的 ref 时需要在模板中添加 <code>.value</code>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count ++&quot;</span>&gt;</span>Increment count<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;nested.count.value ++&quot;</span>&gt;</span>Nested Increment count<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        count,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">nested</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">          count</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你不想要访问实际的对象实例，可将其用 <code>reactive</code> 包裹:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nested</span>: <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  count</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-访问响应式对象"><a href="#2-2-2-访问响应式对象" class="headerlink" title="2.2.2 访问响应式对象"></a>2.2.2 访问响应式对象</h4><p>当 <code>ref</code> 作为响应式对象的 property 被访问或更改时，为使其行为类似于普通 property，它会自动解包内部值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  count</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">count</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">state.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>如果将新的 ref 赋值给现有 ref 的 property，将会替换旧的 ref：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> otherCount = <span class="title function_">ref</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">state.<span class="property">count</span> = otherCount</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">count</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>Ref 解包仅发生在被响应式 <code>Object</code> 嵌套的时候。当从 <code>Array</code> 或原生集合类型如 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"><code>Map</code></a>访问 ref 时，不会进行解包：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> books = <span class="title function_">reactive</span>([<span class="title function_">ref</span>(<span class="string">&#x27;Vue 3 Guide&#x27;</span>)])</span><br><span class="line"><span class="comment">// 这里需要 .value</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(books[<span class="number">0</span>].<span class="property">value</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="title function_">reactive</span>(<span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&#x27;count&#x27;</span>, <span class="title function_">ref</span>(<span class="number">0</span>)]]))</span><br><span class="line"><span class="comment">// 这里需要 .value</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(<span class="string">&#x27;count&#x27;</span>).<span class="property">value</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-3-响应式状态结构"><a href="#2-3-响应式状态结构" class="headerlink" title="2.3 响应式状态结构"></a>2.3 响应式状态结构</h3><p>当我们想使用大型响应式对象的一些 property 时，可能很想使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">ES6 解构</a>来获取我们想要的 property：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> book = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">author</span>: <span class="string">&#x27;Vue Team&#x27;</span>,</span><br><span class="line">  <span class="attr">year</span>: <span class="string">&#x27;2020&#x27;</span>,</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;Vue 3 Guide&#x27;</span>,</span><br><span class="line">  <span class="attr">description</span>: <span class="string">&#x27;You are reading this book right now ;)&#x27;</span>,</span><br><span class="line">  <span class="attr">price</span>: <span class="string">&#x27;free&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; author, title &#125; = book</span><br></pre></td></tr></table></figure>

<p>遗憾的是，使用解构的两个 property 的响应性都会丢失。对于这种情况，我们需要将我们的响应式对象转换为一组 ref。这些 ref 将保留与源对象的响应式关联：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> book = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">author</span>: <span class="string">&#x27;Vue Team&#x27;</span>,</span><br><span class="line">  <span class="attr">year</span>: <span class="string">&#x27;2020&#x27;</span>,</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;Vue 3 Guide&#x27;</span>,</span><br><span class="line">  <span class="attr">description</span>: <span class="string">&#x27;You are reading this book right now ;)&#x27;</span>,</span><br><span class="line">  <span class="attr">price</span>: <span class="string">&#x27;free&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; author, title &#125; = <span class="title function_">toRefs</span>(book)</span><br><span class="line"></span><br><span class="line">title.<span class="property">value</span> = <span class="string">&#x27;Vue 3 Detailed Guide&#x27;</span> <span class="comment">// 我们需要使用 .value 作为标题，现在是 ref</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(book.<span class="property">title</span>) <span class="comment">// &#x27;Vue 3 Detailed Guide&#x27;</span></span><br></pre></td></tr></table></figure>

<p>你可以在 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/refs-api.html#ref">Refs API</a> 部分中了解更多有关 <code>refs</code> 的信息</p>
<h3 id="2-4-使用-readonly-防止更改响应式对象"><a href="#2-4-使用-readonly-防止更改响应式对象" class="headerlink" title="2.4 使用 readonly 防止更改响应式对象"></a>2.4 使用 <code>readonly</code> 防止更改响应式对象</h3><p>有时我们想跟踪响应式对象 (<code>ref</code> 或 <code>reactive</code>) 的变化，但我们也希望防止在应用程序的某个位置更改它。例如，当我们有一个被 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/component-provide-inject.html">provide</a> 的响应式对象时，我们不想让它在注入之后被改变。为此，我们可以基于原始对象创建一个只读的 proxy 对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, readonly &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> original = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> copy = <span class="title function_">readonly</span>(original)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 original 修改 count，将会触发依赖 copy 的侦听器</span></span><br><span class="line"></span><br><span class="line">original.<span class="property">count</span>++</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 copy 修改 count，将导致失败并出现警告</span></span><br><span class="line">copy.<span class="property">count</span>++ <span class="comment">// 警告: &quot;Set operation on key &#x27;count&#x27; failed: target is readonly.&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-响应式计算和侦听"><a href="#3-响应式计算和侦听" class="headerlink" title="3. 响应式计算和侦听"></a>3. 响应式计算和侦听</h2><h3 id="3-1-计算值"><a href="#3-1-计算值" class="headerlink" title="3.1 计算值"></a>3.1 计算值</h3><p>有时我们需要依赖于其他状态的状态——在 Vue 中，这是用组件<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8">计算属性</a>处理的，以直接创建计算值，我们可以使用 <code>computed</code> 函数：它接受 getter 函数并为 getter 返回的值返回一个不可变的响应式 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/reactivity-fundamentals.html#%E5%88%9B%E5%BB%BA%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%80%BC%E4%BD%9C%E4%B8%BA-refs">ref</a> 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> plusOne = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> count.<span class="property">value</span> + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(plusOne.<span class="property">value</span>) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">plusOne.<span class="property">value</span>++ <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>或者，它可以使用一个带有 <code>get</code> 和 <code>set</code> 函数的对象来创建一个可写的 ref 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> plusOne = <span class="title function_">computed</span>(&#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function">() =&gt;</span> count.<span class="property">value</span> + <span class="number">1</span>,</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    count.<span class="property">value</span> = val - <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">plusOne.<span class="property">value</span> = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h4 id="3-1-1-调试Computed"><a href="#3-1-1-调试Computed" class="headerlink" title="3.1.1 调试Computed"></a>3.1.1 调试Computed</h4><p><code>computed</code> 可接受一个带有 <code>onTrack</code> 和 <code>onTrigger</code> 选项的对象作为第二个参数：</p>
<ul>
<li><code>onTrack</code> 会在某个响应式 property 或 ref 作为依赖被追踪时调用。</li>
<li><code>onTrigger</code> 会在侦听回调被某个依赖的修改触发时调用。</li>
</ul>
<p>所有回调都会收到一个 debugger 事件，其中包含了一些依赖相关的信息。推荐在这些回调内放置一个 <code>debugger</code> 语句以调试依赖。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> plusOne = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> count.<span class="property">value</span> + <span class="number">1</span>, &#123;</span><br><span class="line">  <span class="title function_">onTrack</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">// 当 count.value 作为依赖被追踪时触发</span></span><br><span class="line">    <span class="keyword">debugger</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">onTrigger</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">// 当 count.value 被修改时触发</span></span><br><span class="line">    <span class="keyword">debugger</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 访问 plusOne，应该触发 onTrack</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(plusOne.<span class="property">value</span>)</span><br><span class="line"><span class="comment">// 修改 count.value，应该触发 onTrigger</span></span><br><span class="line">count.<span class="property">value</span>++</span><br></pre></td></tr></table></figure>

<p><code>onTrack</code> 和 <code>onTrigger</code> 仅在开发模式下生效。</p>
<h3 id="3-2-watchEffect"><a href="#3-2-watchEffect" class="headerlink" title="3.2 watchEffect"></a>3.2 <code>watchEffect</code></h3><p>为了根据响应式状态<em>自动应用</em>和<em>重新应用</em>副作用，我们可以使用 <code>watchEffect</code> 函数。它立即执行传入的一个函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>))</span><br><span class="line"><span class="comment">// -&gt; logs 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  count.<span class="property">value</span>++</span><br><span class="line">  <span class="comment">// -&gt; logs 1</span></span><br><span class="line">&#125;, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h4 id="3-2-1-停止侦听"><a href="#3-2-1-停止侦听" class="headerlink" title="3.2.1 停止侦听"></a>3.2.1 停止侦听</h4><p>当 <code>watchEffect</code> 在组件的 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/composition-api-setup.html">setup()</a> 函数或<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/composition-api-lifecycle-hooks.html">生命周期钩子</a>被调用时，侦听器会被链接到该组件的生命周期，并在组件卸载时自动停止。</p>
<p>在一些情况下，也可以显式调用返回值以停止侦听：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stop = <span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// later</span></span><br><span class="line"><span class="title function_">stop</span>()</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-清除副作用"><a href="#3-2-2-清除副作用" class="headerlink" title="3.2.2 清除副作用"></a>3.2.2 清除副作用</h4><p>有时副作用函数会执行一些异步的副作用，这些响应需要在其失效时清除 (即完成之前状态已改变了) 。所以侦听副作用传入的函数可以接收一个 <code>onInvalidate</code> 函数作入参，用来注册清理失效时的回调。当以下情况发生时，这个失效回调会被触发：</p>
<ul>
<li>副作用即将重新执行时</li>
<li>侦听器被停止 (如果在 <code>setup()</code> 或生命周期钩子函数中使用了 <code>watchEffect</code>，则在组件卸载时)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watchEffect</span>(<span class="function"><span class="params">onInvalidate</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> token = <span class="title function_">performAsyncOperation</span>(id.<span class="property">value</span>)</span><br><span class="line">  <span class="title function_">onInvalidate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// id has changed or watcher is stopped.</span></span><br><span class="line">    <span class="comment">// invalidate previously pending async operation</span></span><br><span class="line">    token.<span class="title function_">cancel</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我们之所以是通过传入一个函数去注册失效回调，而不是从回调返回它，是因为返回值对于异步错误处理很重要。</p>
<p>在执行数据请求时，副作用函数往往是一个异步函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="keyword">async</span> onInvalidate =&gt; &#123;</span><br><span class="line">  <span class="title function_">onInvalidate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;) <span class="comment">// 我们在Promise解析之前注册清除函数</span></span><br><span class="line">  data.<span class="property">value</span> = <span class="keyword">await</span> <span class="title function_">fetchData</span>(props.<span class="property">id</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我们知道异步函数都会隐式地返回一个 Promise，但是清理函数必须要在 Promise 被 resolve 之前被注册。另外，Vue 依赖这个返回的 Promise 来自动处理 Promise 链上的潜在错误。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gjbegjbe.github.io/2022/07/20/HBuilder%E4%B8%AD%E7%9A%84%E5%B7%B2%E6%9C%89%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E5%88%B0%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%B8%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gjbe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gjbe">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/20/HBuilder%E4%B8%AD%E7%9A%84%E5%B7%B2%E6%9C%89%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E5%88%B0%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%B8%AD/" class="post-title-link" itemprop="url">HBuilder中的已有项目如何运行到微信开发者工具中</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-20 11:47:50 / 修改时间：13:53:31" itemprop="dateCreated datePublished" datetime="2022-07-20T11:47:50+08:00">2022-07-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p>从git上clone项目，在HBuilder直接打开，其他IDE先不要打开。</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202207201150336.png"></p>
</li>
<li><p>在HBuilder工具中-配置微信开发者安装路径 【工具–设置】</p>
<p><img src="https://img-blog.csdnimg.cn/20210204175349746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTMwMDk0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>微信小程序打开服务端口，不要打开此项目</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202207201343409.png"></p>
</li>
<li><p>HBuilder配置小程序id</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202207201348953.png"></p>
</li>
<li><p>点击运行到微信开发者工具，自动启动微信开发者工具</p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202207201350734.png"></p>
<p><img src="https://raw.githubusercontent.com/gjbegjbe/pics/main/202207201352354.png"></p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gjbegjbe.github.io/2022/07/12/Vue%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%92%8C%E7%BB%84%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gjbe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gjbe">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/12/Vue%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E5%8F%AF%E5%A4%8D%E7%94%A8%E5%92%8C%E7%BB%84%E5%90%88/" class="post-title-link" itemprop="url">Vue学习（四）——可复用和组合</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-12 10:41:16" itemprop="dateCreated datePublished" datetime="2022-07-12T10:41:16+08:00">2022-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-19 14:00:56" itemprop="dateModified" datetime="2022-07-19T14:00:56+08:00">2022-07-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、组合式API"><a href="#一、组合式API" class="headerlink" title="一、组合式API"></a>一、组合式API</h1><h2 id="1-什么是组合式API？"><a href="#1-什么是组合式API？" class="headerlink" title="1. 什么是组合式API？"></a>1. 什么是组合式API？</h2><p>通过创建 Vue 组件，我们可以将界面中重复的部分连同其功能一起提取为可重用的代码段。仅此一项就可以使我们的应用在可维护性和灵活性方面走得相当远。然而，我们的经验已经证明，光靠这一点可能并不够，尤其是当你的应用变得非常大的时候——想想几百个组件。处理这样的大型应用时，共享和重用代码变得尤为重要。</p>
<p>假设我们的应用中有一个显示某个用户的仓库列表的视图。此外，我们还希望有搜索和筛选功能。实现此视图组件的代码可能如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// src/components/UserRepositories.vue</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123; RepositoriesFilters, RepositoriesSortBy, RepositoriesList &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    user: &#123; </span><br><span class="line">      type: String,</span><br><span class="line">      required: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      repositories: [], // 1</span><br><span class="line">      filters: &#123; ... &#125;, // 3</span><br><span class="line">      searchQuery: &#x27;&#x27; // 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    filteredRepositories () &#123; ... &#125;, // 3</span><br><span class="line">    repositoriesMatchingSearchQuery () &#123; ... &#125;, // 2</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    user: &#x27;getUserRepositories&#x27; // 1</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getUserRepositories () &#123;</span><br><span class="line">      // 使用 `this.user` 获取用户仓库</span><br><span class="line">    &#125;, // 1</span><br><span class="line">    updateFilters () &#123; ... &#125;, // 3</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    this.getUserRepositories() // 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该组件有以下几个职责：</p>
<ol>
<li>从假定的外部 API 获取该用户的仓库，并在用户有任何更改时进行刷新</li>
<li>使用 <code>searchQuery</code> 字符串搜索仓库</li>
<li>使用 <code>filters</code> 对象筛选仓库</li>
</ol>
<p>使用 (<code>data</code>、<code>computed</code>、<code>methods</code>、<code>watch</code>) 组件选项来组织逻辑通常都很有效。然而，当我们的组件开始变得更大时，<strong>逻辑关注点</strong>的列表也会增长。尤其对于那些一开始没有编写这些组件的人来说，这会导致组件难以阅读和理解。</p>
<p><img src="https://v3.cn.vuejs.org/images/options-api.png" alt="Vue 选项式 API: 按选项类型分组的代码"></p>
<p>这是一个大型组件的示例，其中<strong>逻辑关注点</strong>按颜色进行分组。</p>
<p>这种碎片化使得理解和维护复杂组件变得困难。选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块。</p>
<p>如果能够将同一个逻辑关注点相关代码收集在一起会更好。而这正是组合式 API 使我们能够做到的。</p>
<h2 id="2-组合式API基础"><a href="#2-组合式API基础" class="headerlink" title="2. 组合式API基础"></a>2. 组合式API基础</h2><p>为了开始使用组合式 API，我们首先需要一个可以实际使用它的地方。在 Vue 组件中，我们将此位置称为 <code>setup</code>。</p>
<h3 id="2-1-setup-组件选项"><a href="#2-1-setup-组件选项" class="headerlink" title="2.1  setup 组件选项"></a>2.1  <code>setup</code> 组件选项</h3><p>新的 <code>setup</code> 选项在组件被创建<strong>之前</strong>执行，一旦 <code>props</code> 被解析完成，它就将被作为组合式 API 的入口。</p>
<p>在 <code>setup</code> 中你应该避免使用 <code>this</code>，因为它不会找到组件实例。<code>setup</code> 的调用发生在 <code>data</code> property、<code>computed</code> property 或 <code>methods</code> 被解析之前，所以它们无法在 <code>setup</code> 中被获取。</p>
<p><code>setup</code> 选项是一个接收 <code>props</code> 和 <code>context</code> 的函数。此外，我们将 <code>setup</code> 返回的所有内容都暴露给组件的其余部分 (计算属性、方法、生命周期钩子等等) 以及组件的模板。</p>
<p>把 <code>setup</code> 添加到组件中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// src/components/UserRepositories.vue</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123; RepositoriesFilters, RepositoriesSortBy, RepositoriesList &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    user: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      required: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    console.log(props) // &#123; user: &#x27;&#x27; &#125;</span><br><span class="line"></span><br><span class="line">    return &#123;&#125; // 这里返回的任何内容都可以用于组件的其余部分</span><br><span class="line">  &#125;</span><br><span class="line">  // 组件的“其余部分”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在让我们从提取第一个逻辑关注点开始 (在原始代码段中标记为“1”)。</p>
<blockquote>
<ol>
<li>从假定的外部 API 获取该用户的仓库，并在用户有任何更改时进行刷新</li>
</ol>
</blockquote>
<p>我们将从最明显的部分开始：</p>
<ul>
<li>仓库列表</li>
<li>更新仓库列表的函数</li>
<li>返回列表和函数，以便其他组件选项可以对它们进行访问</li>
</ul>
<h3 id="2-2-带-ref-的响应式变量"><a href="#2-2-带-ref-的响应式变量" class="headerlink" title="2.2 带 ref 的响应式变量"></a>2.2 带 <code>ref</code> 的响应式变量</h3><p>在 Vue 3.0 中，我们可以通过一个新的 <code>ref</code> 函数使任何响应式变量在任何地方起作用，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><code>ref</code> 接收参数并将其包裹在一个带有 <code>value</code> property 的对象中返回，然后可以使用该 property 访问或更改响应式变量的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter) <span class="comment">// &#123; value: 0 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter.<span class="property">value</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">counter.<span class="property">value</span>++</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter.<span class="property">value</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>将值封装在一个对象中，看似没有必要，但为了保持 JavaScript 中不同数据类型的行为统一，这是必须的。这是因为在 JavaScript 中，<code>Number</code> 或 <code>String</code> 等基本类型是通过值而非引用传递的：</p>
<p><img src="https://blog.penjee.com/wp-content/uploads/2015/02/pass-by-reference-vs-pass-by-value-animation.gif" alt="按引用传递与按值传递"></p>
<p>在任何值周围都有一个封装对象，这样我们就可以在整个应用中安全地传递它，而不必担心在某个地方失去它的响应性。</p>
<p>换句话说，<code>ref</code> 为我们的值创建了一个<strong>响应式引用</strong>。在整个组合式 API 中会经常使用<strong>引用</strong>的概念。</p>
<p>现在，每当我们调用 <code>getUserRepositories</code> 时，<code>repositories</code> 都将发生变化，视图也会更新以反映变化。我们的组件现在应该如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/components/UserRepositories.vue</span></span><br><span class="line"><span class="keyword">import</span> &#123; fetchUserRepositories &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/repositories&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123; <span class="title class_">RepositoriesFilters</span>, <span class="title class_">RepositoriesSortBy</span>, <span class="title class_">RepositoriesList</span> &#125;,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">user</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  setup (props) &#123;</span><br><span class="line">    <span class="keyword">const</span> repositories = <span class="title function_">ref</span>([])</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">getUserRepositories</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      repositories.<span class="property">value</span> = <span class="keyword">await</span> <span class="title function_">fetchUserRepositories</span>(props.<span class="property">user</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      repositories,</span><br><span class="line">      getUserRepositories</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">filters</span>: &#123; ... &#125;, <span class="comment">// 3</span></span><br><span class="line">      <span class="attr">searchQuery</span>: <span class="string">&#x27;&#x27;</span> <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    filteredRepositories () &#123; ... &#125;, <span class="comment">// 3</span></span><br><span class="line">    repositoriesMatchingSearchQuery () &#123; ... &#125;, <span class="comment">// 2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">user</span>: <span class="string">&#x27;getUserRepositories&#x27;</span> <span class="comment">// 1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    updateFilters () &#123; ... &#125;, <span class="comment">// 3</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getUserRepositories</span>() <span class="comment">// 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们已经将第一个逻辑关注点中的几个部分移到了 <code>setup</code> 方法中，它们彼此非常接近。剩下的就是在 <code>mounted</code> 钩子中调用 <code>getUserRepositories</code>，并设置一个监听器，以便在 <code>user</code> prop 发生变化时执行此操作。</p>
<p>我们将从生命周期钩子开始。</p>
<h3 id="2-3-在-setup-内注册生命周期钩子"><a href="#2-3-在-setup-内注册生命周期钩子" class="headerlink" title="2.3 在 setup 内注册生命周期钩子"></a>2.3 在 <code>setup</code> 内注册生命周期钩子</h3><p>为了使组合式 API 的功能和选项式 API 一样完整，我们还需要一种在 <code>setup</code> 中注册生命周期钩子的方法。这要归功于 Vue 导出的几个新函数。组合式 API 上的生命周期钩子与选项式 API 的名称相同，但前缀为 <code>on</code>：即 <code>mounted</code> 看起来会像 <code>onMounted</code>。</p>
<p>这些函数接受一个回调，当钩子被组件调用时，该回调将被执行。</p>
<p>让我们将其添加到 <code>setup</code> 函数中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/components/UserRepositories.vue `setup` function</span></span><br><span class="line"><span class="keyword">import</span> &#123; fetchUserRepositories &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/repositories&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在我们的组件中</span></span><br><span class="line">setup (props) &#123;</span><br><span class="line">  <span class="keyword">const</span> repositories = <span class="title function_">ref</span>([])</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getUserRepositories</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    repositories.<span class="property">value</span> = <span class="keyword">await</span> <span class="title function_">fetchUserRepositories</span>(props.<span class="property">user</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onMounted</span>(getUserRepositories) <span class="comment">// 在 `mounted` 时调用 `getUserRepositories`</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    repositories,</span><br><span class="line">    getUserRepositories</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们需要对 <code>user</code> prop 的变化做出反应。为此，我们将使用独立的 <code>watch</code> 函数。</p>
<h3 id="2-4-watch-响应式更改"><a href="#2-4-watch-响应式更改" class="headerlink" title="2.4 watch 响应式更改"></a>2.4 <code>watch</code> 响应式更改</h3><p>就像我们在组件中使用 <code>watch</code> 选项并在 <code>user</code> property 上设置侦听器一样，我们也可以使用从 Vue 导入的 <code>watch</code> 函数执行相同的操作。它接受 3 个参数：</p>
<ul>
<li>一个想要侦听的<strong>响应式引用</strong>或 getter 函数</li>
<li>一个回调</li>
<li>可选的配置选项</li>
</ul>
<p><strong>下面让我们快速了解一下它是如何工作的</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"><span class="title function_">watch</span>(counter, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;The new counter value is: &#x27;</span> + counter.<span class="property">value</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>每当 <code>counter</code> 被修改时，例如 <code>counter.value=5</code>，侦听将触发并执行回调 (第二个参数)，在本例中，它将把 <code>&#39;The new counter value is:5&#39;</code> 记录到控制台中</p>
<p><strong>以下是等效的选项式 API：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">counter</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="title function_">counter</span>(<span class="params">newValue, oldValue</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;The new counter value is: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">counter</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关 <code>watch</code> 的详细信息，请参阅我们的<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/reactivity-computed-watchers.html#watch">深入指南</a>。</p>
<p><strong>现在我们将其应用到我们的示例中：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/components/UserRepositories.vue `setup` function</span></span><br><span class="line"><span class="keyword">import</span> &#123; fetchUserRepositories &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/repositories&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, onMounted, watch, toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在我们组件中</span></span><br><span class="line">setup (props) &#123;</span><br><span class="line">  <span class="comment">// 使用 `toRefs` 创建对 `props` 中的 `user` property 的响应式引用</span></span><br><span class="line">  <span class="keyword">const</span> &#123; user &#125; = <span class="title function_">toRefs</span>(props)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> repositories = <span class="title function_">ref</span>([])</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getUserRepositories</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 更新 `prop.user` 到 `user.value` 访问引用值</span></span><br><span class="line">    repositories.<span class="property">value</span> = <span class="keyword">await</span> <span class="title function_">fetchUserRepositories</span>(user.<span class="property">value</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onMounted</span>(getUserRepositories)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在 user prop 的响应式引用上设置一个侦听器</span></span><br><span class="line">  <span class="title function_">watch</span>(user, getUserRepositories)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    repositories,</span><br><span class="line">    getUserRepositories</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能已经注意到在我们的 <code>setup</code> 的顶部使用了 <code>toRefs</code>。这是为了确保我们的侦听器能够根据 <code>user</code> prop 的变化做出反应。</p>
<p>有了这些变化，我们就把第一个逻辑关注点移到了一个地方。我们现在可以对第二个关注点执行相同的操作——基于 <code>searchQuery</code> 进行过滤，这次是使用计算属性。</p>
<h3 id="2-5-独立的-computed-属性"><a href="#2-5-独立的-computed-属性" class="headerlink" title="2.5 独立的 computed 属性"></a>2.5 独立的 <code>computed</code> 属性</h3><p>与 <code>ref</code> 和 <code>watch</code> 类似，也可以使用从 Vue 导入的 <code>computed</code> 函数在 Vue 组件外部创建计算属性。让我们回到 counter 的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> twiceTheCounter = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> counter.<span class="property">value</span> * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">counter.<span class="property">value</span>++</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter.<span class="property">value</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(twiceTheCounter.<span class="property">value</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>这里我们给 <code>computed</code> 函数传递了第一个参数，它是一个类似 getter 的回调函数，输出的是一个<em>只读</em>的<strong>响应式引用</strong>。为了访问新创建的计算变量的 <strong>value</strong>，我们需要像 <code>ref</code> 一样使用 <code>.value</code> property。</p>
<p>让我们将搜索功能移到 <code>setup</code> 中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/components/UserRepositories.vue `setup` function</span></span><br><span class="line"><span class="keyword">import</span> &#123; fetchUserRepositories &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/repositories&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, onMounted, watch, toRefs, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在我们的组件中</span></span><br><span class="line">setup (props) &#123;</span><br><span class="line">  <span class="comment">// 使用 `toRefs` 创建对 props 中的 `user` property 的响应式引用</span></span><br><span class="line">  <span class="keyword">const</span> &#123; user &#125; = <span class="title function_">toRefs</span>(props)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> repositories = <span class="title function_">ref</span>([])</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getUserRepositories</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 更新 `props.user ` 到 `user.value` 访问引用值</span></span><br><span class="line">    repositories.<span class="property">value</span> = <span class="keyword">await</span> <span class="title function_">fetchUserRepositories</span>(user.<span class="property">value</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onMounted</span>(getUserRepositories)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在 user prop 的响应式引用上设置一个侦听器</span></span><br><span class="line">  <span class="title function_">watch</span>(user, getUserRepositories)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> searchQuery = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> repositoriesMatchingSearchQuery = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> repositories.<span class="property">value</span>.<span class="title function_">filter</span>(</span><br><span class="line">      <span class="function"><span class="params">repository</span> =&gt;</span> repository.<span class="property">name</span>.<span class="title function_">includes</span>(searchQuery.<span class="property">value</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    repositories,</span><br><span class="line">    getUserRepositories,</span><br><span class="line">    searchQuery,</span><br><span class="line">    repositoriesMatchingSearchQuery</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于其他的<strong>逻辑关注点</strong>我们也可以这样做，但是你可能已经在问这个问题了——<em>这不就是把代码移到 <code>setup</code> 选项并使它变得非常大吗</em>？嗯，确实是这样的。这就是为什么我们要在继续其他任务之前，我们首先要将上述代码提取到一个独立的<strong>组合式函数</strong>中。让我们从创建 <code>useUserRepositories</code> 函数开始：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/composables/useUserRepositories.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; fetchUserRepositories &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/repositories&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, onMounted, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">useUserRepositories</span>(<span class="params">user</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> repositories = <span class="title function_">ref</span>([])</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getUserRepositories</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    repositories.<span class="property">value</span> = <span class="keyword">await</span> <span class="title function_">fetchUserRepositories</span>(user.<span class="property">value</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onMounted</span>(getUserRepositories)</span><br><span class="line">  <span class="title function_">watch</span>(user, getUserRepositories)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    repositories,</span><br><span class="line">    getUserRepositories</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是搜索功能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/composables/useRepositoryNameSearch.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">useRepositoryNameSearch</span>(<span class="params">repositories</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> searchQuery = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> repositoriesMatchingSearchQuery = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> repositories.<span class="property">value</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">repository</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> repository.<span class="property">name</span>.<span class="title function_">includes</span>(searchQuery.<span class="property">value</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    searchQuery,</span><br><span class="line">    repositoriesMatchingSearchQuery</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>现在我们有了两个单独的功能模块，接下来就可以开始在组件中使用它们了。以下是如何做到这一点：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/components/UserRepositories.vue</span></span><br><span class="line"><span class="keyword">import</span> useUserRepositories <span class="keyword">from</span> <span class="string">&#x27;@/composables/useUserRepositories&#x27;</span></span><br><span class="line"><span class="keyword">import</span> useRepositoryNameSearch <span class="keyword">from</span> <span class="string">&#x27;@/composables/useRepositoryNameSearch&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123; <span class="title class_">RepositoriesFilters</span>, <span class="title class_">RepositoriesSortBy</span>, <span class="title class_">RepositoriesList</span> &#125;,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">user</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  setup (props) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; user &#125; = <span class="title function_">toRefs</span>(props)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; repositories, getUserRepositories &#125; = <span class="title function_">useUserRepositories</span>(user)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      searchQuery,</span><br><span class="line">      repositoriesMatchingSearchQuery</span><br><span class="line">    &#125; = <span class="title function_">useRepositoryNameSearch</span>(repositories)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 因为我们并不关心未经过滤的仓库</span></span><br><span class="line">      <span class="comment">// 我们可以在 `repositories` 名称下暴露过滤后的结果</span></span><br><span class="line">      <span class="attr">repositories</span>: repositoriesMatchingSearchQuery,</span><br><span class="line">      getUserRepositories,</span><br><span class="line">      searchQuery,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">filters</span>: &#123; ... &#125;, <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    filteredRepositories () &#123; ... &#125;, <span class="comment">// 3</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    updateFilters () &#123; ... &#125;, <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，你可能已经知道了其中的奥妙，所以让我们跳到最后，迁移剩余的过滤功能。我们不需要深入了解实现细节，因为这并不是本指南的重点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/components/UserRepositories.vue</span></span><br><span class="line"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> useUserRepositories <span class="keyword">from</span> <span class="string">&#x27;@/composables/useUserRepositories&#x27;</span></span><br><span class="line"><span class="keyword">import</span> useRepositoryNameSearch <span class="keyword">from</span> <span class="string">&#x27;@/composables/useRepositoryNameSearch&#x27;</span></span><br><span class="line"><span class="keyword">import</span> useRepositoryFilters <span class="keyword">from</span> <span class="string">&#x27;@/composables/useRepositoryFilters&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123; <span class="title class_">RepositoriesFilters</span>, <span class="title class_">RepositoriesSortBy</span>, <span class="title class_">RepositoriesList</span> &#125;,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">user</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; user &#125; = <span class="title function_">toRefs</span>(props)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; repositories, getUserRepositories &#125; = <span class="title function_">useUserRepositories</span>(user)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      searchQuery,</span><br><span class="line">      repositoriesMatchingSearchQuery</span><br><span class="line">    &#125; = <span class="title function_">useRepositoryNameSearch</span>(repositories)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      filters,</span><br><span class="line">      updateFilters,</span><br><span class="line">      filteredRepositories</span><br><span class="line">    &#125; = <span class="title function_">useRepositoryFilters</span>(repositoriesMatchingSearchQuery)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 因为我们并不关心未经过滤的仓库</span></span><br><span class="line">      <span class="comment">// 我们可以在 `repositories` 名称下暴露过滤后的结果</span></span><br><span class="line">      <span class="attr">repositories</span>: filteredRepositories,</span><br><span class="line">      getUserRepositories,</span><br><span class="line">      searchQuery,</span><br><span class="line">      filters,</span><br><span class="line">      updateFilters</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只触及了组合式 API 的表面以及它允许我们做什么。要了解更多信息，请参阅深入指南。</p>
<h2 id="2-Setup"><a href="#2-Setup" class="headerlink" title="2. Setup"></a>2. Setup</h2><h3 id="2-1-参数"><a href="#2-1-参数" class="headerlink" title="2.1 参数"></a>2.1 参数</h3><p>使用 <code>setup</code> 函数时，它将接收两个参数：</p>
<ol>
<li><code>props</code></li>
<li><code>context</code></li>
</ol>
<p>让我们更深入地研究如何使用每个参数。</p>
<h4 id="2-1-1-Props"><a href="#2-1-1-Props" class="headerlink" title="2.1.1 Props"></a>2.1.1 Props</h4><p><code>setup</code> 函数中的第一个参数是 <code>props</code>。正如在一个标准组件中所期望的那样，<code>setup</code> 函数中的 <code>props</code> 是响应式的，当传入新的 prop 时，它将被更新。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyBook.vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="title class_">String</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="property">title</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>props</code> 是响应式的，你<strong>不能使用 ES6 解构</strong>，它会消除 prop 的响应性。</p>
<p>如果需要解构 prop，可以在 <code>setup</code> 函数中使用 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/reactivity-fundamentals.html#%E5%93%8D%E5%BA%94%E5%BC%8F%E7%8A%B6%E6%80%81%E8%A7%A3%E6%9E%84"><code>toRefs</code></a> 函数来完成此操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyBook.vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">setup</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; title &#125; = <span class="title function_">toRefs</span>(props)</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(title.<span class="property">value</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>title</code> 是可选的 prop，则传入的 <code>props</code> 中可能没有 <code>title</code> 。在这种情况下，<code>toRefs</code> 将不会为 <code>title</code> 创建一个 ref 。你需要使用 <code>toRef</code> 替代它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyBook.vue</span></span><br><span class="line"><span class="keyword">import</span> &#123; toRef &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="title function_">setup</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> title = <span class="title function_">toRef</span>(props, <span class="string">&#x27;title&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(title.<span class="property">value</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-Context"><a href="#2-1-2-Context" class="headerlink" title="2.1.2 Context"></a>2.1.2 Context</h4><p>传递给 <code>setup</code> 函数的第二个参数是 <code>context</code>。<code>context</code> 是一个普通 JavaScript 对象，暴露了其它可能在 <code>setup</code> 中有用的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyBook.vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">    <span class="comment">// Attribute (非响应式对象，等同于 $attrs)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(context.<span class="property">attrs</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插槽 (非响应式对象，等同于 $slots)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(context.<span class="property">slots</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件 (方法，等同于 $emit)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(context.<span class="property">emit</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴露公共 property (函数)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(context.<span class="property">expose</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>context</code> 是一个普通的 JavaScript 对象，也就是说，它不是响应式的，这意味着你可以安全地对 <code>context</code> 使用 ES6 解构。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyBook.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, &#123; attrs, slots, emit, expose &#125;</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>attrs</code> 和 <code>slots</code> 是有状态的对象，它们总是会随组件本身的更新而更新。这意味着你应该避免对它们进行解构，并始终以 <code>attrs.x</code> 或 <code>slots.x</code> 的方式引用 property。请注意，与 <code>props</code> 不同，<code>attrs</code> 和 <code>slots</code> 的 property 是<strong>非</strong>响应式的。如果你打算根据 <code>attrs</code> 或 <code>slots</code> 的更改应用副作用，那么应该在 <code>onBeforeUpdate</code> 生命周期钩子中执行此操作。</p>
<p>我们将在稍后解释 <code>expose</code> 所扮演的角色。</p>
<h3 id="2-2-访问组件的-property"><a href="#2-2-访问组件的-property" class="headerlink" title="2.2 访问组件的 property"></a>2.2 访问组件的 property</h3><p>执行 <code>setup</code> 时，你只能访问以下 property：</p>
<ul>
<li><code>props</code></li>
<li><code>attrs</code></li>
<li><code>slots</code></li>
<li><code>emit</code></li>
</ul>
<p>换句话说，你<strong>将无法访问</strong>以下组件选项：</p>
<ul>
<li><code>data</code></li>
<li><code>computed</code></li>
<li><code>methods</code></li>
<li><code>refs</code> (模板 ref)</li>
</ul>
<h3 id="2-3-结合模板使用"><a href="#2-3-结合模板使用" class="headerlink" title="2.3 结合模板使用"></a>2.3 结合模板使用</h3><p>如果 <code>setup</code> 返回一个对象，那么该对象的 property 以及传递给 <code>setup</code> 的 <code>props</code> 参数中的 property 就都可以在模板中访问到：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- <span class="title class_">MyBook</span>.<span class="property">vue</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; collectionName &#125;&#125;: &#123;&#123; readersNumber &#125;&#125; &#123;&#123; book.title &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123; ref, reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">props</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">collectionName</span>: <span class="title class_">String</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">setup</span>(<span class="params">props</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> readersNumber = <span class="title function_">ref</span>(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> book = <span class="title function_">reactive</span>(&#123; <span class="attr">title</span>: <span class="string">&#x27;Vue 3 Guide&#x27;</span> &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 暴露给 template</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        readersNumber,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        book</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>注意，从 <code>setup</code> 返回的 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/refs-api.html#ref">refs</a> 在模板中访问时是<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/reactivity-fundamentals.html#ref-%E8%A7%A3%E5%8C%85">被自动浅解包</a>的，因此不应在模板中使用 <code>.value</code>。</p>
<h3 id="2-4-使用渲染函数"><a href="#2-4-使用渲染函数" class="headerlink" title="2.4 使用渲染函数"></a>2.4 使用渲染函数</h3><p><code>setup</code> 还可以返回一个渲染函数，该函数可以直接使用在同一作用域中声明的响应式状态：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyBook.vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; h, ref, reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> readersNumber = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> book = <span class="title function_">reactive</span>(&#123; <span class="attr">title</span>: <span class="string">&#x27;Vue 3 Guide&#x27;</span> &#125;)</span><br><span class="line">    <span class="comment">// 请注意这里我们需要显式使用 ref 的 value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, [readersNumber.<span class="property">value</span>, book.<span class="property">title</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回一个渲染函数将阻止我们返回任何其它的东西。从内部来说这不应该成为一个问题，但当我们想要将这个组件的方法通过模板 ref 暴露给父组件时就不一样了。</p>
<p>我们可以通过调用 <code>expose</code> 来解决这个问题，给它传递一个对象，其中定义的 property 将可以被外部组件实例访问：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, &#123; expose &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; ++count.<span class="property">value</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">expose</span>(&#123;</span><br><span class="line">      increment</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, count.<span class="property">value</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 <code>increment</code> 方法现在将可以通过父组件的模板 ref 访问。</p>
<h3 id="2-5-使用-this"><a href="#2-5-使用-this" class="headerlink" title="2.5 使用 this"></a>2.5 使用 <code>this</code></h3><p><strong>在 <code>setup()</code> 内部，<code>this</code> 不是该活跃实例的引用</strong>，因为 <code>setup()</code> 是在解析其它组件选项之前被调用的，所以 <code>setup()</code> 内部的 <code>this</code> 的行为与其它选项中的 <code>this</code> 完全不同。这使得 <code>setup()</code> 在和其它选项式 API 一起使用时可能会导致混淆。</p>
<h2 id="3-生命周期钩子"><a href="#3-生命周期钩子" class="headerlink" title="3. 生命周期钩子"></a>3. 生命周期钩子</h2><p>你可以通过在生命周期钩子前面加上 “on” 来访问组件的生命周期钩子。</p>
<p>下表包含如何在 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/composition-api-setup.html">setup ()</a> 内部调用生命周期钩子：</p>
<table>
<thead>
<tr>
<th>选项式 API</th>
<th>Hook inside <code>setup</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>beforeCreate</code></td>
<td>Not needed*</td>
</tr>
<tr>
<td><code>created</code></td>
<td>Not needed*</td>
</tr>
<tr>
<td><code>beforeMount</code></td>
<td><code>onBeforeMount</code></td>
</tr>
<tr>
<td><code>mounted</code></td>
<td><code>onMounted</code></td>
</tr>
<tr>
<td><code>beforeUpdate</code></td>
<td><code>onBeforeUpdate</code></td>
</tr>
<tr>
<td><code>updated</code></td>
<td><code>onUpdated</code></td>
</tr>
<tr>
<td><code>beforeUnmount</code></td>
<td><code>onBeforeUnmount</code></td>
</tr>
<tr>
<td><code>unmounted</code></td>
<td><code>onUnmounted</code></td>
</tr>
<tr>
<td><code>errorCaptured</code></td>
<td><code>onErrorCaptured</code></td>
</tr>
<tr>
<td><code>renderTracked</code></td>
<td><code>onRenderTracked</code></td>
</tr>
<tr>
<td><code>renderTriggered</code></td>
<td><code>onRenderTriggered</code></td>
</tr>
<tr>
<td><code>activated</code></td>
<td><code>onActivated</code></td>
</tr>
<tr>
<td><code>deactivated</code></td>
<td><code>onDeactivated</code></td>
</tr>
</tbody></table>
<p>因为 <code>setup</code> 是围绕 <code>beforeCreate</code> 和 <code>created</code> 生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在 <code>setup</code> 函数中编写。</p>
<p>这些函数接受一个回调函数，当钩子被组件调用时将会被执行:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyBook.vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// mounted</span></span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component is mounted!&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Provide-x2F-Inject"><a href="#4-Provide-x2F-Inject" class="headerlink" title="4. Provide&#x2F;Inject"></a>4. Provide&#x2F;Inject</h2><p>我们也可以在组合式 API 中使用 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/component-provide-inject.html">provide&#x2F;inject</a>。两者都只能在当前活动实例的 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/composition-api-setup.html"><code>setup()</code></a> 期间调用。</p>
<h3 id="4-1-设想场景"><a href="#4-1-设想场景" class="headerlink" title="4.1 设想场景"></a>4.1 设想场景</h3><p>假设我们要重写以下代码，其中包含一个 <code>MyMap</code> 组件，该组件使用组合式 API 为 <code>MyMarker</code> 组件提供用户的位置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- src/components/<span class="title class_">MyMap</span>.<span class="property">vue</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">MyMarker</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">MyMarker</span> <span class="keyword">from</span> <span class="string">&#x27;./MyMarker.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title class_">MyMarker</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">provide</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">location</span>: <span class="string">&#x27;North Pole&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">geolocation</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">longitude</span>: <span class="number">90</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">latitude</span>: <span class="number">135</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- src/components/<span class="title class_">MyMarker</span>.<span class="property">vue</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">inject</span>: [<span class="string">&#x27;location&#x27;</span>, <span class="string">&#x27;geolocation&#x27;</span>]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-使用Provide"><a href="#4-2-使用Provide" class="headerlink" title="4.2 使用Provide"></a>4.2 使用Provide</h3><p>在 <code>setup()</code> 中使用 <code>provide</code> 时，我们首先从 <code>vue</code> 显式导入 <code>provide</code> 方法。这使我们能够调用 <code>provide</code> 来定义每个 property。</p>
<p><code>provide</code> 函数允许你通过两个参数定义 property：</p>
<ol>
<li>name (<code>&lt;String&gt;</code> 类型)</li>
<li>value</li>
</ol>
<p>使用 <code>MyMap</code> 组件后，provide 的值可以按如下方式重构：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- src/components/<span class="title class_">MyMap</span>.<span class="property">vue</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">MyMarker</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; provide &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">MyMarker</span> <span class="keyword">from</span> <span class="string">&#x27;./MyMarker.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title class_">MyMarker</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">provide</span>(<span class="string">&#x27;location&#x27;</span>, <span class="string">&#x27;North Pole&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">provide</span>(<span class="string">&#x27;geolocation&#x27;</span>, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">longitude</span>: <span class="number">90</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">latitude</span>: <span class="number">135</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-使用inject"><a href="#4-3-使用inject" class="headerlink" title="4.3 使用inject"></a>4.3 使用inject</h3><p>在 <code>setup()</code> 中使用 <code>inject</code> 时，也需要从 <code>vue</code> 显式导入。导入以后，我们就可以调用它来定义暴露给我们的组件方式。</p>
<p><code>inject</code> 函数有两个参数：</p>
<ol>
<li>要 inject 的 property 的 name</li>
<li>默认值 (<strong>可选</strong>)</li>
</ol>
<p>使用 <code>MyMarker</code> 组件，可以使用以下代码对其进行重构：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- src/components/<span class="title class_">MyMarker</span>.<span class="property">vue</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> userLocation = <span class="title function_">inject</span>(<span class="string">&#x27;location&#x27;</span>, <span class="string">&#x27;The Universe&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> userGeolocation = <span class="title function_">inject</span>(<span class="string">&#x27;geolocation&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      userLocation,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      userGeolocation</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-响应性"><a href="#4-4-响应性" class="headerlink" title="4.4 响应性"></a>4.4 响应性</h3><h4 id="4-4-1-添加响应性"><a href="#4-4-1-添加响应性" class="headerlink" title="4.4.1 添加响应性"></a>4.4.1 添加响应性</h4><p>为了增加 provide 值和 inject 值之间的响应性，我们可以在 provide 值时使用 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/reactivity-fundamentals.html#%E5%88%9B%E5%BB%BA%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%80%BC%E4%BD%9C%E4%B8%BA-refs">ref</a> 或 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/reactivity-fundamentals.html#%E5%A3%B0%E6%98%8E%E5%93%8D%E5%BA%94%E5%BC%8F%E7%8A%B6%E6%80%81">reactive</a>。</p>
<p>使用 <code>MyMap</code> 组件，我们的代码可以更新如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- src/components/<span class="title class_">MyMap</span>.<span class="property">vue</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">MyMarker</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; provide, reactive, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">MyMarker</span> <span class="keyword">from</span> <span class="string">&#x27;./MyMarker.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title class_">MyMarker</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> location = <span class="title function_">ref</span>(<span class="string">&#x27;North Pole&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> geolocation = <span class="title function_">reactive</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">longitude</span>: <span class="number">90</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">latitude</span>: <span class="number">135</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">provide</span>(<span class="string">&#x27;location&#x27;</span>, location)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">provide</span>(<span class="string">&#x27;geolocation&#x27;</span>, geolocation)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>现在，如果这两个 property 中有任何更改，<code>MyMarker</code> 组件也将自动更新！</p>
<h4 id="4-4-2-修改响应式property"><a href="#4-4-2-修改响应式property" class="headerlink" title="4.4.2 修改响应式property"></a>4.4.2 修改响应式property</h4><p>当使用响应式 provide &#x2F; inject 值时，<strong>建议尽可能将对响应式 property 的所有修改限制在<em>定义 provide 的组件</em>内部</strong>。</p>
<p>例如，在需要更改用户位置的情况下，我们最好在 <code>MyMap</code> 组件中执行此操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- src/components/<span class="title class_">MyMap</span>.<span class="property">vue</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">MyMarker</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; provide, reactive, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">MyMarker</span> <span class="keyword">from</span> <span class="string">&#x27;./MyMarker.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title class_">MyMarker</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> location = <span class="title function_">ref</span>(<span class="string">&#x27;North Pole&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> geolocation = <span class="title function_">reactive</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">longitude</span>: <span class="number">90</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">latitude</span>: <span class="number">135</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">provide</span>(<span class="string">&#x27;location&#x27;</span>, location)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">provide</span>(<span class="string">&#x27;geolocation&#x27;</span>, geolocation)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      location</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">updateLocation</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">location</span> = <span class="string">&#x27;South Pole&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>然而，有时我们需要在注入数据的组件内部更新 inject 的数据。在这种情况下，我们建议 provide 一个方法来负责改变响应式 property。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- src/components/<span class="title class_">MyMap</span>.<span class="property">vue</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">MyMarker</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; provide, reactive, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">MyMarker</span> <span class="keyword">from</span> <span class="string">&#x27;./MyMarker.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title class_">MyMarker</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> location = <span class="title function_">ref</span>(<span class="string">&#x27;North Pole&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> geolocation = <span class="title function_">reactive</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">longitude</span>: <span class="number">90</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">latitude</span>: <span class="number">135</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> <span class="title function_">updateLocation</span> = (<span class="params"></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      location.<span class="property">value</span> = <span class="string">&#x27;South Pole&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">provide</span>(<span class="string">&#x27;location&#x27;</span>, location)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">provide</span>(<span class="string">&#x27;geolocation&#x27;</span>, geolocation)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">provide</span>(<span class="string">&#x27;updateLocation&#x27;</span>, updateLocation)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- src/components/<span class="title class_">MyMarker</span>.<span class="property">vue</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> userLocation = <span class="title function_">inject</span>(<span class="string">&#x27;location&#x27;</span>, <span class="string">&#x27;The Universe&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> userGeolocation = <span class="title function_">inject</span>(<span class="string">&#x27;geolocation&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> updateUserLocation = <span class="title function_">inject</span>(<span class="string">&#x27;updateLocation&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      userLocation,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      userGeolocation,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      updateUserLocation</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>最后，如果要确保通过 <code>provide</code> 传递的数据不会被 inject 的组件更改，我们建议对提供者的 property 使用 <code>readonly</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- src/components/<span class="title class_">MyMap</span>.<span class="property">vue</span> --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">MyMarker</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; provide, reactive, readonly, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">MyMarker</span> <span class="keyword">from</span> <span class="string">&#x27;./MyMarker.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title class_">MyMarker</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> location = <span class="title function_">ref</span>(<span class="string">&#x27;North Pole&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> geolocation = <span class="title function_">reactive</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">longitude</span>: <span class="number">90</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">latitude</span>: <span class="number">135</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> <span class="title function_">updateLocation</span> = (<span class="params"></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      location.<span class="property">value</span> = <span class="string">&#x27;South Pole&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">provide</span>(<span class="string">&#x27;location&#x27;</span>, <span class="title function_">readonly</span>(location))</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">provide</span>(<span class="string">&#x27;geolocation&#x27;</span>, <span class="title function_">readonly</span>(geolocation))</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">provide</span>(<span class="string">&#x27;updateLocation&#x27;</span>, updateLocation)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="5-模板引用"><a href="#5-模板引用" class="headerlink" title="5. 模板引用"></a>5. 模板引用</h2><p>在使用组合式 API 时，<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/reactivity-fundamentals.html#%E5%88%9B%E5%BB%BA%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%80%BC%E4%BD%9C%E4%B8%BA-refs">响应式引用</a>和<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/component-template-refs.html">模板引用</a>的概念是统一的。为了获得对模板内元素或组件实例的引用，我们可以像往常一样声明 ref 并从 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/composition-api-setup.html">setup()</a> 返回：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&quot;root&quot;</span>&gt;</span>This is a root element<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; ref, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> root = <span class="title function_">ref</span>(<span class="literal">null</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// DOM 元素将在初始渲染后分配给 ref</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">value</span>) <span class="comment">// &lt;div&gt;This is a root element&lt;/div&gt;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        root</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里我们在渲染上下文中暴露 <code>root</code>，并通过 <code>ref=&quot;root&quot;</code>，将其绑定到 div 作为其 ref。在虚拟 DOM 补丁算法中，如果 VNode 的 <code>ref</code> 键对应于渲染上下文中的 ref，则 VNode 的相应元素或组件实例将被分配给该 ref 的值。这是在虚拟 DOM 挂载&#x2F;打补丁过程中执行的，因此模板引用只会在初始渲染之后获得赋值。</p>
<p>作为模板使用的 ref 的行为与任何其他 ref 一样：它们是响应式的，可以传递到 (或从中返回) 复合函数中。</p>
<h3 id="5-1-JSX中的用法"><a href="#5-1-JSX中的用法" class="headerlink" title="5.1 JSX中的用法"></a>5.1 JSX中的用法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> root = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span></span><br><span class="line">      <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">ref</span>: root</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with JSX</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;root&#125;</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-v-for-中的用法"><a href="#5-2-v-for-中的用法" class="headerlink" title="5.2 v-for 中的用法"></a>5.2 <code>v-for</code> 中的用法</h3><p>组合式 API 模板引用在 <code>v-for</code> 内部使用时没有特殊处理。相反，请使用函数引用执行自定义处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, i) in list&quot;</span> <span class="attr">:ref</span>=<span class="string">&quot;el =&gt; &#123; if (el) divs[i] = el &#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;&#123; item &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123; ref, reactive, onBeforeUpdate &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> list = <span class="title function_">reactive</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> divs = <span class="title function_">ref</span>([])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 确保在每次更新之前重置ref</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">onBeforeUpdate</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        divs.<span class="property">value</span> = []</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        list,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        divs</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="5-3-侦听模板引用"><a href="#5-3-侦听模板引用" class="headerlink" title="5.3 侦听模板引用"></a>5.3 侦听模板引用</h3><p>侦听模板引用的变更可以替代前面例子中演示使用的生命周期钩子。</p>
<p>但与生命周期钩子的一个关键区别是，<code>watch()</code> 和 <code>watchEffect()</code> 在 DOM 挂载或更新<em>之前</em>运行副作用，所以当侦听器运行时，模板引用还未被更新。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&quot;root&quot;</span>&gt;</span>This is a root element<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123; ref, watchEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> root = <span class="title function_">ref</span>(<span class="literal">null</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 这个副作用在 DOM 更新之前运行，因此，模板引用还没有持有对元素的引用。</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">value</span>) <span class="comment">// =&gt; null</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        root</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>因此，使用模板引用的侦听器应该用 <code>flush: &#39;post&#39;</code> 选项来定义，这将在 DOM 更新<em>后</em>运行副作用，确保模板引用与 DOM 保持同步，并引用正确的元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&quot;root&quot;</span>&gt;</span>This is a root element<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">import</span> &#123; ref, watchEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> root = <span class="title function_">ref</span>(<span class="literal">null</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">value</span>) <span class="comment">// =&gt; &lt;div&gt;This is a root element&lt;/div&gt;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">flush</span>: <span class="string">&#x27;post&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        root</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="二、Mixin"><a href="#二、Mixin" class="headerlink" title="二、Mixin"></a>二、Mixin</h1><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h2><p>Mixin 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个 mixin 对象可以包含任意组件选项。当组件使用 mixin 对象时，所有 mixin 对象的选项将被“混合”进入该组件本身的选项。</p>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个 mixin 对象</span></span><br><span class="line"><span class="keyword">const</span> myMixin = &#123;</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">hello</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello from mixin!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个使用此 mixin 对象的应用</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">  <span class="attr">mixins</span>: [myMixin]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#mixins-basic&#x27;</span>) <span class="comment">// =&gt; &quot;hello from mixin!&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-选项合并"><a href="#2-选项合并" class="headerlink" title="2. 选项合并"></a>2. 选项合并</h2><p>当组件和 mixin 对象含有同名选项时，这些选项将以恰当的方式进行“合并”。</p>
<p>比如，每个 mixin 可以拥有自己的 <code>data</code> 函数。每个 <code>data</code> 函数都会被调用，并将返回结果合并。在数据的 property 发生冲突时，会以组件自身的数据为优先。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMixin = &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">      <span class="attr">foo</span>: <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">  <span class="attr">mixins</span>: [myMixin],</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;goodbye&#x27;</span>,</span><br><span class="line">      <span class="attr">bar</span>: <span class="string">&#x27;def&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$data</span>) <span class="comment">// =&gt; &#123; message: &quot;goodbye&quot;, foo: &quot;abc&quot;, bar: &quot;def&quot; &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>同名钩子函数将合并为一个数组，因此都将被调用。另外，mixin 对象的钩子将在组件自身钩子<strong>之前</strong>调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMixin = &#123;</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;mixin 对象的钩子被调用&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">  <span class="attr">mixins</span>: [myMixin],</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;组件钩子被调用&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; &quot;mixin 对象的钩子被调用&quot;</span></span><br><span class="line"><span class="comment">// =&gt; &quot;组件钩子被调用&quot;</span></span><br></pre></td></tr></table></figure>

<p>值为对象的选项，例如 <code>methods</code>、<code>components</code> 和 <code>directives</code>，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMixin = &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">conflicting</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;from mixin&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">  <span class="attr">mixins</span>: [myMixin],</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">conflicting</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;from self&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = app.<span class="title function_">mount</span>(<span class="string">&#x27;#mixins-basic&#x27;</span>)</span><br><span class="line"></span><br><span class="line">vm.<span class="title function_">foo</span>() <span class="comment">// =&gt; &quot;foo&quot;</span></span><br><span class="line">vm.<span class="title function_">bar</span>() <span class="comment">// =&gt; &quot;bar&quot;</span></span><br><span class="line">vm.<span class="title function_">conflicting</span>() <span class="comment">// =&gt; &quot;from self&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-全局mixin"><a href="#3-全局mixin" class="headerlink" title="3. 全局mixin"></a>3. 全局mixin</h2><p>你还可以为 Vue 应用程序全局应用 mixin：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">  <span class="attr">myOption</span>: <span class="string">&#x27;hello!&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为自定义的选项 &#x27;myOption&#x27; 注入一个处理器。</span></span><br><span class="line">app.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> myOption = <span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">myOption</span></span><br><span class="line">    <span class="keyword">if</span> (myOption) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(myOption)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#mixins-global&#x27;</span>) <span class="comment">// =&gt; &quot;hello!&quot;</span></span><br></pre></td></tr></table></figure>

<p>Mixin 也可以进行全局注册。使用时格外小心！一旦使用全局 mixin，它将影响<strong>每一个</strong>之后创建的组件 (例如，每个子组件)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">  <span class="attr">myOption</span>: <span class="string">&#x27;hello!&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为自定义的选项 &#x27;myOption&#x27; 注入一个处理器。</span></span><br><span class="line">app.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> myOption = <span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">myOption</span></span><br><span class="line">    <span class="keyword">if</span> (myOption) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(myOption)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将myOption也添加到子组件</span></span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&#x27;test-component&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">myOption</span>: <span class="string">&#x27;hello from component!&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#mixins-global&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; &quot;hello!&quot;</span></span><br><span class="line"><span class="comment">// =&gt; &quot;hello from component!&quot;</span></span><br></pre></td></tr></table></figure>

<p>大多数情况下，只应当应用于自定义选项，就像上面示例一样。推荐将其作为<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/plugins.html">插件</a>发布，以避免重复应用 mixin。</p>
<h2 id="4-自定义选项合并策略"><a href="#4-自定义选项合并策略" class="headerlink" title="4. 自定义选项合并策略"></a>4. 自定义选项合并策略</h2><p>自定义选项在合并时，默认策略为简单地覆盖已有值。如果想让某个自定义选项以自定义逻辑进行合并，可以在 <code>app.config.optionMergeStrategies</code> 中添加一个函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="property">config</span>.<span class="property">optionMergeStrategies</span>.<span class="property">customOption</span> = <span class="function">(<span class="params">toVal, fromVal</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// return mergedVal</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合并策略接收在父实例和子实例上定义的该选项的值，分别作为第一个和第二个参数。让我们来检查一下使用 mixin 时，这些参数有哪些：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">  <span class="attr">custom</span>: <span class="string">&#x27;hello!&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="property">config</span>.<span class="property">optionMergeStrategies</span>.<span class="property">custom</span> = <span class="function">(<span class="params">toVal, fromVal</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(fromVal, toVal)</span><br><span class="line">  <span class="comment">// =&gt; &quot;goodbye!&quot;, undefined</span></span><br><span class="line">  <span class="comment">// =&gt; &quot;hello&quot;, &quot;goodbye!&quot;</span></span><br><span class="line">  <span class="keyword">return</span> fromVal || toVal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">  <span class="attr">custom</span>: <span class="string">&#x27;goodbye!&#x27;</span>,</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">custom</span>) <span class="comment">// =&gt; &quot;hello!&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如你所见，在控制台中，我们先从 mixin 打印 <code>toVal</code> 和 <code>fromVal</code>，然后从 <code>app</code> 打印。如果存在，我们总是返回 <code>fromVal</code>，这就是为什么 <code>this.$options.custom</code> 设置为 <code>hello!</code>。最后，让我们尝试将策略更改为优先返回<em>子实例</em>的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">  <span class="attr">custom</span>: <span class="string">&#x27;hello!&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="property">config</span>.<span class="property">optionMergeStrategies</span>.<span class="property">custom</span> = <span class="function">(<span class="params">toVal, fromVal</span>) =&gt;</span> toVal || fromVal</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">  <span class="attr">custom</span>: <span class="string">&#x27;goodbye!&#x27;</span>,</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">custom</span>) <span class="comment">// =&gt; &quot;goodbye!&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="5-不足"><a href="#5-不足" class="headerlink" title="5. 不足"></a>5. 不足</h2><p>在 Vue 2 中，mixin 是将部分组件逻辑抽象成可重用块的主要工具。但是，他们有几个问题：</p>
<ul>
<li><p>Mixin 很容易发生冲突：因为每个 mixin 的 property 都被合并到同一个组件中，所以为了避免 property 名冲突，你仍然需要了解其他每个特性。</p>
</li>
<li><p>可重用性是有限的：我们不能向 mixin 传递任何参数来改变它的逻辑，这降低了它们在抽象逻辑方面的灵活性。</p>
</li>
</ul>
<p>为了解决这些问题，我们添加了一种通过逻辑关注点组织代码的新方法：<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">组合式 API</a>。</p>
<h1 id="三、自定义指令"><a href="#三、自定义指令" class="headerlink" title="三、自定义指令"></a>三、自定义指令</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>除了核心功能默认内置的指令 (例如 <code>v-model</code> 和 <code>v-show</code>)，Vue 也允许注册自定义指令。注意，在 Vue 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。举个聚焦输入框的例子，如下：</p>
<p><img src="C:\Users\ThinkPad\AppData\Roaming\marktext\images\2022-07-12-16-41-03-image.png"></p>
<p>当页面加载时，该元素将获得焦点 (注意：<code>autofocus</code> 在移动版 Safari 上不工作)。事实上，如果你在打开这个页面后还没有点击过任何内容，那么此时这个输入框就应当处于聚焦状态。此外，你可以单击 <code>Rerun</code> 按钮，输入框将被聚焦。</p>
<p>现在让我们用指令来实现这个功能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;&#125;)</span><br><span class="line"><span class="comment">// 注册一个全局自定义指令 `v-focus`</span></span><br><span class="line">app.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 当被绑定的元素挂载到 DOM 中时……</span></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params">el</span>) &#123;</span><br><span class="line">    <span class="comment">// 聚焦元素</span></span><br><span class="line">    el.<span class="title function_">focus</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果想注册局部指令，组件中也接受一个 <code>directives</code> 的选项：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">  <span class="attr">focus</span>: &#123;</span><br><span class="line">    <span class="comment">// 指令的定义</span></span><br><span class="line">    <span class="title function_">mounted</span>(<span class="params">el</span>) &#123;</span><br><span class="line">      el.<span class="title function_">focus</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后你可以在模板中任何元素上使用新的 <code>v-focus</code> attribute，如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-focus</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-钩子函数"><a href="#2-钩子函数" class="headerlink" title="2. 钩子函数"></a>2. 钩子函数</h2><p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p>
<ul>
<li><p><code>created</code>：在绑定元素的 attribute 或事件监听器被应用之前调用。在指令需要附加在普通的 <code>v-on</code> 事件监听器调用前的事件监听器中时，这很有用。</p>
</li>
<li><p><code>beforeMount</code>：当指令第一次绑定到元素并且在挂载父组件之前调用。</p>
</li>
<li><p><code>mounted</code>：在绑定元素的父组件被挂载后调用。</p>
</li>
<li><p><code>beforeUpdate</code>：在更新包含组件的 VNode 之前调用。我们会在<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/render-function.html#%E8%99%9A%E6%8B%9F-dom-%E6%A0%91">稍后</a>讨论渲染函数时介绍更多 VNodes 的细节。</p>
</li>
<li><p><code>updated</code>：在包含组件的 VNode <strong>及其子组件的 VNode</strong> 更新后调用。</p>
</li>
<li><p><code>beforeUnmount</code>：在卸载绑定元素的父组件之前调用</p>
</li>
<li><p><code>unmounted</code>：当指令与元素解除绑定且父组件已卸载时，只调用一次。</p>
</li>
</ul>
<p>接下来我们来看一下在<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/application-api.html#directive">自定义指令 API</a> 钩子函数的参数 (即 <code>el</code>、<code>binding</code>、<code>vnode</code> 和 <code>prevVnode</code>)</p>
<h3 id="2-1-动态指令函数"><a href="#2-1-动态指令函数" class="headerlink" title="2.1 动态指令函数"></a>2.1 动态指令函数</h3><p>指令的参数可以是动态的。例如，在 <code>v-mydirective:[argument]=&quot;value&quot;</code> 中，<code>argument</code> 参数可以根据组件实例数据进行更新！这使得自定义指令可以在应用中被灵活使用。</p>
<p>例如你想要创建一个自定义指令，用来通过固定布局将元素固定在页面上。我们可以创建一个自定义指令，它的值以像素为单位更新被固定元素的垂直位置，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;dynamic-arguments-example&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Scroll down the page<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-pin</span>=<span class="string">&quot;200&quot;</span>&gt;</span>Stick me 200px from the top of the page<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;   </span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">directive</span>(<span class="string">&#x27;pin&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params">el, binding</span>) &#123;</span><br><span class="line">    el.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;fixed&#x27;</span></span><br><span class="line">    <span class="comment">// binding.value 是我们传递给指令的值——在这里是 200</span></span><br><span class="line">    el.<span class="property">style</span>.<span class="property">top</span> = binding.<span class="property">value</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#dynamic-arguments-example&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这会把该元素固定在距离页面顶部 200 像素的位置。但如果场景是我们需要把元素固定在左侧而不是顶部又该怎么办呢？这时使用动态参数就可以非常方便地根据每个组件实例来进行更新。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;dynamicexample&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Scroll down inside this section ↓<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-pin:</span>[<span class="attr">direction</span>]=<span class="string">&quot;200&quot;</span>&gt;</span>I am pinned onto the page at 200px to the left.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">direction</span>: <span class="string">&#x27;right&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">directive</span>(<span class="string">&#x27;pin&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params">el, binding</span>) &#123;</span><br><span class="line">    el.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;fixed&#x27;</span></span><br><span class="line">    <span class="comment">// binding.arg 是我们传递给指令的参数</span></span><br><span class="line">    <span class="keyword">const</span> s = binding.<span class="property">arg</span> || <span class="string">&#x27;top&#x27;</span></span><br><span class="line">    el.<span class="property">style</span>[s] = binding.<span class="property">value</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#dynamic-arguments-example&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\ThinkPad\AppData\Roaming\marktext\images\2022-07-12-17-29-47-image.png"></p>
<p>我们的自定义指令现在已经足够灵活，可以支持一些不同的用例。为了使其更具动态性，我们还可以允许修改绑定值。让我们创建一个附加属性 <code>pinPadding</code>，并将其绑定到 <code>&lt;input type=&quot;range&quot;&gt;</code>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;dynamicexample&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Scroll down the page<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;500&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;pinPadding&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-pin:</span>[<span class="attr">direction</span>]=<span class="string">&quot;pinPadding&quot;</span>&gt;</span>Stick me &#123;&#123; pinPadding + &#x27;px&#x27; &#125;&#125; from the &#123;&#123; direction || &#x27;top&#x27; &#125;&#125; of the page<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">direction</span>: <span class="string">&#x27;right&#x27;</span>,</span><br><span class="line">      <span class="attr">pinPadding</span>: <span class="number">200</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>让我们扩展指令逻辑以在组件更新后重新计算固定的距离。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">directive</span>(<span class="string">&#x27;pin&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params">el, binding</span>) &#123;</span><br><span class="line">    el.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;fixed&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> s = binding.<span class="property">arg</span> || <span class="string">&#x27;top&#x27;</span></span><br><span class="line">    el.<span class="property">style</span>[s] = binding.<span class="property">value</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">updated</span>(<span class="params">el, binding</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> s = binding.<span class="property">arg</span> || <span class="string">&#x27;top&#x27;</span></span><br><span class="line">    el.<span class="property">style</span>[s] = binding.<span class="property">value</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="3-函数简写"><a href="#3-函数简写" class="headerlink" title="3. 函数简写"></a>3. 函数简写</h2><p>在前面的例子中，你可能想在 <code>mounted</code> 和 <code>updated</code> 时触发相同行为，而不关心其他的钩子函数。那么你可以通过将这个回调函数传递给指令来实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">directive</span>(<span class="string">&#x27;pin&#x27;</span>, <span class="function">(<span class="params">el, binding</span>) =&gt;</span> &#123;</span><br><span class="line">  el.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;fixed&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> s = binding.<span class="property">arg</span> || <span class="string">&#x27;top&#x27;</span></span><br><span class="line">  el.<span class="property">style</span>[s] = binding.<span class="property">value</span> + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="4-对象字面量"><a href="#4-对象字面量" class="headerlink" title="4. 对象字面量"></a>4. 对象字面量</h2><p>如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法的 JavaScript 表达式。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-demo</span>=<span class="string">&quot;&#123; color: &#x27;white&#x27;, text: &#x27;hello!&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">directive</span>(<span class="string">&#x27;demo&#x27;</span>, <span class="function">(<span class="params">el, binding</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(binding.<span class="property">value</span>.<span class="property">color</span>) <span class="comment">// =&gt; &quot;white&quot;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(binding.<span class="property">value</span>.<span class="property">text</span>) <span class="comment">// =&gt; &quot;hello!&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="5-在组件中使用"><a href="#5-在组件中使用" class="headerlink" title="5. 在组件中使用"></a>5. 在组件中使用</h2><p>和<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/component-attrs.html">非 prop 的 attribute</a> 类似，当在组件中使用时，自定义指令总是会被应用在组件的根节点上。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-demo</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">component</span>(<span class="string">&#x27;my-component&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt; // v-demo 指令将会被应用在这里</span></span><br><span class="line"><span class="string">      &lt;span&gt;My component content&lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>和 attribute 不同，指令不会通过 <code>v-bind=&quot;$attrs&quot;</code> 被传入另一个元素。</p>
<p>有了<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/migration/fragments.html#%E6%A6%82%E8%A7%88">片段</a>支持以后，组件可能会有多个根节点。当被应用在一个多根节点的组件上时，指令会被忽略，并且会抛出一个警告。</p>
<h1 id="四、Teleport"><a href="#四、Teleport" class="headerlink" title="四、Teleport"></a>四、Teleport</h1><p>Vue 鼓励我们通过将 UI 和相关行为封装到组件中来构建 UI。我们可以将它们嵌套在另一个内部，以构建一个组成应用程序 UI 的树。</p>
<p>然而，有时组件模板的一部分逻辑上属于该组件，而从技术角度来看，最好将模板的这一部分移动到 DOM 中 Vue app 之外的其他位置。</p>
<p>一个常见的场景是创建一个包含全屏模式的组件。在大多数情况下，你希望模态框的逻辑存在于组件中，但是模态框的快速定位就很难通过 CSS 来解决，或者需要更改组件组合。</p>
<p>考虑下面的 HTML 结构。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position: relative;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Tooltips with Vue 3 Teleport<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">modal-button</span>&gt;</span><span class="tag">&lt;/<span class="name">modal-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>让我们来看看 <code>modal-button</code> 组件：</p>
<p>该组件将有一个 <code>button</code> 元素来触发模态框的打开，以及一个带有 class <code>.modal</code> 的 <code>div</code> 元素，它将包含模态框的内容和一个用于自关闭的按钮。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&#x27;modal-button&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;button @click=&quot;modalOpen = true&quot;&gt;</span></span><br><span class="line"><span class="string">        Open full screen modal!</span></span><br><span class="line"><span class="string">    &lt;/button&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;div v-if=&quot;modalOpen&quot; class=&quot;modal&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        I&#x27;m a modal! </span></span><br><span class="line"><span class="string">        &lt;button @click=&quot;modalOpen = false&quot;&gt;</span></span><br><span class="line"><span class="string">          Close</span></span><br><span class="line"><span class="string">        &lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">      <span class="attr">modalOpen</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当在初始的 HTML 结构中使用这个组件时，我们可以看到一个问题——模态框是在深度嵌套的 <code>div</code> 中渲染的，而模态框的 <code>position:absolute</code> 以父级相对定位的 <code>div</code> 作为引用。</p>
<p>Teleport 提供了一种干净的方法，允许我们控制在 DOM 中哪个父节点下渲染了 HTML，而不必求助于全局状态或将其拆分为两个组件。</p>
<p>让我们修改 <code>modal-button</code> 以使用 <code>&lt;teleport&gt;</code>，并告诉 Vue “将这个 HTML <strong>传送</strong>到‘<strong>body</strong>’标签下”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">component</span>(<span class="string">&#x27;modal-button&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;button @click=&quot;modalOpen = true&quot;&gt;</span></span><br><span class="line"><span class="string">        Open full screen modal! (With teleport!)</span></span><br><span class="line"><span class="string">    &lt;/button&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;teleport to=&quot;body&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;div v-if=&quot;modalOpen&quot; class=&quot;modal&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">          I&#x27;m a teleported modal! </span></span><br><span class="line"><span class="string">          (My parent is &quot;body&quot;)</span></span><br><span class="line"><span class="string">          &lt;button @click=&quot;modalOpen = false&quot;&gt;</span></span><br><span class="line"><span class="string">            Close</span></span><br><span class="line"><span class="string">          &lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/teleport&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">      <span class="attr">modalOpen</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>因此，一旦我们单击按钮打开模态框，Vue 将正确地将模态框内容渲染为 <code>body</code> 标签的子级。</p>
<h2 id="1-与-Vue-components-一起使用"><a href="#1-与-Vue-components-一起使用" class="headerlink" title="1. 与 Vue components 一起使用"></a>1. 与 Vue components 一起使用</h2><p>如果 <code>&lt;teleport&gt;</code> 包含 Vue 组件，则它仍将是 <code>&lt;teleport&gt;</code> 父组件的逻辑子组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(&#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h1&gt;Root instance&lt;/h1&gt;</span></span><br><span class="line"><span class="string">    &lt;parent-component /&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&#x27;parent-component&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h2&gt;This is a parent component&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;teleport to=&quot;#endofbody&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;child-component name=&quot;John&quot; /&gt;</span></span><br><span class="line"><span class="string">    &lt;/teleport&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&#x27;child-component&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;name&#x27;</span>],</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;Hello, &#123;&#123; name &#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在这种情况下，即使在不同的地方渲染 <code>child-component</code>，它仍将是 <code>parent-component</code> 的子级，并将从中接收 <code>name</code> prop。</p>
<p>这也意味着来自父组件的注入会正常工作，在 Vue Devtools 中你会看到子组件嵌套在父组件之下，而不是出现在他会被实际移动到的位置。</p>
<h2 id="2-在同一目标上使用多个-teleport"><a href="#2-在同一目标上使用多个-teleport" class="headerlink" title="2. 在同一目标上使用多个 teleport"></a>2. 在同一目标上使用多个 teleport</h2><p>一个常见的用例场景是一个可重用的 <code>&lt;Modal&gt;</code> 组件，它可能同时有多个实例处于活动状态。对于这种情况，多个 <code>&lt;teleport&gt;</code> 组件可以将其内容挂载到同一个目标元素。顺序将是一个简单的追加——稍后挂载将位于目标元素中较早的挂载之后。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;#modals&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;#modals&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>B<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- result--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;modals&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>B<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你可以在 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/built-in-components.html#teleport">API 参考</a> 查看 <code>teleport</code> 组件。</p>
<h1 id="五、渲染函数"><a href="#五、渲染函数" class="headerlink" title="五、渲染函数"></a>五、渲染函数</h1><p>Vue 推荐在绝大多数情况下使用模板来创建你的 HTML。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力。这时你可以用<strong>渲染函数</strong>，它比模板更接近编译器。</p>
<p>让我们深入一个简单的例子，这个例子里 <code>render</code> 函数很实用。假设我们要生成一些带锚点的标题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;hello-world&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#hello-world&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Hello world!</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>锚点标题的使用非常频繁，我们应该创建一个组件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">anchored-heading</span> <span class="attr">:level</span>=<span class="string">&quot;1&quot;</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">anchored-heading</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当开始写一个只能通过 <code>level</code> prop 动态生成标题 (heading) 的组件时，我们很快就可以得出这样的结论：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createApp &#125; = <span class="title class_">Vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&#x27;anchored-heading&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h1 v-if=&quot;level === 1&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    &lt;/h1&gt;</span></span><br><span class="line"><span class="string">    &lt;h2 v-else-if=&quot;level === 2&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    &lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;h3 v-else-if=&quot;level === 3&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    &lt;/h3&gt;</span></span><br><span class="line"><span class="string">    &lt;h4 v-else-if=&quot;level === 4&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    &lt;/h4&gt;</span></span><br><span class="line"><span class="string">    &lt;h5 v-else-if=&quot;level === 5&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    &lt;/h5&gt;</span></span><br><span class="line"><span class="string">    &lt;h6 v-else-if=&quot;level === 6&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    &lt;/h6&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">level</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这个模板感觉不太好。它不仅冗长，而且我们为每个级别标题重复书写了 <code>&lt;slot&gt;&lt;/slot&gt;</code>。当我们添加锚元素时，我们必须在每个 <code>v-if/v-else-if</code> 分支中再次重复它。</p>
<p>虽然模板在大多数组件中都非常好用，但是显然在这里它就不合适了。那么，我们来尝试使用 <code>render</code> 函数重写上面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createApp, h &#125; = <span class="title class_">Vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&#x27;anchored-heading&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">h</span>(</span><br><span class="line">      <span class="string">&#x27;h&#x27;</span> + <span class="variable language_">this</span>.<span class="property">level</span>, <span class="comment">// 标签名</span></span><br><span class="line">      &#123;&#125;, <span class="comment">// prop 或 attribute</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$slots</span>.<span class="title function_">default</span>() <span class="comment">// 包含其子节点的数组</span></span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">level</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>render()</code> 函数的实现要精简得多，但是需要非常熟悉组件的实例 property。在这个例子中，你需要知道，向组件中传递不带 <code>v-slot</code> 指令的子节点时，比如 <code>anchored-heading</code> 中的 <code>Hello world!</code> ，这些子节点被存储在组件实例中的 <code>$slots.default</code> 中。如果你还不了解，在深入渲染函数之前推荐阅读<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/instance-properties.html">实例 property API</a>。</p>
<h2 id="1-DOM树"><a href="#1-DOM树" class="headerlink" title="1. DOM树"></a>1. DOM树</h2><p>在深入渲染函数之前，了解一些浏览器的工作原理是很重要的。以下面这段 HTML 为例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>My title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  Some text content</span><br><span class="line">  <span class="comment">&lt;!-- <span class="doctag">TODO:</span> Add tagline --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当浏览器读到这些代码时，它会建立一个 <a target="_blank" rel="noopener" href="https://javascript.info/dom-nodes">”DOM 节点“ 树</a> 来保持追踪所有内容，如同你会画一张家谱树来追踪家庭成员的发展一样。</p>
<p>上述 HTML 对应的 DOM 节点树如下图所示</p>
<p><img src="https://v3.cn.vuejs.org/images/dom-tree.png" alt="DOM Tree Visualization"></p>
<p>每个元素都是一个节点。每段文字也是一个节点。甚至注释也都是节点。一个节点就是页面的一个部分。就像家谱树一样，每个节点都可以有孩子节点 (也就是说每个部分可以包含其它的一些部分)。</p>
<p>高效地更新所有这些节点会是比较困难的，不过所幸你不必手动完成这个工作。你只需要告诉 Vue 你希望页面上的 HTML 是什么，这可以是在一个模板里：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; blogTitle &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者一个渲染函数里：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;h1&#x27;</span>, &#123;&#125;, <span class="variable language_">this</span>.<span class="property">blogTitle</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这两种情况下，Vue 都会自动保持页面的更新，即便 <code>blogTitle</code> 发生了改变。</p>
<h2 id="2-虚拟DOM树"><a href="#2-虚拟DOM树" class="headerlink" title="2. 虚拟DOM树"></a>2. 虚拟DOM树</h2><p>Vue 通过建立一个<strong>虚拟 DOM</strong> 来追踪自己要如何改变真实 DOM。请仔细看这行代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;h1&#x27;</span>, &#123;&#125;, <span class="variable language_">this</span>.<span class="property">blogTitle</span>)</span><br></pre></td></tr></table></figure>

<p><code>h()</code> 到底会返回什么呢？其实不是一个<em>实际</em>的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为 <strong>VNode</strong>。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。</p>
<h2 id="3-h-参数"><a href="#3-h-参数" class="headerlink" title="3.  h() 参数"></a>3.  <code>h()</code> 参数</h2><p><code>h()</code> 函数是一个用于创建 VNode 的实用程序。也许可以更准确地将其命名为 <code>createVNode()</code>，但由于频繁使用和简洁，它被称为 <code>h()</code> 。它接受三个参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @returns &#123;VNode&#125;</span></span><br><span class="line"><span class="title function_">h</span>(</span><br><span class="line">  <span class="comment">// &#123;String | Object | Function&#125; tag</span></span><br><span class="line">  <span class="comment">// 一个 HTML 标签名、一个组件、一个异步组件、或</span></span><br><span class="line">  <span class="comment">// 一个函数式组件。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 必需的。</span></span><br><span class="line">  <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#123;Object&#125; props</span></span><br><span class="line">  <span class="comment">// 与 attribute、prop 和事件相对应的对象。</span></span><br><span class="line">  <span class="comment">// 这会在模板中用到。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 可选的。</span></span><br><span class="line">  &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#123;String | Array | Object&#125; children</span></span><br><span class="line">  <span class="comment">// 子 VNodes, 使用 `h()` 构建,</span></span><br><span class="line">  <span class="comment">// 或使用字符串获取 &quot;文本 VNode&quot; 或者</span></span><br><span class="line">  <span class="comment">// 有插槽的对象。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 可选的。</span></span><br><span class="line">  [</span><br><span class="line">    <span class="string">&#x27;Some text comes first.&#x27;</span>,</span><br><span class="line">    <span class="title function_">h</span>(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;A headline&#x27;</span>),</span><br><span class="line">    <span class="title function_">h</span>(<span class="title class_">MyComponent</span>, &#123;</span><br><span class="line">      <span class="attr">someProp</span>: <span class="string">&#x27;foobar&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果没有 prop，那么通常可以将 children 作为第二个参数传入。如果会产生歧义，可以将 <code>null</code> 作为第二个参数传入，将 children 作为第三个参数传入。</p>
<h2 id="4-完整实例"><a href="#4-完整实例" class="headerlink" title="4. 完整实例"></a>4. 完整实例</h2><p>有了这些知识，我们现在可以完成我们最开始想实现的组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createApp, h &#125; = <span class="title class_">Vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 递归地从子节点获取文本 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getChildrenTextContent</span>(<span class="params">children</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> children</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">typeof</span> node.<span class="property">children</span> === <span class="string">&#x27;string&#x27;</span></span><br><span class="line">        ? node.<span class="property">children</span></span><br><span class="line">        : <span class="title class_">Array</span>.<span class="title function_">isArray</span>(node.<span class="property">children</span>)</span><br><span class="line">        ? <span class="title function_">getChildrenTextContent</span>(node.<span class="property">children</span>)</span><br><span class="line">        : <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&#x27;anchored-heading&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 从 children 的文本内容中创建短横线分隔 (kebab-case) id。</span></span><br><span class="line">    <span class="keyword">const</span> headingId = <span class="title function_">getChildrenTextContent</span>(<span class="variable language_">this</span>.<span class="property">$slots</span>.<span class="title function_">default</span>())</span><br><span class="line">      .<span class="title function_">toLowerCase</span>()</span><br><span class="line">      .<span class="title function_">replace</span>(<span class="regexp">/\W+/g</span>, <span class="string">&#x27;-&#x27;</span>) <span class="comment">// 用短横线替换非单词字符</span></span><br><span class="line">      .<span class="title function_">replace</span>(<span class="regexp">/(^-|-$)/g</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// 删除前后短横线</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;h&#x27;</span> + <span class="variable language_">this</span>.<span class="property">level</span>, [</span><br><span class="line">      <span class="title function_">h</span>(</span><br><span class="line">        <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">name</span>: headingId,</span><br><span class="line">          <span class="attr">href</span>: <span class="string">&#x27;#&#x27;</span> + headingId</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$slots</span>.<span class="title function_">default</span>()</span><br><span class="line">      )</span><br><span class="line">    ])</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">level</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="5-约束"><a href="#5-约束" class="headerlink" title="5. 约束"></a>5. 约束</h2><h3 id="5-1-VNodes必须唯一"><a href="#5-1-VNodes必须唯一" class="headerlink" title="5.1 VNodes必须唯一"></a>5.1 VNodes必须唯一</h3><p>组件树中的所有 VNode 必须是唯一的。这意味着，下面的渲染函数是不合法的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> myParagraphVNode = <span class="title function_">h</span>(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, [</span><br><span class="line">    <span class="comment">// 错误 - 重复的 Vnode!</span></span><br><span class="line">    myParagraphVNode, myParagraphVNode</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你真的需要重复很多次的元素&#x2F;组件，你可以使用工厂函数来实现。例如，下面这渲染函数用完全合法的方式渲染了 20 个相同的段落：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">20</span> &#125;).<span class="title function_">map</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-创建组件VNode"><a href="#6-创建组件VNode" class="headerlink" title="6. 创建组件VNode"></a>6. 创建组件VNode</h2><p>要为某个组件创建一个 VNode，传递给 <code>h</code> 的第一个参数应该是组件本身。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">h</span>(<span class="title class_">ButtonCounter</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们需要通过名称来解析一个组件，那么我们可以调用 <code>resolveComponent</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; h, resolveComponent &#125; = <span class="title class_">Vue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">ButtonCounter</span> = <span class="title function_">resolveComponent</span>(<span class="string">&#x27;ButtonCounter&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">h</span>(<span class="title class_">ButtonCounter</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>resolveComponent</code> 是模板内部用来解析组件名称的同一个函数。</p>
<p><code>render</code> 函数通常只需要对<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/component-registration.html#global-registration">全局注册</a>的组件使用 <code>resolveComponent</code>。而对于<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/component-registration.html#local-registration">局部注册</a>的却可以跳过，请看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此写法可以简化</span></span><br><span class="line"><span class="attr">components</span>: &#123;</span><br><span class="line">  <span class="title class_">ButtonCounter</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">h</span>(<span class="title function_">resolveComponent</span>(<span class="string">&#x27;ButtonCounter&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以直接使用它，而不是通过名称注册一个组件，然后再查找：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">h</span>(<span class="title class_">ButtonCounter</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-使用JavaScript代替模板功能"><a href="#7-使用JavaScript代替模板功能" class="headerlink" title="7. 使用JavaScript代替模板功能"></a>7. 使用JavaScript代替模板功能</h2><h3 id="7-1-v-if-和-v-for"><a href="#7-1-v-if-和-v-for" class="headerlink" title="7.1 v-if 和 v-for"></a>7.1 <code>v-if</code> 和 <code>v-for</code></h3><p>只要在原生的 JavaScript 中可以轻松完成的操作，Vue 的渲染函数就不会提供专有的替代方法。比如，在模板中使用的 <code>v-if</code> 和 <code>v-for</code>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">&quot;items.length&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>No items found.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这些都可以在渲染函数中用 JavaScript 的 <code>if</code>&#x2F;<code>else</code> 和 <code>map()</code> 来重写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">props</span>: [<span class="string">&#x27;items&#x27;</span>],</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;ul&#x27;</span>, <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;li&#x27;</span>, item.<span class="property">name</span>)</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;No items found.&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-v-model"><a href="#7-2-v-model" class="headerlink" title="7.2 v-model"></a>7.2 <code>v-model</code></h3><p><code>v-model</code> 指令扩展为 <code>modelValue</code> 和 <code>onUpdate:modelValue</code> 在模板编译过程中，我们必须自己提供这些 prop：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">props</span>: [<span class="string">&#x27;modelValue&#x27;</span>],</span><br><span class="line"><span class="attr">emits</span>: [<span class="string">&#x27;update:modelValue&#x27;</span>],</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">h</span>(<span class="title class_">SomeComponent</span>, &#123;</span><br><span class="line">    <span class="attr">modelValue</span>: <span class="variable language_">this</span>.<span class="property">modelValue</span>,</span><br><span class="line">    <span class="string">&#x27;onUpdate:modelValue&#x27;</span>: <span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">this</span>.$emit(<span class="string">&#x27;update:modelValue&#x27;</span>, value)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-3-v-on"><a href="#7-3-v-on" class="headerlink" title="7.3 v-on"></a>7.3 <code>v-on</code></h3><p>我们必须为事件处理程序提供一个正确的 prop 名称，例如，要处理 <code>click</code> 事件，prop 名称应该是 <code>onClick</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">onClick</span>: $event =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;clicked&#x27;</span>, $event.<span class="property">target</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-3-1-事件修饰符"><a href="#7-3-1-事件修饰符" class="headerlink" title="7.3.1 事件修饰符"></a>7.3.1 事件修饰符</h4><p>对于 <code>.passive</code> 、<code>.capture</code> 和 <code>.once</code> 事件修饰符，可以使用驼峰写法将他们拼接在事件名后面：</p>
<p>实例:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;input&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">onClickCapture</span>: <span class="variable language_">this</span>.<span class="property">doThisInCapturingMode</span>,</span><br><span class="line">    <span class="attr">onKeyupOnce</span>: <span class="variable language_">this</span>.<span class="property">doThisOnce</span>,</span><br><span class="line">    <span class="attr">onMouseoverOnceCapture</span>: <span class="variable language_">this</span>.<span class="property">doThisOnceInCapturingMode</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于所有其它的修饰符，私有前缀都不是必须的，因为你可以在事件处理函数中使用事件方法：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>处理函数中的等价操作</th>
</tr>
</thead>
<tbody><tr>
<td><code>.stop</code></td>
<td><code>event.stopPropagation()</code></td>
</tr>
<tr>
<td><code>.prevent</code></td>
<td><code>event.preventDefault()</code></td>
</tr>
<tr>
<td><code>.self</code></td>
<td><code>if (event.target !== event.currentTarget) return</code></td>
</tr>
<tr>
<td>按键：<br><code>.enter</code>, <code>.13</code></td>
<td><code>if (event.keyCode !== 13) return</code> (对于别的按键修饰符来说，可将 13 改为<a target="_blank" rel="noopener" href="http://keycode.info/">另一个按键码</a></td>
</tr>
<tr>
<td>修饰键：<br><code>.ctrl</code>, <code>.alt</code>, <code>.shift</code>, <code>.meta</code></td>
<td><code>if (!event.ctrlKey) return</code> (将 <code>ctrlKey</code> 分别修改为 <code>altKey</code>, <code>shiftKey</code>, 或 <code>metaKey</code>)</td>
</tr>
</tbody></table>
<p>这里是一个使用所有修饰符的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;input&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">onKeyUp</span>: <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 如果触发事件的元素不是事件绑定的元素</span></span><br><span class="line">      <span class="comment">// 则返回</span></span><br><span class="line">      <span class="keyword">if</span> (event.<span class="property">target</span> !== event.<span class="property">currentTarget</span>) <span class="keyword">return</span></span><br><span class="line">      <span class="comment">// 如果向上键不是回车键，则终止</span></span><br><span class="line">      <span class="comment">// 没有同时按下按键 (13) 和 shift 键</span></span><br><span class="line">      <span class="keyword">if</span> (!event.<span class="property">shiftKey</span> || event.<span class="property">keyCode</span> !== <span class="number">13</span>) <span class="keyword">return</span></span><br><span class="line">      <span class="comment">// 停止事件传播</span></span><br><span class="line">      event.<span class="title function_">stopPropagation</span>()</span><br><span class="line">      <span class="comment">// 阻止该元素默认的 keyup 事件</span></span><br><span class="line">      event.<span class="title function_">preventDefault</span>()</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-插槽"><a href="#7-4-插槽" class="headerlink" title="7.4 插槽"></a>7.4 插槽</h3><p>你可以通过 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/instance-properties.html#slots"><code>this.$slots</code></a> 访问静态插槽的内容，每个插槽都是一个 VNode 数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// `&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;`</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, &#123;&#125;, <span class="variable language_">this</span>.<span class="property">$slots</span>.<span class="title function_">default</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">props</span>: [<span class="string">&#x27;message&#x27;</span>],</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// `&lt;div&gt;&lt;slot :text=&quot;message&quot;&gt;&lt;/slot&gt;&lt;/div&gt;`</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, &#123;&#125;, <span class="variable language_">this</span>.<span class="property">$slots</span>.<span class="title function_">default</span>(&#123;</span><br><span class="line">    <span class="attr">text</span>: <span class="variable language_">this</span>.<span class="property">message</span></span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要使用渲染函数将插槽传递给子组件，请执行以下操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; h, resolveComponent &#125; = <span class="title class_">Vue</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// `&lt;div&gt;&lt;child v-slot=&quot;props&quot;&gt;&lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt;&lt;/child&gt;&lt;/div&gt;`</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, [</span><br><span class="line">    <span class="title function_">h</span>(</span><br><span class="line">      <span class="title function_">resolveComponent</span>(<span class="string">&#x27;child&#x27;</span>),</span><br><span class="line">      &#123;&#125;,</span><br><span class="line">      <span class="comment">// 将 `slots` 以 &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125; 的形式传递给子对象。</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">default</span>: <span class="function">(<span class="params">props</span>) =&gt;</span> <span class="title function_">h</span>(<span class="string">&#x27;span&#x27;</span>, props.<span class="property">text</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插槽以函数的形式传递，允许子组件控制每个插槽内容的创建。任何响应式数据都应该在插槽函数内访问，以确保它被注册为子组件的依赖关系，而不是父组件。相反，对 <code>resolveComponent</code> 的调用应该在插槽函数之外进行，否则它们会相对于错误的组件进行解析。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `&lt;MyButton&gt;&lt;MyIcon :name=&quot;icon&quot; /&gt;&#123;&#123; text &#125;&#125;&lt;/MyButton&gt;`</span></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 应该是在插槽函数外面调用 resolveComponent。</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Button</span> = <span class="title function_">resolveComponent</span>(<span class="string">&#x27;MyButton&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Icon</span> = <span class="title function_">resolveComponent</span>(<span class="string">&#x27;MyIcon&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">h</span>(</span><br><span class="line">    <span class="title class_">Button</span>,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 使用箭头函数保存 `this` 的值</span></span><br><span class="line">      <span class="attr">default</span>: <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 响应式 property 应该在插槽函数内部读取，</span></span><br><span class="line">        <span class="comment">// 这样它们就会成为 children 渲染的依赖。</span></span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">          <span class="title function_">h</span>(<span class="title class_">Icon</span>, &#123; <span class="attr">name</span>: <span class="variable language_">this</span>.<span class="property">icon</span> &#125;),</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">text</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个组件从它的父组件中接收到插槽，它们可以直接传递给子组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">h</span>(<span class="title class_">Panel</span>, <span class="literal">null</span>, <span class="variable language_">this</span>.<span class="property">$slots</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以根据情况单独传递或包裹住。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">h</span>(</span><br><span class="line">    <span class="title class_">Panel</span>,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 如果我们想传递一个槽函数，我们可以通过</span></span><br><span class="line">      <span class="attr">header</span>: <span class="variable language_">this</span>.<span class="property">$slots</span>.<span class="property">header</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果我们需要以某种方式对插槽进行操作，</span></span><br><span class="line">      <span class="comment">// 那么我们需要用一个新的函数来包裹它</span></span><br><span class="line">      <span class="attr">default</span>: <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> children = <span class="variable language_">this</span>.<span class="property">$slots</span>.<span class="property">default</span> ? <span class="variable language_">this</span>.<span class="property">$slots</span>.<span class="title function_">default</span>(props) : []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> children.<span class="title function_">concat</span>(<span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;Extra child&#x27;</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-5-lt-component-gt-和-is"><a href="#7-5-lt-component-gt-和-is" class="headerlink" title="7.5 &lt;component&gt; 和 is"></a>7.5 <code>&lt;component&gt;</code> 和 <code>is</code></h3><p>在底层实现里，模板使用 <code>resolveDynamicComponent</code> 来实现 <code>is</code> attribute。如果我们在 <code>render</code> 函数中需要 <code>is</code> 提供的所有灵活性，我们可以使用同样的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; h, resolveDynamicComponent &#125; = <span class="title class_">Vue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `&lt;component :is=&quot;name&quot;&gt;&lt;/component&gt;`</span></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Component</span> = <span class="title function_">resolveDynamicComponent</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">h</span>(<span class="title class_">Component</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像 <code>is</code>, <code>resolveDynamicComponent</code> 支持传递一个组件名称、一个 HTML 元素名称或一个组件选项对象。</p>
<p>通常这种程度的灵活性是不需要的。通常 <code>resolveDynamicComponent</code> 可以被换做一个更直接的替代方案。</p>
<p>例如，如果我们只需要支持组件名称，那么可以使用 <code>resolveComponent</code> 来代替。</p>
<p>如果 VNode 始终是一个 HTML 元素，那么我们可以直接把它的名字传递给 <code>h</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `&lt;component :is=&quot;bold ? &#x27;strong&#x27; : &#x27;em&#x27;&quot;&gt;&lt;/component&gt;`</span></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">h</span>(<span class="variable language_">this</span>.<span class="property">bold</span> ? <span class="string">&#x27;strong&#x27;</span> : <span class="string">&#x27;em&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，如果传递给 <code>is</code> 的值是一个组件选项对象，那么不需要解析什么，可以直接作为 <code>h</code> 的第一个参数传递。</p>
<p>与 <code>&lt;template&gt;</code> 标签一样，<code>&lt;component&gt;</code> 标签仅在模板中作为语法占位符需要，当迁移到 <code>render</code> 函数时，应被丢弃。</p>
<h3 id="7-6-自定义指令"><a href="#7-6-自定义指令" class="headerlink" title="7.6 自定义指令"></a>7.6 自定义指令</h3><p>可以使用 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/global-api.html#withdirectives"><code>withDirectives</code></a> 将自定义指令应用于 VNode：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; h, resolveDirective, withDirectives &#125; = <span class="title class_">Vue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;div v-pin:top.animate=&quot;200&quot;&gt;&lt;/div&gt;</span></span><br><span class="line">render () &#123;</span><br><span class="line">  <span class="keyword">const</span> pin = <span class="title function_">resolveDirective</span>(<span class="string">&#x27;pin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">withDirectives</span>(<span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>), [</span><br><span class="line">    [pin, <span class="number">200</span>, <span class="string">&#x27;top&#x27;</span>, &#123; <span class="attr">animate</span>: <span class="literal">true</span> &#125;]</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/global-api.html#resolvedirective"><code>resolveDirective</code></a> 是模板内部用来解析指令名称的同一个函数。只有当你还没有直接访问指令的定义对象时，才需要这样做。</p>
<h3 id="7-7-内置组件"><a href="#7-7-内置组件" class="headerlink" title="7.7 内置组件"></a>7.7 内置组件</h3><p>诸如 <code>&lt;keep-alive&gt;</code>、<code>&lt;transition&gt;</code>、<code>&lt;transition-group&gt;</code> 和 <code>&lt;teleport&gt;</code> 等<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/built-in-components.html">内置组件</a>默认并没有被全局注册。这使得打包工具可以 tree-shake，因此这些组件只会在被用到的时候被引入构建。不过这也意味着我们无法通过 <code>resolveComponent</code> 或 <code>resolveDynamicComponent</code> 访问它们。</p>
<p>在模板中这些组件会被特殊处理，即在它们被用到的时候自动导入。当我们编写自己的 <code>render</code> 函数时，需要自行导入它们：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; h, <span class="title class_">KeepAlive</span>, <span class="title class_">Teleport</span>, <span class="title class_">Transition</span>, <span class="title class_">TransitionGroup</span> &#125; = <span class="title class_">Vue</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">render () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">h</span>(<span class="title class_">Transition</span>, &#123; <span class="attr">mode</span>: <span class="string">&#x27;out-in&#x27;</span> &#125;, <span class="comment">/* ... */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-渲染函数的返回值"><a href="#8-渲染函数的返回值" class="headerlink" title="8. 渲染函数的返回值"></a>8. 渲染函数的返回值</h2><p>在我们目前看过的所有示例中，<code>render</code> 函数返回的是单个根 VNode。但其实也有别的选项。</p>
<p>返回一个字符串时会创建一个文本 VNode，而不被包裹任何元素：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Hello world!&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以返回一个子元素数组，而不把它们包裹在一个根结点里。这会创建一个片段 (fragment)：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于模板 `Hello&lt;br&gt;world!`</span></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">    <span class="title function_">h</span>(<span class="string">&#x27;br&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;world!&#x27;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能是因为数据依然在加载中的关系，组件不需要渲染，这时它可以返回 <code>null</code>。这样我们在 DOM 中会渲染一个注释节点。</p>
<h2 id="9-JSX"><a href="#9-JSX" class="headerlink" title="9. JSX"></a>9. JSX</h2><p>如果你写了很多渲染函数，可能会觉得下面这样的代码写起来很痛苦：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">h</span>(</span><br><span class="line">  <span class="string">&#x27;anchored-heading&#x27;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">level</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">default</span>: <span class="function">() =&gt;</span> [<span class="title function_">h</span>(<span class="string">&#x27;span&#x27;</span>, <span class="string">&#x27;Hello&#x27;</span>), <span class="string">&#x27; world!&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>特别是对应的模板如此简单的情况下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">anchored-heading</span> <span class="attr">:level</span>=<span class="string">&quot;1&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span> world! <span class="tag">&lt;/<span class="name">anchored-heading</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这就是为什么会有一个 <a target="_blank" rel="noopener" href="https://github.com/vuejs/jsx-next">Babel 插件</a>，用于在 Vue 中使用 JSX 语法，它可以让我们回到更接近于模板的语法上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">AnchoredHeading</span> <span class="keyword">from</span> <span class="string">&#x27;./AnchoredHeading.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">AnchoredHeading</span> <span class="attr">level</span>=<span class="string">&#123;1&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span> world!</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">AnchoredHeading</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#demo&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>有关 JSX 如何映射到 JavaScript 的更多信息，请参阅<a target="_blank" rel="noopener" href="https://github.com/vuejs/jsx-next#installation">使用文档</a> 。</p>
<h2 id="10-函数式组件"><a href="#10-函数式组件" class="headerlink" title="10. 函数式组件"></a>10. 函数式组件</h2><p>函数式组件是自身没有任何状态的组件的另一种形式。它们在渲染过程中不会创建组件实例，并跳过常规的组件生命周期。</p>
<p>我们使用的是一个简单函数，而不是一个选项对象，来创建函数式组件。该函数实际上就是该组件的 <code>render</code> 函数。而因为函数式组件里没有 <code>this</code> 引用，Vue 会把 <code>props</code> 当作第一个参数传入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">FunctionalComponent</span> = (<span class="params">props, context</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个参数 <code>context</code> 包含三个 property：<code>attrs</code>、<code>emit</code> 和 <code>slots</code>。它们分别相当于实例的 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/instance-properties.html#attrs"><code>$attrs</code></a>、<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/instance-methods.html#emit"><code>$emit</code></a> 和 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/instance-properties.html#slots"><code>$slots</code></a> 这几个 property。</p>
<p>大多数常规组件的配置选项在函数式组件中都不可用。然而我们还是可以把 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/options-data.html#props"><code>props</code></a> 和 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/options-data.html#emits"><code>emits</code></a> 作为 property 加入，以达到定义它们的目的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">FunctionalComponent</span>.<span class="property">props</span> = [<span class="string">&#x27;value&#x27;</span>]</span><br><span class="line"><span class="title class_">FunctionalComponent</span>.<span class="property">emits</span> = [<span class="string">&#x27;click&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>如果这个 <code>props</code> 选项没有被定义，那么被传入函数的 <code>props</code> 对象就会像 <code>attrs</code> 一样会包含所有 attribute。除非指定了 <code>props</code> 选项，否则每个 prop 的名字将不会基于驼峰命名法被一般化处理。</p>
<p>函数式组件可以像普通组件一样被注册和消费。如果你将一个函数作为第一个参数传入 <code>h</code>，它将会被当作一个函数式组件来对待。</p>
<h2 id="11-模板编译"><a href="#11-模板编译" class="headerlink" title="11. 模板编译"></a>11. 模板编译</h2><p>你可能会有兴趣知道，Vue 的模板实际上被编译成了渲染函数。这是一个实现细节，通常不需要关心。但如果你想看看模板的功能具体是怎样被编译的，可能会发现会非常有意思。下面是一个使用 <code>Vue.compile</code> 来实时编译模板字符串的简单示例：</p>
<p><img src="C:\Users\ThinkPad\AppData\Roaming\marktext\images\2022-07-19-11-49-45-image.png"></p>
<h1 id="六、插件"><a href="#六、插件" class="headerlink" title="六、插件"></a>六、插件</h1><p>插件是自包含的代码，通常向 Vue 添加全局级功能。它可以是公开 <code>install()</code> 方法的 <code>object</code>，也可以是 <code>function</code></p>
<p>插件的功能范围没有严格的限制——一般有下面几种：</p>
<ol>
<li><p>添加全局方法或者 property。如：<a target="_blank" rel="noopener" href="https://github.com/karol-f/vue-custom-element">vue-custom-element</a></p>
</li>
<li><p>添加全局资源：指令&#x2F;过渡等。如：<a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-touch">vue-touch</a>）</p>
</li>
<li><p>通过全局 mixin 来添加一些组件选项。(如<a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-router">vue-router</a>)</p>
</li>
<li><p>添加全局实例方法，通过把它们添加到 <code>config.globalProperties</code> 上实现。</p>
</li>
<li><p>一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-router">vue-router</a></p>
</li>
</ol>
<h2 id="1-编写插件"><a href="#1-编写插件" class="headerlink" title="1. 编写插件"></a>1. 编写插件</h2><p>为了更好地理解如何创建自己的 Vue.js 版插件，我们将创建一个非常简化的插件版本，它显示 <code>i18n</code> 准备好的字符串。</p>
<p>每当这个插件被添加到应用程序中时，如果它是一个对象，就会调用 <code>install</code> 方法。如果它是一个 <code>function</code>，则函数本身将被调用。在这两种情况下——它都会收到两个参数：由 Vue 的 <code>createApp</code> 生成的 <code>app</code> 对象和用户传入的选项。</p>
<p>让我们从设置插件对象开始。建议在单独的文件中创建它并将其导出，如下所示，以保持包含的逻辑和分离的逻辑。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// plugins/i18n.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">install</span>: <span class="function">(<span class="params">app, options</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Plugin code goes here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们想要一个函数来翻译整个应用程序可用的键，因此我们将使用 <code>app.config.globalProperties</code> 暴露它。</p>
<p>该函数将接收一个 <code>key</code> 字符串，我们将使用它在用户提供的选项中查找转换后的字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// plugins/i18n.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">install</span>: <span class="function">(<span class="params">app, options</span>) =&gt;</span> &#123;</span><br><span class="line">    app.<span class="property">config</span>.<span class="property">globalProperties</span>.<span class="property">$translate</span> = <span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> key.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_">reduce</span>(<span class="function">(<span class="params">o, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o) <span class="keyword">return</span> o[i]</span><br><span class="line">      &#125;, options)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们假设用户使用插件时，将在 <code>options</code> 参数中传递一个包含翻译后的键的对象。我们的 <code>$translate</code> 函数将使用诸如 <code>greetings.hello</code> 之类的字符串，查看用户提供的配置内部并返回转换后的值-在这种情况下为 <code>Bonjour!</code>。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">greetings</span>: &#123;</span><br><span class="line">  <span class="attr">hello</span>: <span class="string">&#x27;Bonjour!&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插件还允许我们使用 <code>inject</code> 为插件的用户提供功能或 attribute。例如，我们可以允许应用程序访问 <code>options</code> 参数以能够使用翻译对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// plugins/i18n.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">install</span>: <span class="function">(<span class="params">app, options</span>) =&gt;</span> &#123;</span><br><span class="line">    app.<span class="property">config</span>.<span class="property">globalProperties</span>.<span class="property">$translate</span> = <span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> key.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_">reduce</span>(<span class="function">(<span class="params">o, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o) <span class="keyword">return</span> o[i]</span><br><span class="line">      &#125;, options)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    app.<span class="title function_">provide</span>(<span class="string">&#x27;i18n&#x27;</span>, options)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插件用户现在可以将 <code>inject[i18n]</code> 注入到他们的组件并访问该对象。</p>
<p>另外，由于我们可以访问 <code>app</code> 对象，因此插件可以使用所有其他功能，例如使用 <code>mixin</code> 和 <code>directive</code>。要了解有关 <code>createApp</code> 和应用程序实例的更多信息，请查看 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/application-api.html">Application API 文档</a>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// plugins/i18n.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">install</span>: <span class="function">(<span class="params">app, options</span>) =&gt;</span> &#123;</span><br><span class="line">    app.<span class="property">config</span>.<span class="property">globalProperties</span>.<span class="property">$translate</span> = <span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> key.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        .<span class="title function_">reduce</span>(<span class="function">(<span class="params">o, i</span>) =&gt;</span> &#123; <span class="keyword">if</span> (o) <span class="keyword">return</span> o[i] &#125;, options)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    app.<span class="title function_">provide</span>(<span class="string">&#x27;i18n&#x27;</span>, options)</span><br><span class="line"></span><br><span class="line">    app.<span class="title function_">directive</span>(<span class="string">&#x27;my-directive&#x27;</span>, &#123;</span><br><span class="line">      mounted (el, binding, vnode, oldVnode) &#123;</span><br><span class="line">        <span class="comment">// some logic ...</span></span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    app.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">      <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// some logic ...</span></span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-使用插件"><a href="#2-使用插件" class="headerlink" title="2. 使用插件"></a>2. 使用插件</h2><p>在使用 <code>createApp()</code> 初始化 Vue 应用程序后，你可以通过调用 <code>use()</code> 方法将插件添加到你的应用程序中。</p>
<p>我们将使用在<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/plugins.html#%E7%BC%96%E5%86%99%E6%8F%92%E4%BB%B6">编写插件</a>部分中创建的 <code>i18nPlugin</code> 进行演示。</p>
<p><code>use()</code> 方法有两个参数。第一个是要安装的插件，在这种情况下为 <code>i18nPlugin</code>。</p>
<p>它还会自动阻止你多次使用同一插件，因此在同一插件上多次调用只会安装一次该插件。</p>
<p>第二个参数是可选的，并且取决于每个特定的插件。在演示 <code>i18nPlugin</code> 的情况下，它是带有转换后的字符串的对象。</p>
<p>如果你使用的是第三方插件 (例如 <code>Vuex</code> 或 <code>Vue Router</code>)，请始终查看文档以了解特定插件期望作为第二个参数接收的内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Root</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> i18nPlugin <span class="keyword">from</span> <span class="string">&#x27;./plugins/i18n&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">Root</span>)</span><br><span class="line"><span class="keyword">const</span> i18nStrings = &#123;</span><br><span class="line">  <span class="attr">greetings</span>: &#123;</span><br><span class="line">    <span class="attr">hi</span>: <span class="string">&#x27;Hallo!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(i18nPlugin, i18nStrings)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/vuejs/awesome-vue#components--libraries">awesome-vue</a> 集合了大量由社区贡献的插件和库。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gjbegjbe.github.io/2022/07/05/%E6%9F%90%E4%B8%AA%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gjbe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gjbe">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/05/%E6%9F%90%E4%B8%AA%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">某个项目的代码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-05 15:57:12" itemprop="dateCreated datePublished" datetime="2022-07-05T15:57:12+08:00">2022-07-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">gjbe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">gjbe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  


    </div>
</body>
</html>
